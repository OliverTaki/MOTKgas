<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MOTK Scheduler (v179 Origin Fixed)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* --- Theme --- */
    :root {
      --bg-app: #0e0e10; --bg-panel: #18181b; --bg-header: #121214;
      --border-color: #2a2a2e; --grid-line: #222225; --grid-line-strong: #3f3f46;
      --accent-blue: #2563eb; --select-gold: #fbbf24; --text-main: #e4e4e7; --text-dim: #71717a;
      --header-h: 36px; --axis-w: 60px; --lane-w: 65px;
      --asset-col-w: 65px;
      --sched-inspector-w: 320px;
      --card-status-not-started: #1d4ed8;
      --card-status-in-progress: #7c3aed;
      --card-status-review: #d97706;
      --card-status-approved: #0f766e;
      --card-status-completed: #166534;
      --card-camera-accent: #7dd3fc;
      --card-taskless-bg: #334155;
    }
    body { background: var(--bg-app); color: var(--text-main); font-family: sans-serif; height: 100vh; overflow: hidden; margin:0; user-select:none; }
    #app-root { display: flex; flex-direction: column; height: 100%; }

    /* Toolbar */
    #toolbar { height: 48px; background: var(--bg-header); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; padding: 0 12px; gap: 10px; flex-shrink: 0; }
    .brand a { font-weight: 900; font-size: 13px; color: #fff; text-decoration: none; margin-right: 12px; }
    .brand span { color: var(--accent-blue); }
    .info-tag { font-size: 10px; color: #666; border: 1px solid #333; padding: 2px 6px; border-radius: 4px; white-space: nowrap; }
    .btn { background: #27272a; border: 1px solid #3f3f46; color: #eee; padding: 4px 10px; font-size: 11px; border-radius: 4px; cursor: pointer; white-space: nowrap; }
    .btn:hover { background: #3f3f46; }
    .inp-dark { background: #000; border: 1px solid #333; color: #fff; font-size: 11px; padding: 3px 6px; border-radius: 4px; }
    .toolbar-group { position: relative; display: inline-flex; align-items: center; }
    .toolbar-pop {
      position: absolute;
      top: calc(100% + 6px);
      right: 0;
      min-width: 260px;
      max-width: min(360px, calc(100vw - 24px));
      max-height: min(70vh, calc(100vh - 76px));
      background: #111214;
      border: 1px solid #2f3136;
      border-radius: 8px;
      box-shadow: 0 10px 24px rgba(0,0,0,0.45);
      padding: 8px;
      z-index: 140;
      overflow: auto;
      display: none;
    }
    .toolbar-pop.open { display: block; }
    .toolbar-pop .pop-title { font-size: 10px; color: #8b8f98; margin: 0 0 6px; letter-spacing: 0.02em; }
    .toolbar-pop .pop-grid { display: grid; gap: 8px; }
    .toolbar-pop .pop-row { display: flex; align-items: center; gap: 8px; }
    .toolbar-pop .pop-row label { font-size: 10px; color: #a4a8b0; min-width: 64px; }
    #lane-menu-list { display: grid; gap: 4px; }
    .lane-row-controls { display: inline-flex; align-items: center; gap: 4px; margin-left: auto; }
    .lane-row-btn { width: 22px; height: 20px; padding: 0; line-height: 1; font-size: 10px; }
    /* Layout */
    #main { flex: 1; display: flex; overflow: hidden; position: relative; }
    #grid-wrap { flex: 1; display: flex; flex-direction: column; min-width: 0; }

    /* Headers */
    #lane-header-scroll { height: var(--header-h); display: flex; overflow: hidden; background: var(--bg-panel); border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
    #year-corner { width: var(--axis-w); flex-shrink: 0; border-right: 1px solid var(--border-color); display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; color: var(--accent-blue); background: var(--bg-header); z-index: 40; position: sticky; left: 0; }
    #lane-headers { display: flex; }
    .lane-header-cell { width: var(--lane-w); flex-shrink: 0; border-right: 1px solid var(--border-color); display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 600; color: #a1a1aa; overflow: hidden; white-space: nowrap; }
    .lane-header-cell.assets-col { width: var(--asset-col-w); color: #d1d5db; background: #15151a; justify-content: flex-start; padding-left: 8px; }

    /* Grid Body */
    #grid-scroll { flex: 1; overflow: auto; display: flex; position: relative; }
    #date-axis { width: var(--axis-w); flex-shrink: 0; background: var(--bg-header); border-right: 1px solid var(--border-color); position: sticky; left: 0; z-index: 30; min-height: 100%; }
    .date-cell { border-bottom: 1px solid var(--grid-line-strong); display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 10px; color: #71717a; box-sizing: border-box; position: relative; background: var(--bg-header); }
    .date-cell.today { background: rgba(37,99,235,0.08); color: #fff; }
    .d-main { font-size: 13px; font-weight: 700; color: #e4e4e7; line-height: 1.1; }
    .d-sub { font-size: 10px; color: #a1a1aa; line-height: 1.1; }
    .date-cell.compact .d-sub { display: none; }
    .date-cell.compact .d-main { font-size: 11px; }
    .year-marker { position: absolute; top: 0; left: 0; right: 0; background: var(--accent-blue); color: #fff; font-size: 9px; font-weight: bold; text-align: center; padding: 1px 0; z-index: 10; }

    /* Canvas */
    #grid-canvas { position: relative; display: flex; min-height: 100%; }
    .lane-col-bg { width: var(--lane-w); flex-shrink: 0; border-right: 1px solid var(--border-color); height: 100%; box-sizing: border-box; }
    .asset-col-bg { width: var(--asset-col-w); flex-shrink: 0; border-right: 1px solid var(--border-color); height: 100%; box-sizing: border-box; background: rgba(16, 16, 20, 0.95); }
    .asset-cell {
      position: absolute;
      left: 0;
      box-sizing: border-box;
      border-bottom: 1px solid #2a2a2e;
      border-left: 1px solid #2a2a2e;
      border-right: 1px solid #2a2a2e;
      overflow: hidden;
      background: rgba(20, 20, 26, 0.9);
      pointer-events: auto;
      cursor: pointer;
      color: transparent;
      font-size: 0;
      line-height: 0;
    }
    .asset-cell * { display: none !important; }
    .asset-cell.has-assets {
      background: rgba(37, 99, 235, 0.2);
    }
    .asset-cell.over {
      background: rgba(127, 29, 29, 0.42);
      border-color: #7f1d1d;
    }
    .asset-cell.selected {
      outline: 2px solid #fbbf24;
      outline-offset: -2px;
    }
    .week-sep { position: absolute; left: 0; right: 0; height: 2px; background: #52525b; z-index: 2; pointer-events: none; }

    /* Cards */
    .card { position: absolute; width: calc(var(--lane-w) - 10px); background: #2563eb; border-radius: 3px; font-size: 10px; color: #fff; padding: 2px 4px; overflow: hidden; cursor: grab; z-index: 5; box-shadow: 0 1px 3px rgba(0,0,0,0.5); display: flex; flex-direction: column; justify-content: center; }
    .card.selected { border: 1px solid #fbbf24; z-index: 20; }
    .card.multi-selected { box-shadow: 0 0 0 1px rgba(110, 231, 255, 0.85), 0 1px 3px rgba(0,0,0,0.5); }
    .card.unsaved { border: 1px dashed #f59e0b; }
    .card:hover { z-index: 15; background: #3b82f6; }
    .card.status-not_started { background: var(--card-status-not-started); }
    .card.status-in_progress { background: var(--card-status-in-progress); }
    .card.status-review { background: var(--card-status-review); }
    .card.status-approved { background: var(--card-status-approved); }
    .card.status-completed { background: var(--card-status-completed); }
    .card.taskless { background: var(--card-taskless-bg); }
    .card.camera-move { box-shadow: inset 0 0 0 2px var(--card-camera-accent), 0 1px 3px rgba(0,0,0,0.5); }
    .card-move-band {
      position: absolute;
      top: 1px;
      left: 46px;
      right: 22px;
      height: 12px;
      font-size: 8px;
      font-weight: 700;
      line-height: 12px;
      text-align: center;
      letter-spacing: 0.04em;
      padding: 0 1px;
      border-radius: 3px;
      background: rgba(2, 132, 199, 0.62);
      color: #e0f2fe;
      border: 0;
      box-sizing: border-box;
      z-index: 8;
      pointer-events: none;
    }
    .card-multi-toggle {
      position:absolute;
      top:1px;
      left:1px;
      right:auto;
      width:18px;
      height:18px;
      margin:0;
      cursor:pointer;
      accent-color:#22d3ee;
      opacity:1;
      z-index:7;
      border-radius:3px;
      border:1px solid rgba(255,255,255,0.35);
      background:rgba(17,24,39,0.65);
    }
    .card-multi-toggle:focus { outline: 1px solid rgba(255,255,255,0.65); outline-offset: 1px; }
    .card-close { position:absolute; top:0; right:2px; color:#ccc; font-weight:bold; cursor:pointer; display:none; }
    .card:hover .card-close { display:block; }
    .card-resizer { position:absolute; bottom:0; left:0; right:0; height:6px; cursor:ns-resize; }
    .card .c-id { position: absolute; top: 2px; left: 24px; font-size: 10px; opacity: 0.85; }
    .card.camera-move .c-main { margin-top: 10px; }
    .card .c-main { text-align: center; font-weight: 700; font-size: 12px; }
    .card .c-sub { text-align: center; font-size: 9px; opacity: 0.8; margin-top: 2px; }
    .card.asset-conflict {
      background: repeating-linear-gradient(
        -45deg,
        #991b1b 0,
        #991b1b 8px,
        #7f1d1d 8px,
        #7f1d1d 16px
      );
      border: 2px solid #fecaca;
      box-shadow: 0 0 0 1px #450a0a, 0 0 0 3px rgba(239, 68, 68, 0.35), 0 1px 3px rgba(0,0,0,0.6);
    }
    .card.asset-conflict:hover { background: repeating-linear-gradient(-45deg, #b91c1c 0, #b91c1c 8px, #991b1b 8px, #991b1b 16px); }
    .card-conflict-badge {
      position: absolute;
      bottom: 1px;
      right: 2px;
      font-size: 8px;
      font-weight: 700;
      line-height: 1;
      padding: 1px 3px;
      border-radius: 2px;
      background: #111827;
      color: #fee2e2;
      border: 1px solid #fca5a5;
      z-index: 8;
      pointer-events: none;
    }
    .lite-cell {
      position: absolute;
      box-sizing: border-box;
      border-bottom: 1px solid var(--grid-line-strong);
      border-right: 1px solid var(--border-color);
      background: rgba(16, 18, 23, 0.9);
      overflow: hidden;
      padding: 4px;
    }
    .lite-token {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-bottom: 3px;
      padding: 2px 4px;
      border-radius: 4px;
      font-size: 10px;
      color: #e5e7eb;
      border: 1px solid rgba(255,255,255,0.15);
      cursor: pointer;
      background: rgba(37, 99, 235, 0.35);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .lite-token.selected {
      border-color: #facc15;
      box-shadow: 0 0 0 1px rgba(250, 204, 21, 0.45) inset;
    }
    .lite-token.multi-selected {
      border-color: #22d3ee;
      box-shadow: 0 0 0 1px rgba(34, 211, 238, 0.42) inset;
    }
    .lite-token.more {
      justify-content: center;
      color: #9ca3af;
      border-style: dashed;
      cursor: default;
    }
    .lite-token:last-child { margin-bottom: 0; }
    .lite-token.status-not_started { background: var(--card-status-not-started); }
    .lite-token.status-in_progress { background: var(--card-status-in-progress); }
    .lite-token.status-review { background: var(--card-status-review); }
    .lite-token.status-approved { background: var(--card-status-approved); }
    .lite-token.status-completed { background: var(--card-status-completed); }
    .lite-token.taskless { background: var(--card-taskless-bg); }
    .lite-token .lt-order { font-size: 9px; opacity: 0.85; min-width: 18px; text-align: right; }
    .lite-token .lt-main { min-width: 0; overflow: hidden; text-overflow: ellipsis; }
    .lite-token .lt-arrow { font-size: 10px; opacity: 0.75; }
    .gap-marker {
      position: absolute;
      width: calc(var(--lane-w) - 10px);
      border: 1px dashed #f59e0b;
      background: rgba(245, 158, 11, 0.14);
      border-radius: 3px;
      z-index: 4;
      pointer-events: none;
    }
    .gap-hitbox {
      position: absolute;
      width: calc(var(--lane-w) - 10px);
      border: 1px dashed rgba(245, 158, 11, 0.18);
      background: rgba(245, 158, 11, 0.02);
      border-radius: 3px;
      z-index: 4;
      cursor: pointer;
      pointer-events: auto;
    }
    .gap-hitbox:hover {
      border-color: rgba(245, 158, 11, 0.45);
      background: rgba(245, 158, 11, 0.08);
    }
    .drag-preview {
      position: absolute;
      width: calc(var(--lane-w) - 10px);
      border: 1px dashed rgba(110, 231, 255, 0.95);
      background: rgba(14, 165, 233, 0.22);
      border-radius: 3px;
      z-index: 60;
      pointer-events: none;
    }
    .drag-preview.resize { border-color: rgba(250, 204, 21, 0.95); background: rgba(250, 204, 21, 0.18); }
    .drag-preview.block { border-color: rgba(34, 197, 94, 0.95); background: rgba(34, 197, 94, 0.16); }
    .drop-slot-line {
      position: absolute;
      height: 2px;
      width: calc(var(--lane-w) - 10px);
      background: #22d3ee;
      box-shadow: 0 0 0 1px rgba(8, 47, 73, 0.65);
      z-index: 61;
      pointer-events: none;
    }
    .drop-slot-line.resize { background: #facc15; box-shadow: 0 0 0 1px rgba(113, 63, 18, 0.65); }
    .drop-slot-line.block { background: #22c55e; box-shadow: 0 0 0 1px rgba(20, 83, 45, 0.65); }
    .lane-boundary-line {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 1px;
      background: #616b7a;
      pointer-events: none;
      z-index: 3;
      opacity: 0.7;
    }

    /* Inspector */
    #inspector { width: var(--sched-inspector-w); flex: 0 0 var(--sched-inspector-w); background: var(--bg-panel); border-left: 1px solid var(--border-color); display: flex; flex-direction: column; overflow: auto; min-width: 260px; max-width: 720px; transition: width 0.2s, flex-basis 0.2s; user-select: text; -webkit-user-select: text; }
    #inspector.closed { width: 0 !important; flex-basis: 0 !important; min-width: 0 !important; padding: 0 !important; border: 0 !important; overflow: hidden !important; }
    #inspector-resizer { width: 6px; cursor: ew-resize; flex: 0 0 6px; background: transparent; }
    #inspector-resizer:hover { background: rgba(255,255,255,0.06); }
    #main.inspector-closed #inspector-resizer { display: none; }
    .ins-tabs { display: flex; border-bottom: 1px solid var(--border-color); background: var(--bg-header); height: 32px; }
    .ins-tab { flex: 1; display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 600; color: var(--text-dim); cursor: pointer; border-bottom: 2px solid transparent; }
    .ins-tab.active { color: #fff; border-bottom-color: var(--accent-blue); background: var(--bg-panel); }
    .ins-panel { flex: 1; overflow-y: auto; padding: 12px; display: flex; flex-direction: column; gap: 10px; }
    .hidden { display: none !important; }
    .inp-group { display: flex; flex-direction: column; gap: 4px; font-size: 11px; color: #a1a1aa; }
    .inp { background: #000; border: 1px solid #333; color: #eee; padding: 6px 8px; border-radius: 4px; width: 100%; box-sizing: border-box; }
    .date-wrap { position: relative; width: 100%; }
    .date-wrap .inp { padding-right: 28px; }
    .date-picker-overlay { position: absolute; right: 6px; top: 50%; transform: translateY(-50%); width: 20px; height: 20px; border: none; background: transparent; color: transparent; padding: 0; margin: 0; }
    .date-picker-overlay::-webkit-datetime-edit { color: transparent; }
    .date-picker-overlay::-webkit-calendar-picker-indicator { filter: invert(1); opacity: 0.9; }
    .date-picker-overlay { color-scheme: light; }

    /* Overlays */
    .settings-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.65); z-index: 120; display: flex; align-items: center; justify-content: center; padding: 16px; }
    .settings-modal.hidden { display: none; }
    .settings-panel { width: min(960px, 96vw); max-height: 92vh; overflow: auto; background: #17171a; border: 1px solid #333; border-radius: 10px; box-shadow: 0 10px 40px rgba(0,0,0,0.45); }
    .settings-head { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; border-bottom: 1px solid #2c2c30; background: #121214; position: sticky; top: 0; z-index: 1; }
    .settings-title { font-size: 13px; font-weight: 700; color: #fff; }
    .settings-body { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; padding: 12px; }
    .settings-section { border: 1px solid #2d2d31; border-radius: 8px; padding: 10px; background: #1c1c20; display: flex; flex-direction: column; gap: 8px; }
    .settings-section h4 { margin: 0; font-size: 12px; color: #ddd; letter-spacing: 0.03em; }
    .settings-grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .settings-grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; }
    .settings-inline { display: flex; gap: 6px; align-items: flex-end; }
    .settings-inline .inp-group { flex: 1 1 auto; }
    .settings-inline .btn { height: 26px; }
    .settings-actions { display: flex; justify-content: flex-end; gap: 8px; padding: 0 12px 12px; }
    .undo-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.65); z-index: 130; display: flex; align-items: center; justify-content: center; padding: 16px; }
    .undo-modal.hidden { display: none; }
    .undo-panel { width: min(760px, 96vw); max-height: 90vh; overflow: hidden; background: #17171a; border: 1px solid #333; border-radius: 10px; box-shadow: 0 10px 40px rgba(0,0,0,0.45); display: flex; flex-direction: column; }
    .undo-head { display: flex; align-items: center; justify-content: space-between; padding: 10px 12px; border-bottom: 1px solid #2c2c30; background: #121214; }
    .undo-title { font-size: 13px; font-weight: 700; color: #fff; }
    .undo-body { display: flex; flex-direction: column; gap: 8px; padding: 12px; min-height: 220px; }
    .undo-toolbar { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
    .undo-list { border: 1px solid #2d2d31; border-radius: 8px; overflow: auto; background: #101014; min-height: 180px; max-height: 52vh; }
    .undo-item { padding: 8px 10px; border-bottom: 1px solid #202024; cursor: pointer; display: flex; flex-direction: column; gap: 3px; font-size: 11px; }
    .undo-item:last-child { border-bottom: 0; }
    .undo-item:hover { background: #1a1a1f; }
    .undo-item.active { background: #10263f; outline: 1px solid #2563eb; }
    .undo-item.snapshot { background: #121b25; }
    .undo-item.snapshot.named { background: #1a2a1a; }
    .undo-item.snapshot.named .undo-main { color: #bbf7d0; }
    .undo-main { color: #e5e7eb; font-weight: 600; }
    .undo-meta { color: #9ca3af; font-size: 10px; }
    .undo-empty { color: #9ca3af; font-size: 11px; padding: 12px; }
    .undo-actions { display: flex; justify-content: flex-end; gap: 8px; padding: 0 12px 12px; }
    .remove-card-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.65); z-index: 140; display: flex; align-items: center; justify-content: center; padding: 16px; }
    .remove-card-modal.hidden { display: none; }
    .remove-card-panel {
      width: min(420px, 96vw);
      background: #17171a;
      border: 1px solid #333;
      border-radius: 10px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.45);
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 12px;
    }
    .remove-card-title { color: #fff; font-size: 13px; font-weight: 700; }
    .remove-card-msg { color: #aab0ba; font-size: 12px; }
    .remove-card-actions { display: flex; justify-content: flex-end; gap: 8px; }
    .tz-guard-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.72); z-index: 160; display: flex; align-items: center; justify-content: center; padding: 16px; }
    .tz-guard-modal.hidden { display: none; }
    .tz-guard-panel {
      width: min(520px, 96vw);
      background: #17171a;
      border: 1px solid #333;
      border-radius: 10px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.45);
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 12px;
    }
    .tz-guard-title { color: #fff; font-size: 14px; font-weight: 700; }
    .tz-guard-msg { color: #aab0ba; font-size: 12px; line-height: 1.5; white-space: pre-line; }
    .tz-guard-actions { display: flex; justify-content: flex-end; gap: 8px; }
    .lane-row { display: flex; gap: 6px; padding: 4px; border-bottom: 1px solid #222; font-size: 11px; align-items: center; }
    .list-item { display: flex; align-items: center; justify-content: space-between; gap: 8px; padding: 6px 8px; border-bottom: 1px solid #222; cursor: pointer; font-size: 11px; line-height: 1.2; flex-wrap: nowrap; }
    .list-item.unassigned .li-title { color: #ef4444; }
    .list-item.attention .li-title { color: #ef4444; }
    .li-left { display: flex; align-items: center; gap: 6px; min-width: 0; flex: 1; flex-wrap: nowrap; }
    .li-title { font-weight: 700; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; min-width: 0; flex: 1 1 auto; }
    .li-sub { font-size: 10px; color: #888; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; min-width: 0; flex: 0 1 auto; }
    .li-lane { font-size: 10px; padding: 2px 6px; border: 1px solid #333; border-radius: 4px; color: #aaa; white-space: nowrap; max-width: 40%; overflow: hidden; text-overflow: ellipsis; flex: 0 0 auto; text-align: right; margin-left: auto; }
    .list-item.unassigned .li-lane { color: #ef4444; border-color: #ef4444; }
    .list-item.attention .li-lane { color: #ef4444; border-color: #ef4444; }
    .status-pill {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-height:22px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid #3f3f46;
      font-size:10px;
      font-weight:700;
      letter-spacing:0.02em;
      text-transform:uppercase;
    }
    .status-pill.not_started { background:#1e3a8a; color:#bfdbfe; border-color:#1d4ed8; }
    .status-pill.in_progress { background:#4c1d95; color:#ddd6fe; border-color:#7c3aed; }
    .status-pill.review { background:#78350f; color:#fde68a; border-color:#d97706; }
    .status-pill.approved { background:#134e4a; color:#99f6e4; border-color:#0f766e; }
    .status-pill.completed { background:#14532d; color:#bbf7d0; border-color:#16a34a; }
    .task-suggest-box {
      position: absolute;
      left: 0;
      right: 34px;
      top: calc(100% + 2px);
      z-index: 25;
      max-height: 200px;
      overflow: auto;
      border: 1px solid #3a3a3f;
      border-radius: 6px;
      background: #0f0f12;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.45);
      display: none;
    }
    .task-suggest-item {
      display: block;
      width: 100%;
      text-align: left;
      border: 0;
      border-bottom: 1px solid #242428;
      background: transparent;
      color: #e7e7ea;
      font-size: 11px;
      line-height: 1.25;
      padding: 6px 8px;
      cursor: pointer;
    }
    .task-suggest-item:hover,
    .task-suggest-item:focus {
      background: #1f2937;
      outline: none;
    }
    .task-suggest-item .id {
      display: inline-block;
      min-width: 72px;
      color: #93c5fd;
      margin-right: 6px;
    }

    #saveStatus { font-size: 10px; font-weight: bold; margin-right: 10px; opacity: 0; transition: opacity 0.5s; }
    #saveStatus.saving { color: #fbbf24; opacity: 1; }
    #saveStatus.saved { color: #4ade80; opacity: 1; }
    #saveStatus.error { color: #ef4444; opacity: 1; }

    #loadingSpinner { position:fixed; inset:0; background:rgba(0,0,0,0.8); display:none; z-index:100; align-items:center; justify-content:center; flex-direction:column; }
    .spinner { width:24px; height:24px; border:3px solid #555; border-top-color:#fff; border-radius:50%; animation:spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>

<div id="app-root">
  <div id="toolbar">
    <div class="brand">
      <a id="brand-link" href="<?= ScriptApp.getService().getUrl() ?>" target="_blank">MOTK <span>SCHED</span></a>
      <select id="sched-switch" class="inp-dark" style="margin-left:8px; min-width:140px;"></select>
    </div>

    <div id="config-info" style="display:flex; gap:4px;"></div>

    <div style="flex:1"></div>
    <div class="toolbar-group">
      <button id="btn-view" class="btn" title="View">VIEW</button>
      <div id="view-menu-popup" class="toolbar-pop">
        <div class="pop-title">View</div>
        <div class="pop-grid">
          <div class="pop-row">
            <label for="sel-start-preset">Start</label>
            <select id="sel-start-preset" class="inp-dark" style="width:130px;">
              <option value="today">Today</option>
              <option value="yesterday">Yesterday</option>
              <option value="tomorrow">Tomorrow</option>
              <option value="this_monday">This Monday</option>
              <option value="next_monday">Next Monday</option>
              <option value="custom">Custom</option>
            </select>
            <input id="start-date" class="inp-dark" type="text" list="start-date-suggest" placeholder="YYYY/MM/DD or today" style="flex:1;">
            <datalist id="start-date-suggest">
              <option value="today"></option>
              <option value="yesterday"></option>
              <option value="tomorrow"></option>
              <option value="this monday"></option>
              <option value="next monday"></option>
              <option value="<?= Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy/MM/dd") ?>"></option>
            </datalist>
          </div>
          <div class="pop-row">
            <label for="sel-end-preset">End</label>
            <select id="sel-end-preset" class="inp-dark" style="width:130px;">
              <option value="today">Today</option>
              <option value="yesterday">Yesterday</option>
              <option value="tomorrow">Tomorrow</option>
              <option value="this_monday">This Monday</option>
              <option value="next_monday">Next Monday</option>
              <option value="custom">Custom</option>
            </select>
            <input id="end-date" class="inp-dark" type="text" list="end-date-suggest" placeholder="YYYY/MM/DD or today" style="flex:1;">
            <datalist id="end-date-suggest">
              <option value="today"></option>
              <option value="yesterday"></option>
              <option value="tomorrow"></option>
              <option value="this monday"></option>
              <option value="next monday"></option>
              <option value="<?= Utilities.formatDate(new Date(), Session.getScriptTimeZone(), "yyyy/MM/dd") ?>"></option>
            </datalist>
          </div>
          <div class="pop-row">
            <label for="sel-view-mode">Mode</label>
            <select id="sel-view-mode" class="inp-dark" style="flex:1;">
              <option value="grid">Grid</option>
              <option value="lite">Lite (day)</option>
            </select>
          </div>
          <div class="pop-row">
            <label for="sel-range">Range</label>
            <select id="sel-range" class="inp-dark" style="flex:1;">
              <option value="1">1 Day</option>
              <option value="5">1 Week</option>
              <option value="14">2 Weeks</option>
              <option value="30">1 Month</option>
              <option value="90">3 Months</option>
              <option value="180">6 Months</option>
              <option value="365">1 Year</option>
              <option value="730">2 Years</option>
              <option value="custom">Custom</option>
            </select>
          </div>
          <div style="font-size:10px; color:#8b8f98;">Range / End: whichever you change later is applied.</div>
          <div class="pop-row">
            <label for="inp-zoom">Zoom</label>
            <input id="inp-zoom" type="range" min="1" max="100" value="60" style="flex:1;">
            <input id="inp-zoom-val" type="number" value="60" class="inp-dark" style="width:58px; text-align:center;">
          </div>
          <div class="pop-row" style="justify-content:flex-end;">
            <button id="btn-view-fit" class="btn" type="button" title="Fit current Start/End in view">Fit</button>
            <button id="btn-save-view" class="btn" type="button" title="Save current View settings">Save View</button>
          </div>
          <label style="font-size:11px; color:#aaa; display:flex; gap:6px; align-items:center;">
            <input type="checkbox" id="chk-push"> Auto-Push
          </label>
        </div>
      </div>
    </div>
    <div class="toolbar-group">
      <button id="btn-lanes" class="btn" title="Lane Visibility">LANE</button>
      <div id="lane-menu-popup" class="toolbar-pop">
        <div class="pop-title">Lanes</div>
        <div class="pop-grid" style="margin-bottom:6px;">
          <div class="pop-row">
            <label for="inp-lane-w">Lane W</label>
            <input id="inp-lane-w" type="number" class="inp-dark" style="width:78px;">
          </div>
          <div class="pop-row">
            <label for="inp-asset-w">Assets W</label>
            <input id="inp-asset-w" type="number" class="inp-dark" style="width:78px;">
          </div>
          <div class="pop-row" style="justify-content:flex-end;">
            <button id="btn-save-lane" class="btn" type="button" title="Save current Lane settings">Save Lane</button>
          </div>
        </div>
        <div id="lane-menu-list"></div>
      </div>
    </div>
    <div id="saveStatus"></div>
    <button id="btn-undo" class="btn" title="Undo last scheduler change">Undo</button>
    <button id="btn-insp" class="btn">Insp</button>
    <button id="btn-settings" class="btn" title="Settings">Settings</button>
    <button id="btn-sched-index" class="btn" title="Open schedule index">Index</button>
    <button id="btn-publish" class="btn" title="Publish schedule to Tasks">Publish</button>
  </div>

  <div id="main">
    <div id="grid-wrap">
      <div id="lane-header-scroll">
        <div id="year-corner">----</div>
        <div id="lane-headers"></div>
      </div>
      <div id="grid-scroll">
        <div id="date-axis"></div>
        <div id="grid-canvas"></div>
      </div>
    </div>

    <div id="inspector-resizer" title="Resize Inspector"></div>

    <div id="inspector">
       <div class="ins-tabs">
          <div id="tab-edit" class="ins-tab active">EDIT</div>
          <div id="tab-list" class="ins-tab">CARD LIST</div>
          <div id="btn-close-insp" style="width:30px; display:flex; align-items:center; justify-content:center; cursor:pointer;">âœ•</div>
       </div>

       <div id="panel-edit" class="ins-panel">
          <div id="insp-content" style="display:flex; flex-direction:column; gap:8px;"></div>
       </div>

       <div id="panel-list" class="ins-panel hidden">
          <button id="btn-auto" class="btn" style="width:100%; margin-bottom:8px;">Auto Create Cards</button>
          <input id="inp-filter" type="text" class="inp" placeholder="Search..." style="margin-bottom:8px;">
          <div id="card-list-container"></div>
          <button id="btn-new" class="btn" style="width:100%; margin-top:8px;">+ New Card</button>
       </div>
    </div>
  </div>
</div>

<div id="settings-modal" class="settings-modal hidden">
  <div class="settings-panel">
    <div class="settings-head">
      <div class="settings-title">Scheduler Settings</div>
      <button id="btn-settings-close" class="btn" type="button">Close</button>
    </div>
    <div class="settings-body">
      <section class="settings-section">
        <h4>Schedule Title</h4>
        <div class="settings-grid-2">
          <div class="inp-group">
            <label for="sched-rename-input">Title</label>
            <input id="sched-rename-input" class="inp-dark" type="text" placeholder="Schedule title">
          </div>
          <div style="display:flex; align-items:flex-end; justify-content:flex-end;">
            <button id="btn-rename-sched-save" class="btn" type="button">Save Title</button>
          </div>
        </div>
      </section>

      <section class="settings-section">
        <h4>Card Display</h4>
        <div class="settings-grid-2">
          <div class="inp-group">
            <label for="sel-card-main">Main (center)</label>
            <select id="sel-card-main" class="inp-dark">
              <option value="shot_code">Shot Code</option>
              <option value="shot_id">Shot ID</option>
              <option value="task_name">Task Name</option>
              <option value="task_status">Task Status</option>
              <option value="task_assignee">Task Assignee</option>
              <option value="task_id">Task ID</option>
            </select>
          </div>
          <div class="inp-group">
            <label for="sel-card-sub">Sub (bottom)</label>
            <select id="sel-card-sub" class="inp-dark">
              <option value="shot_code">Shot Code</option>
              <option value="shot_id">Shot ID</option>
              <option value="task_name">Task Name</option>
              <option value="task_status">Task Status</option>
              <option value="task_assignee">Task Assignee</option>
              <option value="task_id">Task ID</option>
            </select>
          </div>
        </div>
        <div class="settings-grid-2" style="margin-top:8px;">
          <div class="inp-group">
            <label for="sel-taskless-main">Taskless Main (center)</label>
            <select id="sel-taskless-main" class="inp-dark">
              <option value="card_memo">Card Memo</option>
              <option value="card_length">Card Length</option>
              <option value="card_id">Card ID</option>
            </select>
          </div>
          <div class="inp-group">
            <label for="sel-taskless-sub">Taskless Sub (bottom)</label>
            <select id="sel-taskless-sub" class="inp-dark">
              <option value="card_length">Card Length</option>
              <option value="card_memo">Card Memo</option>
              <option value="card_id">Card ID</option>
            </select>
          </div>
        </div>
        <div class="settings-inline">
          <div class="inp-group">
            <label for="sel-card-add-field">Add field</label>
            <select id="sel-card-add-field" class="inp-dark"></select>
          </div>
          <div class="inp-group" style="max-width:130px;">
            <label for="sel-card-add-target">Target</label>
            <select id="sel-card-add-target" class="inp-dark">
              <option value="main">Main</option>
              <option value="sub">Sub</option>
            </select>
          </div>
          <button id="btn-card-add-field" class="btn" type="button">+ Add</button>
        </div>
      </section>

      <section class="settings-section">
        <h4>Card Colors</h4>
        <div class="settings-grid-3">
          <div class="inp-group">
            <label for="inp-color-not-started">not_started</label>
            <input id="inp-color-not-started" class="inp-dark" type="color" value="#1d4ed8">
          </div>
          <div class="inp-group">
            <label for="inp-color-in-progress">in_progress</label>
            <input id="inp-color-in-progress" class="inp-dark" type="color" value="#7c3aed">
          </div>
          <div class="inp-group">
            <label for="inp-color-review">review</label>
            <input id="inp-color-review" class="inp-dark" type="color" value="#d97706">
          </div>
          <div class="inp-group">
            <label for="inp-color-approved">approved</label>
            <input id="inp-color-approved" class="inp-dark" type="color" value="#0f766e">
          </div>
          <div class="inp-group">
            <label for="inp-color-completed">completed</label>
            <input id="inp-color-completed" class="inp-dark" type="color" value="#166534">
          </div>
          <div class="inp-group">
            <label for="inp-color-camera">camera movement</label>
            <input id="inp-color-camera" class="inp-dark" type="color" value="#7dd3fc">
          </div>
          <div class="inp-group">
            <label for="inp-color-taskless">taskless card</label>
            <input id="inp-color-taskless" class="inp-dark" type="color" value="#334155">
          </div>
        </div>
      </section>

    </div>
    <div class="settings-actions">
      <button id="btn-settings-save" class="btn" type="button">Save Settings</button>
    </div>
  </div>
</div>

<div id="undo-modal" class="undo-modal hidden">
  <div class="undo-panel">
    <div class="undo-head">
      <div class="undo-title">Snapshot History (Scheduler)</div>
      <button id="btn-undo-modal-close" class="btn" type="button">Close</button>
    </div>
    <div class="undo-body">
      <div class="undo-toolbar">
        <div id="undo-summary" class="undo-meta">Loading...</div>
        <button id="btn-undo-snap-take" class="btn" type="button">Take SNAP</button>
        <button id="btn-undo-snap-rename" class="btn" type="button">Rename SNAP</button>
        <button id="btn-undo-modal-refresh" class="btn" type="button">Refresh</button>
      </div>
      <div id="undo-list" class="undo-list"></div>
    </div>
    <div class="undo-actions">
      <button id="btn-undo-apply" class="btn" type="button">Restore Selected SNAP</button>
    </div>
  </div>
</div>

<div id="remove-card-modal" class="remove-card-modal hidden">
  <div class="remove-card-panel">
    <div class="remove-card-title">Remove Card</div>
    <div id="remove-card-msg" class="remove-card-msg">Remove this card from lane?</div>
    <div class="remove-card-actions">
      <button id="btn-remove-card-cancel" class="btn" type="button">Cancel</button>
      <button id="btn-remove-card-confirm" class="btn" type="button">Remove</button>
    </div>
  </div>
</div>

<div id="tz-guard-modal" class="tz-guard-modal hidden">
  <div class="tz-guard-panel">
    <div class="tz-guard-title">Timezone Required</div>
    <div id="tz-guard-msg" class="tz-guard-msg">Project timezone is not configured.</div>
    <div class="tz-guard-actions">
      <button id="btn-tz-guard-reload" class="btn" type="button">Reload</button>
    </div>
  </div>
</div>

<div id="loadingSpinner">
  <div class="spinner"></div>
  <div id="loadingSpinnerText" style="color:#fff; font-size:11px; margin-top:10px;">Loading...</div>
</div>

<script>
window.app = (function() {
  const config = {
    slotMin: 30,
    workHours: 8,
    originDate: null,
    originDisplayText: '',
    originAnchor: null
  };

  const state = {
    tasks: [], members: [], cards: {}, lanes: [],
    tasksById: {},
    startDate: new Date(), dayCount: 14, slotPx: 20,
    endDate: null, startPreset: 'custom', endPreset: 'custom', viewDriver: 'range',
    viewMode: 'grid',
    workDayMap: [], selection: null, autoPush: true,
    schedId: 'sched_0001', schedName: 'Schedule', scriptUrl: (function(){ try { return location.origin + location.pathname; } catch (_) { return location.pathname || ''; } })(), scriptUrlServer: '', viewMeta: {}, allScheds: [],
    laneWidth: 65,
    assetColWidth: 65,
    assetColumnVisible: true,
    viewDirty: false,
    laneDirty: false,
    cardDisplayMain: 'shot_code',
    cardDisplaySub: 'task_name',
    tasklessDisplayMain: 'card_memo',
    tasklessDisplaySub: 'card_length',
    customCardDisplayFields: [],
    cardColors: {
      notStarted: '#1d4ed8',
      inProgress: '#7c3aed',
      review: '#d97706',
      approved: '#0f766e',
      completed: '#166534',
      camera: '#7dd3fc',
      taskless: '#334155'
    },
    assetCapacityById: {},
    assetNameById: {},
    assetCapacityDefault: 1,
    assetUsageBySlot: {},
    cardAssetConflictById: {},
    assetUsageStats: { conflictSlots: 0, overloadedAssets: 0, affectedCards: 0 },
    legacyOffsetWarned: false,
    gapSelection: null,
    assetCellSelection: null,
    multiSelection: [],
    multiAnchorCardId: null,
    dragPreview: null,
    suppressCanvasPickUntil: 0,
    requestedSchedId: '',
    requestedSchedApplied: false,
    requestedViewMode: '',
    undoBusy: false,
    undoPhase: '',
    undoOptions: [],
    undoSelectedKey: '',
    undoLoading: false,
    undoLoadError: '',
    removeCardPendingId: '',
    snapBusy: false,
    snapPhase: '',
    publishBusy: false,
    publishPhase: '',
    projectTimezoneRaw: '',
    projectTimezoneResolved: '',
    timezoneConfigured: true,
    timezoneBlocked: false,
    autoSnapPending: false,
    autoSnapThresholdMs: 10 * 60 * 1000,
    lastSnapshotAtMs: Date.now(),
    lastSnapshotAttemptAtMs: 0,
    commitOpId: '',
    commitQueue: [],
    commitInflight: null,
    commitSeq: 0,
    disableBatchCommit: false,
    inspEdit: { active: false, cardId: null, fields: {}, dirty: {}, commitLock: false, isTyping: false, isEditingStart: false, isEditingEnd: false, needsResyncAfterEdit: false, refs: {}, timers: {} }
  };
  const readRequestedSchedId_ = () => {
    try {
      var usp = new URLSearchParams(location.search || '');
      return String(usp.get('schedId') || usp.get('sid') || '').trim();
    } catch (_) {
      return '';
    }
  };
  const readRequestedViewMode_ = () => {
    try {
      var usp = new URLSearchParams(location.search || '');
      var raw = String(usp.get('viewMode') || usp.get('vm') || '').trim().toLowerCase();
      if (raw === 'lite') return 'lite';
      if (raw === 'grid') return 'grid';
      return '';
    } catch (_) {
      return '';
    }
  };
  state.requestedSchedId = readRequestedSchedId_();
  state.requestedSchedApplied = !state.requestedSchedId;
  state.requestedViewMode = readRequestedViewMode_();
  const INSPECTOR_FIELDS_MODE_KEY = 'motk:scheduler:inspectorFieldsMode';
  try {
    const mode = localStorage.getItem(INSPECTOR_FIELDS_MODE_KEY);
    state.inspectorFieldsMode = mode || 'card';
  } catch (_) {
    state.inspectorFieldsMode = 'card';
  }

  const SCHED_CACHE_KEY = 'MOTK_SCHED_CACHE_V2';
  const SCHED_CACHE_TS_KEY = 'MOTK_SCHED_CACHE_TS_V2';
  const SCHED_LOAD_DIAG_KEY = 'MOTK_SCHED_LOAD_DIAG_V1';
  const SCHED_LAST_SNAPSHOT_TS_KEY = 'MOTK_SCHED_LAST_SNAPSHOT_TS_V1';
  const SCHED_CACHE_MAX_AGE_MS = 10 * 60 * 1000;
  const INSPECTOR_WIDTH_KEY = 'motk:sched:inspectorW';
  const INSPECTOR_MIN_W = 260;
  const INSPECTOR_MAX_W = 720;
  const INSPECTOR_NARROW_W = 300;

  const markSnapshotTs_ = (tsLike) => {
    let ms = Date.parse(String(tsLike || ''));
    if (!isFinite(ms) || ms <= 0) ms = Date.now();
    state.lastSnapshotAtMs = ms;
    try { localStorage.setItem(SCHED_LAST_SNAPSHOT_TS_KEY, String(ms)); } catch (_) {}
  };
  try {
    const rawSnapTs = Number(localStorage.getItem(SCHED_LAST_SNAPSHOT_TS_KEY) || 0);
    if (isFinite(rawSnapTs) && rawSnapTs > 0) state.lastSnapshotAtMs = rawSnapTs;
  } catch (_) {}

  const els = {
    gridScroll: document.getElementById('grid-scroll'),
    headerScroll: document.getElementById('lane-header-scroll'),
    laneHeaders: document.getElementById('lane-headers'),
    dateAxis: document.getElementById('date-axis'),
    canvas: document.getElementById('grid-canvas'),
    yearCorner: document.getElementById('year-corner'),
    inspContent: document.getElementById('insp-content'),
    cardList: document.getElementById('card-list-container'),
    configInfo: document.getElementById('config-info'),
    settingsModal: document.getElementById('settings-modal'),
    viewMenuPopup: document.getElementById('view-menu-popup'),
    laneMenuPopup: document.getElementById('lane-menu-popup')
  };

  const setInspectorWidth_ = (w) => {
    if (!w || !isFinite(w)) return;
    const clamped = Math.max(INSPECTOR_MIN_W, Math.min(INSPECTOR_MAX_W, Math.round(w)));
    document.documentElement.style.setProperty('--sched-inspector-w', `${clamped}px`);
    const insp = document.getElementById('inspector');
    if (insp) insp.classList.toggle('inspector-narrow', clamped < INSPECTOR_NARROW_W);
    return clamped;
  };
  const setInspectorClosed_ = (closed) => {
    const insp = document.getElementById('inspector');
    const main = document.getElementById('main');
    if (!insp || !main) return;
    if (closed) {
      insp.classList.add('closed');
      main.classList.add('inspector-closed');
    } else {
      insp.classList.remove('closed');
      main.classList.remove('inspector-closed');
    }
  };
  const setSettingsModalOpen_ = (open) => {
    var modal = els.settingsModal || document.getElementById('settings-modal');
    if (!modal) return;
    if (open) modal.classList.remove('hidden');
    else modal.classList.add('hidden');
  };
  const setUndoModalOpen_ = (open) => {
    var modal = document.getElementById('undo-modal');
    if (!modal) return;
    if (open) modal.classList.remove('hidden');
    else modal.classList.add('hidden');
  };
  const setRemoveCardModalOpen_ = (open) => {
    var modal = document.getElementById('remove-card-modal');
    if (!modal) return;
    if (open) modal.classList.remove('hidden');
    else modal.classList.add('hidden');
  };
  const setTimezoneGuardModalOpen_ = (open) => {
    var modal = document.getElementById('tz-guard-modal');
    if (!modal) return;
    if (open) modal.classList.remove('hidden');
    else modal.classList.add('hidden');
  };
  const timezoneGuardMessage_ = () => {
    const raw = String(state.projectTimezoneRaw || '').trim();
    if (raw) return '';
    return 'Project timezone is not configured in project_meta.\nPlease set "Timezone" first. Until then, scheduler actions are disabled.';
  };
  const syncTimezoneGuardUi_ = () => {
    const blocked = !state.timezoneConfigured;
    state.timezoneBlocked = blocked;
    const msgEl = document.getElementById('tz-guard-msg');
    if (msgEl) msgEl.textContent = timezoneGuardMessage_();
    setTimezoneGuardModalOpen_(blocked);
    const main = document.getElementById('main');
    if (main) main.style.pointerEvents = blocked ? 'none' : '';
    const blockIds = [
      'btn-view', 'btn-lanes', 'btn-undo', 'btn-insp', 'btn-settings', 'btn-publish',
      'btn-auto', 'btn-new', 'btn-save-view', 'btn-save-lane', 'btn-settings-save',
      'btn-rename-sched-save', 'sched-switch', 'start-date', 'end-date', 'sel-start-preset',
      'sel-end-preset', 'sel-range', 'inp-filter', 'chk-push'
    ];
    blockIds.forEach((id) => {
      var el = document.getElementById(id);
      if (!el) return;
      if ('disabled' in el) el.disabled = blocked;
      if (blocked) el.setAttribute('aria-disabled', 'true');
      else el.removeAttribute('aria-disabled');
    });
  };
  const ensureTimezoneReady_ = () => {
    if (state.timezoneConfigured) return true;
    syncTimezoneGuardUi_();
    try { utils.saveStatus('error', 'Timezone is not configured'); } catch (_) {}
    return false;
  };
  const requestRemoveCardFromLane_ = (cardId) => {
    if (state.undoBusy) return;
    var key = String(cardId || '').trim();
    if (!key || !state.cards[key]) return;
    state.removeCardPendingId = key;
    var msg = document.getElementById('remove-card-msg');
    if (msg) msg.textContent = 'Remove this card from lane?';
    setRemoveCardModalOpen_(true);
  };
  const cancelRemoveCardFromLane_ = () => {
    state.removeCardPendingId = '';
    setRemoveCardModalOpen_(false);
  };
  const confirmRemoveCardFromLane_ = () => {
    var key = String(state.removeCardPendingId || '').trim();
    cancelRemoveCardFromLane_();
    if (!key || !state.cards[key]) return;
    var c = state.cards[key];
    c.laneId = '';
    render.grid();
    ui.renderCardList();
    ui.refreshInspectorValuesFromCard();
    actions.commit(c.id, 'update');
  };
  const formatUndoTs_ = (ts) => {
    const raw = String(ts || '').trim();
    if (!raw) return '-';
    const d = new Date(raw);
    if (!isNaN(d.getTime())) {
      return `${d.getFullYear()}/${String(d.getMonth() + 1).padStart(2, '0')}/${String(d.getDate()).padStart(2, '0')} ${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}:${String(d.getSeconds()).padStart(2, '0')}`;
    }
    return raw;
  };
  const renderUndoModalList_ = () => {
    const listEl = document.getElementById('undo-list');
    const summaryEl = document.getElementById('undo-summary');
    const applyBtn = document.getElementById('btn-undo-apply');
    const takeSnapBtn = document.getElementById('btn-undo-snap-take');
    const renameSnapBtn = document.getElementById('btn-undo-snap-rename');
    if (!listEl || !summaryEl || !applyBtn) return;
    const items = Array.isArray(state.undoOptions) ? state.undoOptions.filter((it) => !!it && typeof it === 'object') : [];
    const selected = items.find((it) => String((it && it.undoKey) || '') === String(state.undoSelectedKey || '')) || null;
    const selectedKind = String((selected && selected.kind) || '').trim().toLowerCase();
    const selectedIsSnapshot = (selectedKind === 'snapshot');
    const isLoading = !!state.undoLoading;
    const hasError = String(state.undoLoadError || '').trim();
    const snapCount = items.filter((it) => String((it && it.kind) || '').toLowerCase() === 'snapshot').length;
    const namedCount = items.filter((it) => !!(it && it.snapshotNamed)).length;
    summaryEl.textContent = isLoading
      ? 'Loading undo history...'
      : (hasError ? (`Error: ${hasError}`) : (`SNAP:${snapCount} | named:${namedCount}`));
    applyBtn.disabled = isLoading || !!hasError || !state.undoSelectedKey || state.undoBusy || !selectedIsSnapshot;
    applyBtn.textContent = 'Restore Selected SNAP';
    if (takeSnapBtn) {
      takeSnapBtn.disabled = isLoading || !!hasError || state.undoBusy || state.snapBusy;
    }
    if (renameSnapBtn) {
      renameSnapBtn.disabled = isLoading || !!hasError || state.undoBusy || !selectedIsSnapshot;
    }
    listEl.innerHTML = '';
    if (isLoading) {
      const d = document.createElement('div');
      d.className = 'undo-empty';
      d.textContent = 'Loading...';
      listEl.appendChild(d);
      return;
    }
    if (hasError) {
      const d = document.createElement('div');
      d.className = 'undo-empty';
      d.textContent = hasError;
      listEl.appendChild(d);
      return;
    }
    if (!items.length) {
      const d = document.createElement('div');
      d.className = 'undo-empty';
      d.textContent = 'No undo history found.';
      listEl.appendChild(d);
      return;
    }
    items.forEach((item, idx) => {
      const key = String((item && item.undoKey) || '').trim();
      if (!key) return;
      const kind = String((item && item.kind) || '').trim().toLowerCase();
      const isSnapshot = (kind === 'snapshot');
      const row = document.createElement('div');
      const isNamedSnapshot = isSnapshot && !!(item && item.snapshotNamed);
      row.className = 'undo-item' +
        (isSnapshot ? ' snapshot' : '') +
        (isNamedSnapshot ? ' named' : '') +
        (state.undoSelectedKey === key ? ' active' : '');
      const count = Math.max(1, Math.round(Number(item.count || 1)));
      const cardCount = Math.max(0, Math.round(Number(item.targetIdsCount || 0)));
      const actionSummary = String(item.actionSummary || 'update');
      const when = formatUndoTs_(item.ts);
      const targetSheet = String(item.targetSheet || '');
      const targetIds = Array.isArray(item.targetIds) ? item.targetIds.slice(0, 4) : [];
      const idsText = targetIds.length ? targetIds.join(', ') : '-';
      if (isSnapshot) {
        const snapName = String(item.snapshotName || '').trim();
        const title = snapName ? (`SNAP "${snapName}"`) : 'SNAP (unnamed)';
        const retentionTag = snapName ? 'retained' : 'rolling(5)';
        row.innerHTML = '' +
          `<div class="undo-main">${idx + 1}. ${escapeHtml_(title)}</div>` +
          `<div class="undo-meta">${escapeHtml_(when)} | sheet:${escapeHtml_(targetSheet || '-')} | cards:${cardCount}</div>` +
          `<div class="undo-meta">type: snapshot | ${escapeHtml_(retentionTag)}</div>`;
      } else {
        // Scheduler undo menu is snapshot-only; non-snapshot rows are shown for safety/debug.
        row.innerHTML = '' +
          `<div class="undo-main">${idx + 1}. ${escapeHtml_(actionSummary)}</div>` +
          `<div class="undo-meta">${escapeHtml_(when)} | sheet:${escapeHtml_(targetSheet || '-')}</div>` +
          `<div class="undo-meta">type: non-snapshot (not restorable from this menu)</div>`;
      }
      row.addEventListener('click', () => {
        state.undoSelectedKey = key;
        renderUndoModalList_();
      });
      listEl.appendChild(row);
    });
  };
  const closeToolbarMenus_ = () => {
    if (els.viewMenuPopup) els.viewMenuPopup.classList.remove('open');
    if (els.laneMenuPopup) els.laneMenuPopup.classList.remove('open');
  };
  const getToolbarMenu_ = (menuKey) => {
    if (menuKey === 'view') return els.viewMenuPopup;
    if (menuKey === 'lane') return els.laneMenuPopup;
    return null;
  };
  const toggleToolbarMenu_ = (menuKey) => {
    if (!menuKey) return;
    const target = getToolbarMenu_(menuKey);
    if (!target) return;
    const willOpen = !target.classList.contains('open');
    closeToolbarMenus_();
    if (willOpen) target.classList.add('open');
  };
  const clearInspectorTimers_ = () => {
    const edit = state.inspEdit;
    if (!edit || !edit.timers) return;
    try {
      Object.keys(edit.timers).forEach((k) => {
        const t = edit.timers[k];
        if (t) clearTimeout(t);
      });
    } catch (_) {}
    edit.timers = {};
  };
  const queueAssetInspectorRefresh_ = () => {
    if (!(state.assetCellSelection && isFinite(Number(state.assetCellSelection.rawStart)))) return;
    if (state.assetInspectorRefreshQueued) return;
    state.assetInspectorRefreshQueued = true;
    requestAnimationFrame(() => {
      state.assetInspectorRefreshQueued = false;
      if (!(state.assetCellSelection && isFinite(Number(state.assetCellSelection.rawStart)))) return;
      var selStart = Math.max(1, Math.round(Number(state.assetCellSelection.rawStart) || 1));
      var selEnd = Math.max(selStart, Math.round(Number(state.assetCellSelection.rawEnd) || selStart));
      refreshAssetUsageState_();
      state.assetCellSelection.rawStart = selStart;
      state.assetCellSelection.rawEnd = selEnd;
      state.assetCellSelection.rows = summarizeAssetsForRawRange_(
        selStart,
        selEnd
      );
      ui.renderInspector();
    });
  };
  const initInspectorResizer_ = () => {
    const resizer = document.getElementById('inspector-resizer');
    const insp = document.getElementById('inspector');
    if (!resizer || !insp) return;
    resizer.addEventListener('mousedown', (e) => {
      if (insp.classList.contains('closed')) return;
      e.preventDefault();
      const startX = e.clientX;
      const startW = insp.getBoundingClientRect().width;
      const onMove = (ev) => {
        const dx = ev.clientX - startX;
        const newW = startW - dx;
        setInspectorWidth_(newW);
      };
      const onUp = () => {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
        const finalW = insp.getBoundingClientRect().width;
        try { localStorage.setItem(INSPECTOR_WIDTH_KEY, String(Math.round(finalW))); } catch (_) {}
      };
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
  };
  try {
    const savedW = Number(localStorage.getItem(INSPECTOR_WIDTH_KEY) || '');
    if (isFinite(savedW) && savedW > 0) setInspectorWidth_(savedW);
  } catch (_) {}

  if (els.gridScroll) {
    els.gridScroll.addEventListener('scroll', () => {
      if (els.headerScroll) els.headerScroll.scrollLeft = els.gridScroll.scrollLeft;
      const pxPerDay = getPxPerDay_();
      const dayIdx = Math.floor(els.gridScroll.scrollTop / pxPerDay);
      if (state.workDayMap[dayIdx] && els.yearCorner) {
        els.yearCorner.textContent = state.workDayMap[dayIdx].getFullYear();
      }
    });
  }

  const utils = {
    dateToSlot: (d, kind) => {
      if (!d || isNaN(d)) return 1;
      const dateStr = formatYmd_(d);
      const mins = (d.getHours() * 60 + d.getMinutes());
      const rel = Math.round(mins / config.slotMin);
      return utils.dateValToSlot(dateStr, rel + 1, kind || 'start');
    },
    slotToDate: (s) => {
      const anchor = config.originAnchor || config.originDate;
      if (!anchor) return new Date();
      const slot = Math.max(1, Math.round(Number(s) || 1));
      return new Date(anchor.getTime() + ((slot - 1) * config.slotMin * 60000));
    },
    getSnapProps: (pxPer30) => {
      let desired = 1440;
      if (pxPer30 >= 24) desired = 30;
      else if (pxPer30 >= 12) desired = 60;
      else if (pxPer30 >= 6) desired = 120;
      else if (pxPer30 >= 3) desired = 240;
      const min = Math.max(desired, config.slotMin);
      let label = `${min}m`;
      if (min >= 1440) label = '1d';
      else if (min === 240) label = '4h';
      else if (min === 120) label = '2h';
      else if (min === 60) label = '1h';
      else if (min === 30) label = '30m';
      return { min, label };
    },
    fmtDate: (d) => `${d.getMonth()+1}/${d.getDate()}`,
    fmtDateAxis: (d) => {
      const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
      return {
        main: `${d.getMonth()+1}/${d.getDate()}`,
        sub: `(${days[d.getDay()]})`
      };
    },
    fmtYmdInput: (d) => {
      if (!d || isNaN(d)) return '';
      return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    },
    fmtYmdText: (d) => {
      if (!d || isNaN(d)) return '';
      return `${d.getFullYear()}/${String(d.getMonth()+1).padStart(2,'0')}/${String(d.getDate()).padStart(2,'0')}`;
    },
    parseDateTextStrict: (v) => {
      if (!v) return null;
      const s = String(v).trim();
      if (!s) return null;
      let y = null; let mo = null; let d = null;
      const m = s.match(/^(\d{4})[-/](\d{1,2})[-/](\d{1,2})$/);
      if (m) {
        y = Number(m[1]); mo = Number(m[2]); d = Number(m[3]);
      } else {
        const m8 = s.match(/^(\d{4})(\d{2})(\d{2})$/);
        if (m8) {
          y = Number(m8[1]); mo = Number(m8[2]); d = Number(m8[3]);
        } else {
          return null;
        }
      }
      if (!isFinite(y) || !isFinite(mo) || !isFinite(d)) return null;
      if (mo < 1 || mo > 12 || d < 1 || d > 31) return null;
      const dt = new Date(y, mo - 1, d);
      if (dt.getFullYear() !== y || (dt.getMonth() + 1) !== mo || dt.getDate() !== d) return null;
      dt.setHours(12,0,0,0);
      return dt;
    },
    fmtSlotDisplay: (slot, kind) => {
      if (slot === null || slot === undefined) return 'Slot -';
      const n = utils.normalizeSlot(slot, kind || 'neutral');
      if (!n || !n.dateVal) return `Slot ${slot}`;
      const disp = n.slotVal;
      return `${n.dateVal.replace(/-/g, '/')} Slot ${disp}`;
    },
    shiftWorkdays: (base, dayIdx) => {
      const d = new Date(base.getFullYear(), base.getMonth(), base.getDate());
      if (!dayIdx) return d;
      const step = dayIdx > 0 ? 1 : -1;
      let remain = Math.abs(dayIdx);
      while (remain > 0) {
        d.setDate(d.getDate() + step);
        const dow = d.getDay();
        if (dow !== 0 && dow !== 6) remain -= 1;
      }
      return d;
    },
    adjustWeekend: (d, kind) => {
      const out = new Date(d.getFullYear(), d.getMonth(), d.getDate());
      const step = (kind === 'end') ? -1 : 1;
      while (out.getDay() === 0 || out.getDay() === 6) {
        out.setDate(out.getDate() + step);
      }
      return out;
    },
    workdayDiff: (fromDate, toDate) => {
      const from = new Date(fromDate.getFullYear(), fromDate.getMonth(), fromDate.getDate());
      const to = new Date(toDate.getFullYear(), toDate.getMonth(), toDate.getDate());
      if (from.getTime() === to.getTime()) return 0;
      let sign = 1;
      let start = from;
      let end = to;
      if (from.getTime() > to.getTime()) {
        sign = -1;
        start = to;
        end = from;
      }
      const msPerDay = 86400000;
      const days = Math.floor((end.getTime() - start.getTime()) / msPerDay);
      const fullWeeks = Math.floor(days / 7);
      let business = fullWeeks * 5;
      const remaining = days % 7;
      const startDay = start.getDay();
      for (let i = 1; i <= remaining; i++) {
        const dow = (startDay + i) % 7;
        if (dow !== 0 && dow !== 6) business += 1;
      }
      return business * sign;
    },
    normalizeSlot: (slot, kind) => {
      const slotsPerDay = Math.max(1, Math.round((config.workHours * 60) / config.slotMin));
      let raw = Number(slot);
      if (!isFinite(raw)) raw = 1;
      raw = Math.max(1, Math.round(raw));
      const dayIdx = Math.floor((raw - 1) / slotsPerDay);
      const rel = ((raw - 1) % slotsPerDay) + 1;
      const origin = config.originDate || config.originAnchor || new Date();
      const base = new Date(origin.getFullYear(), origin.getMonth(), origin.getDate());
      let date = utils.shiftWorkdays(base, dayIdx);
      date = utils.adjustWeekend(date, kind || 'neutral');
      const dateVal = formatYmd_(date);
      return { date, dateVal, slotVal: rel, slotsPerDay, rawSlot: raw, dayIdx };
    },
    slotToDateVal: (slot, kind) => {
      const n = utils.normalizeSlot(slot, kind || 'neutral');
      if (!n || !n.date) {
        const fallback = new Date();
        fallback.setHours(12,0,0,0);
        const fbSlot = 1;
        return { date: fallback, slot: fbSlot, absStart: 1, dateVal: formatYmd_(fallback) };
      }
      return { date: n.date, slot: n.slotVal, absStart: (n.dayIdx * n.slotsPerDay) + 1, dateVal: n.dateVal, slotsPerDay: n.slotsPerDay };
    },
    dateValToSlot: (dateStr, relSlot, kind) => {
      const anchor = config.originAnchor || config.originDate;
      if (!dateStr || !anchor) return 1;
      const d0 = utils.parseDateTime(dateStr);
      if (!d0 || isNaN(d0)) return 1;
      d0.setHours(0,0,0,0);
      const adj = utils.adjustWeekend(d0, kind || 'neutral');
      const anchorDay = new Date(anchor.getFullYear(), anchor.getMonth(), anchor.getDate());
      const dayIdx = utils.workdayDiff(anchorDay, adj);
      const slotsPerDay = Math.max(1, Math.round((config.workHours * 60) / config.slotMin));
      const rawRel = Number(relSlot);
      const slotInDay = (isFinite(rawRel) && rawRel > 0) ? Math.round(rawRel) : 1;
      const rel = Math.max(1, Math.min(slotInDay, slotsPerDay));
      return Math.max(1, (dayIdx * slotsPerDay) + rel);
    },
    parseCardTitle: (title) => {
      if (!title) return { main: 'Card', sub: '' };
      const s = String(title);
      if (s.includes('_')) {
        const parts = s.split('_');
        return { main: parts[0], sub: parts.slice(1).join('_') };
      }
      return { main: s, sub: '' };
    },
    getDisplayId: (id) => {
      const raw = String(id || '');
      const suffix = raw.includes('_') ? raw.split('_').pop() : raw;
      if (/^\d+$/.test(suffix)) return suffix.padStart(3, '0');
      return suffix || raw;
    },
    parseDateTime: (v) => {
      if (!v) return null;
      if (v instanceof Date) {
        const d = new Date(v.getTime());
        d.setHours(12,0,0,0);
        return d;
      }
      if (typeof v === 'number') {
        const dNum = new Date(v);
        if (isNaN(dNum)) return null;
        dNum.setHours(12,0,0,0);
        return dNum;
      }
      const s = String(v).trim();
      if (!s) return null;
      const mDash = s.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
      if (mDash) {
        const dLocal = new Date(Number(mDash[1]), Number(mDash[2]) - 1, Number(mDash[3]));
        if (!isNaN(dLocal)) {
          dLocal.setHours(12,0,0,0);
          return dLocal;
        }
      }
      const mSlash = s.match(/^(\d{4})\/(\d{1,2})\/(\d{1,2})$/);
      if (mSlash) {
        const dLocal = new Date(Number(mSlash[1]), Number(mSlash[2]) - 1, Number(mSlash[3]));
        if (!isNaN(dLocal)) {
          dLocal.setHours(12,0,0,0);
          return dLocal;
        }
      }
      const strictDate = utils.parseDateTextStrict(s);
      if (strictDate) return strictDate;
      if (/[Tt].*(Z|[+-]\d{2}:?\d{2})/.test(s)) {
        const dIso = new Date(s);
        if (!isNaN(dIso)) {
          dIso.setHours(12,0,0,0);
          return dIso;
        }
      }
      if (/^\d{10,}$/.test(s)) {
        const n = Number(s);
        if (isFinite(n)) {
          const dNum = new Date(n);
          if (!isNaN(dNum)) {
            dNum.setHours(12,0,0,0);
            return dNum;
          }
        }
      }
      return null;
    },
    saveStatus: (st, msg) => {
      const el = document.getElementById('saveStatus');
      if (!el) return;
      el.className = st; el.textContent = msg;
      if (st === 'saved') setTimeout(() => { el.className=''; }, 2000);
    },
    calcSlotPx: (val) => {
      const n = Number(val);
      return Math.max(1, Math.min(100, n));
    },
    setCacheStatus: () => {}
  };

  function _sch_normKey_(k){ return String(k || '').trim().toLowerCase(); }

  function _sch_inferIdKey_(o, idPrefixRe){
    if (!o || typeof o !== 'object') return null;
    if ('id' in o) return 'id';
    var keys = Object.keys(o);
    var best = null;
    for (var i=0;i<keys.length;i++){
      var k = keys[i];
      var v = o[k];
      if (typeof v === 'string' && idPrefixRe && idPrefixRe.test(v.trim())) return k;
    }
    for (var j=0;j<keys.length;j++){
      var kk = keys[j];
      if (/\bid\b|_id$| id$/i.test(_sch_normKey_(kk))) { best = kk; break; }
    }
    return best;
  }

  function _sch_inferNameKey_(o){
    if (!o || typeof o !== 'object') return null;
    if ('name' in o) return 'name';
    var keys = Object.keys(o);
    for (var i=0;i<keys.length;i++){
      var k = keys[i];
      var nk = _sch_normKey_(k);
      if (/\bname\b|_name$|\btitle\b|_title$/i.test(nk)) return k;
    }
    for (var j=0;j<keys.length;j++){
      var kk = keys[j];
      var nk2 = _sch_normKey_(kk);
      if (/\bid\b|_id$| id$/i.test(nk2)) continue;
      var v = o[kk];
      if (typeof v === 'string' && v.trim()) return kk;
    }
    return null;
  }

  function _sch_inferKeyByParts_(o, parts){
    if (!o || typeof o !== 'object' || !parts || !parts.length) return null;
    var keys = Object.keys(o);
    for (var i=0;i<keys.length;i++){
      var k = keys[i];
      var nk = _sch_normKey_(k);
      var ok = true;
      for (var p=0;p<parts.length;p++){
        if (nk.indexOf(parts[p]) === -1) { ok = false; break; }
      }
      if (ok) return k;
    }
    return null;
  }

  function getSlotsPerDay_() {
    return Math.round((config.workHours * 60) / config.slotMin);
  }

  function getLaneWidth_() {
    try {
      var raw = getComputedStyle(document.documentElement).getPropertyValue('--lane-w');
      var n = Math.round(parseFloat(String(raw || '').replace('px', '')));
      if (isFinite(n) && n > 0) return n;
    } catch (_) {}
    return (isFinite(Number(state.laneWidth)) && Number(state.laneWidth) > 0) ? Number(state.laneWidth) : 65;
  }

  function getVisibleLanes_() {
    return state.lanes.filter(function(l) { return !!l.visible; });
  }

  function canvasPointToSlot_(yInCanvas) {
    const pxPerDay = getPxPerDay_();
    const dayIdx = Math.floor(yInCanvas / pxPerDay);
    if (!isFinite(dayIdx) || dayIdx < 0 || dayIdx >= state.workDayMap.length) return null;
    const yInDay = yInCanvas - (dayIdx * pxPerDay);
    const spd = Math.max(1, getSlotsPerDay_());
    const ratio = Math.max(0, Math.min(0.999999, yInDay / pxPerDay));
    const slotInDay = Math.max(1, Math.min(spd, Math.floor(ratio * spd) + 1));
    const dateVal = formatYmd_(state.workDayMap[dayIdx]);
    const rawSlot = utils.dateValToSlot(dateVal, slotInDay, 'start');
    return {
      dayIdx: dayIdx,
      dateVal: dateVal,
      slotInDay: slotInDay,
      rawSlot: rawSlot
    };
  }

  function resolveAssetCellFromCanvasPoint_(xInCanvas, yInCanvas) {
    if (!state.assetColumnVisible) return null;
    const lanes = getVisibleLanes_();
    if (!lanes.length) return null;
    const laneAreaW = lanes.length * getLaneWidth_();
    const assetsColW = getAssetsColWidth_();
    if (!isFinite(xInCanvas) || xInCanvas < laneAreaW || xInCanvas >= (laneAreaW + assetsColW)) return null;
    const slotHit = canvasPointToSlot_(yInCanvas);
    if (!slotHit) return null;

    const snap = getSnapState_();
    const dayMinutes = Math.max(config.slotMin, config.workHours * 60);
    let snapMin = Math.max(config.slotMin, Number(snap && snap.min) || config.slotMin);
    if (snapMin > dayMinutes) snapMin = dayMinutes;
    const pxPerDay = getPxPerDay_();
    const yInDay = yInCanvas - (slotHit.dayIdx * pxPerDay);
    const minuteInDay = Math.max(0, Math.min(dayMinutes - 0.000001, (yInDay / Math.max(1, pxPerDay)) * dayMinutes));
    let startMin = 0;
    for (let m = 0; m < dayMinutes; m += snapMin) {
      const cellMinutes = Math.min(snapMin, dayMinutes - m);
      if (minuteInDay >= m && minuteInDay < (m + cellMinutes)) {
        startMin = m;
        break;
      }
    }
    const slotInDayStart = Math.floor(startMin / config.slotMin) + 1;
    const spanSlots = Math.max(1, Math.round(snapMin / config.slotMin));
    const slotsPerDay = Math.max(1, getSlotsPerDay_());
    const rawStart = utils.dateValToSlot(slotHit.dateVal, slotInDayStart, 'start');
    const rawEnd = Math.min(rawStart + spanSlots - 1, utils.dateValToSlot(slotHit.dateVal, slotsPerDay, 'end'));
    const rows = summarizeAssetsForRawRange_(rawStart, rawEnd);
    return {
      dateVal: slotHit.dateVal,
      rawStart: rawStart,
      rawEnd: rawEnd,
      resolutionLabel: snap && snap.label ? String(snap.label) : '',
      rows: rows
    };
  }

  function selectionFromAssetCellElement_(el) {
    if (!el || !el.dataset) return null;
    var rawStart = Math.round(Number(el.dataset.rawStart));
    var rawEnd = Math.round(Number(el.dataset.rawEnd));
    var dateVal = String(el.dataset.dateVal || '').trim();
    if (!isFinite(rawStart) || rawStart < 1) return null;
    if (!isFinite(rawEnd) || rawEnd < rawStart) rawEnd = rawStart;
    if (!dateVal) return null;
    return {
      dateVal: dateVal,
      rawStart: rawStart,
      rawEnd: rawEnd,
      resolutionLabel: String(el.dataset.resolutionLabel || ''),
      rows: summarizeAssetsForRawRange_(rawStart, rawEnd)
    };
  }

  function findGapAtSlot_(laneId, rawSlot) {
    const laneCards = Object.values(state.cards || {})
      .filter(function(c) {
        return String(c && c.laneId || '') === String(laneId || '') &&
          isFinite(Number(c && c.start)) && isFinite(Number(c && c.end));
      })
      .sort(function(a, b) { return Number(a.start) - Number(b.start); });
    if (laneCards.length < 2) return null;
    const s = Math.round(Number(rawSlot));
    if (!isFinite(s) || s < 1) return null;
    for (let i = 0; i < laneCards.length - 1; i++) {
      const a = laneCards[i];
      const b = laneCards[i + 1];
      const from = Math.round(Number(a.end)) + 1;
      const to = Math.round(Number(b.start)) - 1;
      if (from <= to && s >= from && s <= to) {
        return {
          laneId: String(laneId || ''),
          fromSlot: from,
          toSlot: to,
          sizeSlots: (to - from + 1),
          prevCardId: String(a.id || ''),
          nextCardId: String(b.id || '')
        };
      }
    }
    return null;
  }

  function slotRectForRawRange_(fromRaw, toRaw, pxPerDay) {
    var s = utils.normalizeSlot(fromRaw, 'start');
    var e = utils.normalizeSlot(toRaw, 'end');
    if (!s || !e) return null;
    var sDayIdx = state.workDayMap.findIndex(function(wd) { return formatYmd_(wd) === s.dateVal; });
    var eDayIdx = state.workDayMap.findIndex(function(wd) { return formatYmd_(wd) === e.dateVal; });
    if (sDayIdx < 0 || eDayIdx < 0 || eDayIdx < sDayIdx) return null;
    var sSpd = Math.max(1, Number(s.slotsPerDay) || getSlotsPerDay_());
    var eSpd = Math.max(1, Number(e.slotsPerDay) || getSlotsPerDay_());
    var top = (sDayIdx * pxPerDay) + (((Math.max(1, Number(s.slotVal) || 1) - 1) / sSpd) * pxPerDay);
    var bottom = (eDayIdx * pxPerDay) + ((Math.max(1, Number(e.slotVal) || 1) / eSpd) * pxPerDay);
    if (!isFinite(top) || !isFinite(bottom) || bottom <= top) return null;
    return {
      top: top,
      height: Math.max(6, bottom - top)
    };
  }

  function normalizeCardIds_(ids) {
    var out = [];
    var seen = {};
    (Array.isArray(ids) ? ids : []).forEach(function (id) {
      var key = String(id || '').trim();
      if (!key || seen[key] || !state.cards[key]) return;
      seen[key] = true;
      out.push(key);
    });
    return out;
  }

  function keepOnlyLaneSelection_(ids, laneId) {
    var targetLane = String(laneId || '');
    if (!targetLane) return normalizeCardIds_(ids);
    return normalizeCardIds_(ids).filter(function (id) {
      var c = state.cards[String(id || '')];
      return !!c && String(c.laneId || '') === targetLane;
    });
  }

  function isCardInMultiSelection_(cardId) {
    var key = String(cardId || '');
    if (!key) return false;
    return (state.multiSelection || []).indexOf(key) >= 0;
  }

  function toggleMultiSelection_(cardId) {
    var key = String(cardId || '').trim();
    if (!key || !state.cards[key]) return;
    var next = normalizeCardIds_(state.multiSelection || []);
    var idx = next.indexOf(key);
    if (idx >= 0) next.splice(idx, 1);
    else next.push(key);
    state.multiSelection = next;
  }

  function getLaneSortedCardIds_(laneId) {
    var key = String(laneId || '');
    if (!key) return [];
    return Object.values(state.cards || {})
      .filter(function (c) {
        return !!c &&
          String(c.laneId || '') === key &&
          isFinite(Number(c.start)) &&
          isFinite(Number(c.end));
      })
      .sort(function (a, b) {
        if (Number(a.start) !== Number(b.start)) return Number(a.start) - Number(b.start);
        return String(a.id || '').localeCompare(String(b.id || ''));
      })
      .map(function (c) { return String(c.id || ''); })
      .filter(Boolean);
  }

  function buildLaneRangeSelection_(anchorId, targetId) {
    var aId = String(anchorId || '').trim();
    var tId = String(targetId || '').trim();
    if (!aId || !tId || !state.cards[aId] || !state.cards[tId]) return [];
    var aLane = String(state.cards[aId].laneId || '');
    var tLane = String(state.cards[tId].laneId || '');
    if (!aLane || aLane === 'unassigned' || aLane !== tLane) return [];
    var ordered = getLaneSortedCardIds_(aLane);
    if (!ordered.length) return [];
    var ai = ordered.indexOf(aId);
    var ti = ordered.indexOf(tId);
    if (ai < 0 || ti < 0) return [];
    var lo = Math.min(ai, ti);
    var hi = Math.max(ai, ti);
    return ordered.slice(lo, hi + 1);
  }

  function getCardLengthSlots_(card) {
    if (!card) return 1;
    var s = Math.round(Number(card.start));
    var e = Math.round(Number(card.end));
    if (!isFinite(s) || !isFinite(e) || e < s) return 1;
    return Math.max(1, e - s + 1);
  }

  function buildDragBlockForCard_(cardId) {
    var key = String(cardId || '').trim();
    if (!key || !state.cards[key]) return null;
    var seed = isCardInMultiSelection_(key) ? normalizeCardIds_(state.multiSelection || []) : [key];
    if (seed.length <= 1) return null;
    var laneId = String(state.cards[key].laneId || '');
    if (!laneId || laneId === 'unassigned') return null;
    var cards = seed
      .map(function (id) { return state.cards[id]; })
      .filter(function (c) {
        return !!c &&
          String(c.laneId || '') === laneId &&
          isFinite(Number(c.start)) &&
          isFinite(Number(c.end));
      })
      .sort(function (a, b) {
        if (Number(a.start) !== Number(b.start)) return Number(a.start) - Number(b.start);
        return String(a.id || '').localeCompare(String(b.id || ''));
      });
    if (cards.length <= 1) return null;
    var baseStart = Math.round(Number(cards[0].start) || 1);
    if (!isFinite(baseStart) || baseStart < 1) baseStart = 1;
    var entries = cards.map(function (c) {
      var len = getCardLengthSlots_(c);
      var rel = Math.max(0, Math.round(Number(c.start) || baseStart) - baseStart);
      return {
        id: String(c.id || ''),
        relStart: rel,
        len: len
      };
    });
    var anchorRel = 0;
    entries.forEach(function (ent) {
      if (String(ent.id || '') === key) anchorRel = ent.relStart;
    });
    var spanSlots = 1;
    entries.forEach(function (ent) {
      spanSlots = Math.max(spanSlots, ent.relStart + ent.len);
    });
    return {
      laneId: laneId,
      ids: entries.map(function (ent) { return ent.id; }),
      entries: entries,
      baseStart: baseStart,
      anchorRelStart: anchorRel,
      spanSlots: spanSlots
    };
  }

  function resolveInsertStartByEarlyCards_(laneId, desiredStart, excludeIds) {
    var laneKey = String(laneId || '');
    var start = Math.max(1, Math.round(Number(desiredStart) || 1));
    if (!laneKey) return start;
    var exclude = {};
    normalizeCardIds_(excludeIds || []).forEach(function (id) { exclude[id] = true; });
    var maxEarlyEnd = null;
    Object.values(state.cards || {}).forEach(function (c) {
      if (!c) return;
      var id = String(c.id || '');
      if (exclude[id]) return;
      if (String(c.laneId || '') !== laneKey) return;
      var cStart = Math.round(Number(c.start));
      var cEnd = Math.round(Number(c.end));
      if (!isFinite(cStart) || !isFinite(cEnd)) return;
      if (cEnd < cStart) return;
      if (cStart >= start) return;
      if (maxEarlyEnd === null || cEnd > maxEarlyEnd) maxEarlyEnd = cEnd;
    });
    if (maxEarlyEnd !== null && maxEarlyEnd >= start) return maxEarlyEnd + 1;
    return start;
  }

  function pushDownLaneSuffixPreserveGaps_(laneId, insertStart, insertEnd, excludeIds) {
    var laneKey = String(laneId || '');
    if (!laneKey || !isFinite(Number(insertStart)) || !isFinite(Number(insertEnd))) return [];
    var start = Math.max(1, Math.round(Number(insertStart)));
    var end = Math.max(start, Math.round(Number(insertEnd)));
    var exclude = {};
    if (excludeIds && typeof excludeIds.forEach === 'function') {
      excludeIds.forEach(function (id) { exclude[String(id || '')] = true; });
    } else {
      normalizeCardIds_(excludeIds || []).forEach(function (id) { exclude[id] = true; });
    }
    var laneCards = Object.values(state.cards || {})
      .filter(function (c) {
        return !!c &&
          String(c.laneId || '') === laneKey &&
          !exclude[String(c.id || '')] &&
          isFinite(Number(c.start)) &&
          isFinite(Number(c.end));
      })
      .sort(function (a, b) {
        if (Number(a.start) !== Number(b.start)) return Number(a.start) - Number(b.start);
        return String(a.id || '').localeCompare(String(b.id || ''));
      });
    if (!laneCards.length) return [];
    var firstIdx = -1;
    for (var i = 0; i < laneCards.length; i++) {
      var c = laneCards[i];
      var cEnd = Math.round(Number(c.end) || 0);
      if (cEnd >= start) {
        firstIdx = i;
        break;
      }
    }
    if (firstIdx < 0) return [];
    var firstStart = Math.round(Number(laneCards[firstIdx].start) || start);
    var delta = (end - firstStart + 1);
    if (!isFinite(delta) || delta <= 0) return [];
    var shifted = [];
    for (var j = firstIdx; j < laneCards.length; j++) {
      var card = laneCards[j];
      card.start = Math.max(1, Math.round(Number(card.start) || 1) + delta);
      card.end = Math.max(card.start, Math.round(Number(card.end) || card.start) + delta);
      shifted.push(card);
    }
    return shifted;
  }

  function snapshotLaneLengths_(laneId) {
    var key = String(laneId || '');
    var map = {};
    Object.values(state.cards || {}).forEach(function(card) {
      if (!card) return;
      if (String(card.laneId || '') !== key) return;
      var s = Math.round(Number(card.start));
      var e = Math.round(Number(card.end));
      if (!isFinite(s) || !isFinite(e)) return;
      if (e < s) return;
      map[String(card.id || '')] = Math.max(1, e - s + 1);
    });
    return map;
  }

  function enforceLaneLengthInvariant_(laneId, expectedById, reason) {
    var key = String(laneId || '');
    var fixes = [];
    var expected = expectedById || {};
    Object.keys(expected).forEach(function(cardId) {
      var c = state.cards && state.cards[cardId];
      if (!c) return;
      if (String(c.laneId || '') !== key) return;
      var s = Math.round(Number(c.start));
      var e = Math.round(Number(c.end));
      var exp = Math.max(1, Math.round(Number(expected[cardId]) || 1));
      if (!isFinite(s) || !isFinite(e)) return;
      var cur = Math.max(1, e - s + 1);
      if (cur === exp) return;
      c.end = s + exp - 1;
      fixes.push({ id: cardId, from: cur, to: exp });
    });
    if (fixes.length) {
      console.warn('[MOTK][Scheduler][LEN_GUARD] corrected', {
        laneId: key,
        reason: String(reason || ''),
        fixes: fixes
      });
    }
    return fixes;
  }

  function focusSelectedGapHitbox_() {
    if (!els.canvas || !state.gapSelection) return;
    var g = state.gapSelection;
    var laneId = String(g.laneId || '');
    var from = String(Math.round(Number(g.fromSlot) || 0));
    var to = String(Math.round(Number(g.toSlot) || 0));
    var nodes = els.canvas.querySelectorAll('.gap-hitbox');
    for (var i = 0; i < nodes.length; i++) {
      var n = nodes[i];
      if (!n || !n.dataset) continue;
      if (String(n.dataset.gapLaneId || '') !== laneId) continue;
      if (String(n.dataset.gapFrom || '') !== from) continue;
      if (String(n.dataset.gapTo || '') !== to) continue;
      try { n.focus({ preventScroll: true }); } catch (_) { try { n.focus(); } catch (_) {} }
      return;
    }
  }

  function getPxPerDay_() {
    return state.slotPx * getSlotsPerDay_();
  }

  function getSnapState_() {
    const pxPer30 = state.slotPx * (30 / config.slotMin);
    let snap = utils.getSnapProps(pxPer30);
    const dayMinutes = config.workHours * 60;
    if (snap.label === '1d' || snap.min >= 1440) {
      snap = { min: Math.max(dayMinutes, config.slotMin), label: '1d' };
    }
    return snap;
  }

  function snapMinutes_(yInDay, pxPerDay) {
    const snap = getSnapState_();
    const dayMinutes = config.workHours * 60;
    if (snap.label === '1d' || snap.min >= dayMinutes) {
      return { minutes: 0, snap: { min: dayMinutes, label: '1d' } };
    }
    const mins = Math.max(0, Math.min(dayMinutes, (yInDay / pxPerDay) * dayMinutes));
    let snapped = Math.round(mins / snap.min) * snap.min;
    snapped = Math.max(0, Math.min(dayMinutes, snapped));
    return { minutes: snapped, snap: snap };
  }

  function setDragPreview_(preview) {
    if (!preview || !preview.laneId || !isFinite(Number(preview.start)) || !isFinite(Number(preview.end))) {
      state.dragPreview = null;
      return;
    }
    var start = Math.max(1, Math.round(Number(preview.start)));
    var end = Math.max(start, Math.round(Number(preview.end)));
    state.dragPreview = {
      laneId: String(preview.laneId || ''),
      start: start,
      end: end,
      mode: String(preview.mode || 'move')
    };
  }

  function formatYmd_(d) {
    if (!d || isNaN(d)) return '----';
    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
  }

  function normalizeOriginDisplayText_(raw) {
    if (raw === undefined || raw === null) return '';
    if (raw instanceof Date && !isNaN(raw)) return formatYmd_(raw).replace(/-/g, '/');
    if (typeof raw === 'number') {
      const d = new Date(raw);
      return isNaN(d) ? '' : formatYmd_(d).replace(/-/g, '/');
    }
    const s = String(raw).trim();
    if (!s) return '';
    // Prioritize robust datetime parsing to avoid YYYY-MM-DD extraction
    // from UTC ISO strings that would show one-day shift in local view.
    const parsed = utils.parseDateTime(s);
    if (parsed && !isNaN(parsed)) {
      return formatYmd_(parsed).replace(/-/g, '/');
    }
    const m = s.match(/^(\d{4})[-/](\d{1,2})[-/](\d{1,2})/);
    if (m) {
      return `${m[1]}/${String(m[2]).padStart(2, '0')}/${String(m[3]).padStart(2, '0')}`;
    }
    const m8 = s.match(/^(\d{4})(\d{2})(\d{2})$/);
    if (m8) {
      return `${m8[1]}/${m8[2]}/${m8[3]}`;
    }
    return s.replace(/-/g, '/');
  }

  var CARD_DISPLAY_BASE_OPTIONS = [
    { value: 'shot_code', label: 'Shot Code' },
    { value: 'shot_id', label: 'Shot ID' },
    { value: 'task_name', label: 'Task Name' },
    { value: 'task_status', label: 'Task Status' },
    { value: 'task_assignee', label: 'Task Assignee' },
    { value: 'task_est_length', label: 'Est length (mins)' },
    { value: 'task_id', label: 'Task ID' },
    { value: 'card_id', label: 'Card ID' },
    { value: 'card_memo', label: 'Card Memo' },
    { value: 'card_lane', label: 'Card Lane' },
    { value: 'card_start_slot', label: 'Card Start Slot' },
    { value: 'card_end_slot', label: 'Card End Slot' },
    { value: 'card_length', label: 'Card Length' }
  ];
  var CARD_DISPLAY_BASE_FIELDS = CARD_DISPLAY_BASE_OPTIONS.map(function (o) { return o.value; });

  function normalizeCardDisplayField_(value, fallback) {
    var raw = String(value || '').trim();
    var v = raw.toLowerCase();
    if (CARD_DISPLAY_BASE_FIELDS.indexOf(v) >= 0) return v;
    if (/^task:/i.test(raw)) return 'task:' + raw.replace(/^task:/i, '');
    if (/^card:/i.test(raw)) return 'card:' + raw.replace(/^card:/i, '');
    return fallback || 'task_name';
  }

  function normalizePresetKey_(value) {
    var key = String(value || '').trim().toLowerCase().replace(/\s+/g, '_');
    if (key === 'monday') key = 'this_monday';
    if (key === 'thismonday') key = 'this_monday';
    if (key === 'nextmonday') key = 'next_monday';
    if (key === 'today' || key === 'yesterday' || key === 'tomorrow' || key === 'this_monday' || key === 'next_monday' || key === 'custom') return key;
    return 'custom';
  }

  function resolveDatePreset_(presetKey) {
    var key = normalizePresetKey_(presetKey);
    const base = new Date();
    base.setHours(0,0,0,0);
    if (key === 'today') return base;
    if (key === 'yesterday') {
      const d = new Date(base.getTime());
      d.setDate(d.getDate() - 1);
      return d;
    }
    if (key === 'tomorrow') {
      const d = new Date(base.getTime());
      d.setDate(d.getDate() + 1);
      return d;
    }
    if (key === 'this_monday') {
      const d = new Date(base.getTime());
      const day = d.getDay() || 7;
      d.setDate(d.getDate() - (day - 1));
      return d;
    }
    if (key === 'next_monday') {
      const d = new Date(base.getTime());
      const day = d.getDay() || 7;
      d.setDate(d.getDate() - (day - 1) + 7);
      return d;
    }
    return null;
  }

  function resolveDateInput_(raw) {
    const text = String(raw || '').trim();
    if (!text) return null;
    const presetDate = resolveDatePreset_(text);
    if (presetDate) return presetDate;
    const strict = utils.parseDateTextStrict(text);
    if (!strict || isNaN(strict)) return null;
    strict.setHours(0,0,0,0);
    return strict;
  }

  function escapeHtml_(s) {
    return String(s == null ? '' : s)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  const CARD_COLOR_DEFAULTS = {
    notStarted: '#1d4ed8',
    inProgress: '#7c3aed',
    review: '#d97706',
    approved: '#0f766e',
    completed: '#166534',
    camera: '#7dd3fc',
    taskless: '#334155'
  };

  function normalizeHexColor_(value, fallback) {
    const fb = String(fallback || '#2563eb');
    const raw = String(value || '').trim();
    if (!raw) return fb;
    const m = raw.match(/^#([0-9a-fA-F]{6})$/);
    return m ? ('#' + m[1].toLowerCase()) : fb;
  }

  function applyCardColorTheme_() {
    const c = state.cardColors || {};
    const root = document.documentElement;
    if (!root || !root.style || typeof root.style.setProperty !== 'function') return;
    root.style.setProperty('--card-status-not-started', normalizeHexColor_(c.notStarted, CARD_COLOR_DEFAULTS.notStarted));
    root.style.setProperty('--card-status-in-progress', normalizeHexColor_(c.inProgress, CARD_COLOR_DEFAULTS.inProgress));
    root.style.setProperty('--card-status-review', normalizeHexColor_(c.review, CARD_COLOR_DEFAULTS.review));
    root.style.setProperty('--card-status-approved', normalizeHexColor_(c.approved, CARD_COLOR_DEFAULTS.approved));
    root.style.setProperty('--card-status-completed', normalizeHexColor_(c.completed, CARD_COLOR_DEFAULTS.completed));
    root.style.setProperty('--card-camera-accent', normalizeHexColor_(c.camera, CARD_COLOR_DEFAULTS.camera));
    root.style.setProperty('--card-taskless-bg', normalizeHexColor_(c.taskless, CARD_COLOR_DEFAULTS.taskless));
  }

  const TASK_FIDS = {
    status: 'fi_0027',
    shotLink: 'fi_0031',
    startDate: 'fi_0029',
    endDate: 'fi_0030',
    stillShot: 'fi_0067',
    travelChars: 'fi_0068',
    noTravelChars: 'fi_0069',
    cameraMovement: 'fi_0070',
    shootingFps: 'fi_0071',
    shootingFrames: 'fi_0072',
    difficultyFactor: 'fi_0073',
    estLength: 'fi_0074',
    finished: 'fi_0075',
    spentLength: 'fi_0076',
    overrunRatio: 'fi_0077',
    taskOrder: 'fi_0095'
  };

  const TASK_STATUS_OPTIONS = ['not_started', 'in_progress', 'review', 'approved', 'completed'];

  function normalizeTaskStatus_(value) {
    const s = String(value || '').trim().toLowerCase();
    if (!s) return '';
    return TASK_STATUS_OPTIONS.indexOf(s) >= 0 ? s : s.replace(/\s+/g, '_');
  }

  function taskRawValue_(task, fid, fallbackKeys) {
    const t = task || {};
    const raw = (t.raw && typeof t.raw === 'object') ? t.raw : {};
    if (fid && raw[fid] != null && raw[fid] !== '') return raw[fid];
    const arr = Array.isArray(fallbackKeys) ? fallbackKeys : [];
    for (let i = 0; i < arr.length; i++) {
      const k = String(arr[i] || '');
      if (!k) continue;
      if (t[k] != null && t[k] !== '') return t[k];
      if (raw[k] != null && raw[k] !== '') return raw[k];
    }
    return '';
  }

  function taskNumberValue_(task, fid, fallbackKeys, fallback) {
    const v = taskRawValue_(task, fid, fallbackKeys);
    if (v == null || v === '') return fallback;
    if (typeof v === 'number' && isFinite(v)) return v;
    const s = String(v).trim();
    if (!s) return fallback;
    const direct = Number(s.replace(/,/g, ''));
    if (isFinite(direct)) return direct;
    const m = s.match(/-?\d+(?:\.\d+)?/);
    if (!m) return fallback;
    const n = Number(m[0]);
    return isFinite(n) ? n : fallback;
  }

  function formatMinutesLabel_(value) {
    const n = Number(value);
    if (!isFinite(n) || n <= 0) return '';
    return String(Math.round(n)) + 'mins';
  }

  function parseSpentMinutesValue_(value) {
    if (value == null || value === '') return NaN;
    if (typeof value === 'number' && isFinite(value)) return Number(value);
    const raw = String(value || '').trim();
    if (!raw) return NaN;
    if (raw.startsWith('{') && raw.endsWith('}')) {
      try {
        const obj = JSON.parse(raw);
        const n = Number(obj && obj.spentMinutes);
        if (isFinite(n)) return n;
      } catch (_) {}
    }
    const n = Number(raw.replace(/,/g, ''));
    if (isFinite(n)) return n;
    const m = raw.match(/-?\d+(?:\.\d+)?/);
    if (!m) return NaN;
    const d = Number(m[0]);
    return isFinite(d) ? d : NaN;
  }

  function parseOverrunRatioValue_(value) {
    if (value == null || value === '') return NaN;
    if (typeof value === 'number' && isFinite(value)) return Number(value);
    const raw = String(value || '').trim();
    if (!raw) return NaN;
    if (raw.startsWith('{') && raw.endsWith('}')) {
      try {
        const obj = JSON.parse(raw);
        const n = Number(obj && obj.ratioPercent);
        if (isFinite(n)) return n;
      } catch (_) {}
    }
    const n = Number(raw.replace(/,/g, ''));
    if (isFinite(n)) return n;
    const m = raw.match(/-?\d+(?:\.\d+)?/);
    if (!m) return NaN;
    const d = Number(m[0]);
    return isFinite(d) ? d : NaN;
  }

  function parseFinishedDateForInput_(value) {
    if (value == null || value === '') return '';
    let raw = String(value || '').trim();
    if (!raw) return '';
    if (raw.startsWith('{') && raw.endsWith('}')) {
      try {
        const obj = JSON.parse(raw);
        raw = String((obj && (obj.completedAt || obj.finishedDate || obj.date)) || '').trim();
      } catch (_) {
        raw = '';
      }
    }
    if (!raw) return '';
    const d1 = utils.parseDateTextStrict(raw);
    if (d1) return utils.fmtYmdInput(d1);
    const d2 = utils.parseDateTime(raw);
    if (d2 && !isNaN(d2)) return utils.fmtYmdInput(d2);
    return '';
  }

  function taskBoolValue_(task, fid, fallbackKeys) {
    const v = taskRawValue_(task, fid, fallbackKeys);
    if (v === true || v === 1) return true;
    const s = String(v == null ? '' : v).trim().toLowerCase();
    return s === 'true' || s === '1' || s === 'yes' || s === 'on';
  }

  function getTaskOrderValue_(task) {
    const n = Number(taskRawValue_(task, TASK_FIDS.taskOrder, ['taskOrder', 'order']));
    if (!isFinite(n)) return Number.MAX_SAFE_INTEGER;
    return Math.max(1, Math.round(n));
  }

  function getTaskEstLengthMin_(task) {
    const n = taskNumberValue_(task, TASK_FIDS.estLength, ['estLength', 'est_length'], NaN);
    if (!isFinite(n) || n <= 0) return 60;
    return Math.max(1, Math.round(n));
  }

  function applyTaskPatchLocally_(taskId, patch) {
    const key = String(taskId || '').trim();
    if (!key) return;
    const task = state.tasksById[key];
    if (!task) return;
    if (!task.raw || typeof task.raw !== 'object') task.raw = {};
    const p = (patch && typeof patch === 'object') ? patch : {};
    const assignTaskValueByFid_ = (fid, val) => {
      if (fid === TASK_FIDS.status) task.status = String(val || '').trim();
      if (fid === TASK_FIDS.startDate) {
        task.planStart = String(val || '').trim();
        task.planStartIso = String(val || '').trim();
      }
      if (fid === TASK_FIDS.endDate) {
        task.planEnd = String(val || '').trim();
        task.planEndIso = String(val || '').trim();
      }
      if (fid === TASK_FIDS.taskOrder) task.taskOrder = String(val || '').trim();
      if (fid === TASK_FIDS.stillShot) task.stillShot = String(val || '').trim();
      if (fid === TASK_FIDS.travelChars) task.travelChars = String(val || '').trim();
      if (fid === TASK_FIDS.noTravelChars) task.noTravelChars = String(val || '').trim();
      if (fid === TASK_FIDS.cameraMovement) task.cameraMovement = String(val || '').trim();
      if (fid === TASK_FIDS.shootingFps) task.shootingFps = String(val || '').trim();
      if (fid === TASK_FIDS.shootingFrames) task.shootingFrames = String(val || '').trim();
      if (fid === TASK_FIDS.difficultyFactor) task.difficultyFactor = String(val || '').trim();
      if (fid === TASK_FIDS.estLength) task.estLength = String(val || '').trim();
      if (fid === TASK_FIDS.finished) task.finished = String(val || '').trim();
      if (fid === TASK_FIDS.spentLength) task.spentLength = String(val || '').trim();
      if (fid === TASK_FIDS.overrunRatio) task.overrunRatio = String(val || '').trim();
    };
    Object.keys(p).forEach((fid) => {
      task.raw[fid] = p[fid];
      assignTaskValueByFid_(String(fid || ''), p[fid]);
    });
    Object.values(state.cards || {}).forEach((card) => {
      if (String(card && card.taskId || '') !== key) return;
      card.status = String(task.status || '');
      if (task.name) card.title = String(task.name || card.title || '');
    });
  }

  function refreshTaskFromServer_(taskId, onDone) {
    const key = String(taskId || '').trim();
    const done = (typeof onDone === 'function') ? onDone : function () {};
    if (!key) {
      done(false);
      return;
    }
    google.script.run
      .withSuccessHandler((record) => {
        const rec = (record && typeof record === 'object') ? record : {};
        const t = state.tasksById[key];
        if (t) {
          if (!t.raw || typeof t.raw !== 'object') t.raw = {};
          Object.keys(rec).forEach((rk) => {
            t.raw[rk] = rec[rk];
            if (rk === TASK_FIDS.status) t.status = String(rec[rk] || '').trim();
            if (rk === TASK_FIDS.startDate) { t.planStart = String(rec[rk] || '').trim(); t.planStartIso = t.planStart; }
            if (rk === TASK_FIDS.endDate) { t.planEnd = String(rec[rk] || '').trim(); t.planEndIso = t.planEnd; }
            if (rk === TASK_FIDS.taskOrder) t.taskOrder = String(rec[rk] || '').trim();
            if (rk === TASK_FIDS.stillShot) t.stillShot = String(rec[rk] || '').trim();
            if (rk === TASK_FIDS.travelChars) t.travelChars = String(rec[rk] || '').trim();
            if (rk === TASK_FIDS.noTravelChars) t.noTravelChars = String(rec[rk] || '').trim();
            if (rk === TASK_FIDS.cameraMovement) t.cameraMovement = String(rec[rk] || '').trim();
            if (rk === TASK_FIDS.shootingFps) t.shootingFps = String(rec[rk] || '').trim();
            if (rk === TASK_FIDS.shootingFrames) t.shootingFrames = String(rec[rk] || '').trim();
            if (rk === TASK_FIDS.difficultyFactor) t.difficultyFactor = String(rec[rk] || '').trim();
            if (rk === TASK_FIDS.estLength) t.estLength = String(rec[rk] || '').trim();
            if (rk === TASK_FIDS.finished) t.finished = String(rec[rk] || '').trim();
            if (rk === TASK_FIDS.spentLength) t.spentLength = String(rec[rk] || '').trim();
            if (rk === TASK_FIDS.overrunRatio) t.overrunRatio = String(rec[rk] || '').trim();
          });
          t.status = String(rec[TASK_FIDS.status] || t.status || '').trim();
          t.planStart = String(rec[TASK_FIDS.startDate] || t.planStart || '').trim();
          t.planEnd = String(rec[TASK_FIDS.endDate] || t.planEnd || '').trim();
          t.taskOrder = String(rec[TASK_FIDS.taskOrder] || t.taskOrder || '').trim();
          Object.values(state.cards || {}).forEach((card) => {
            if (String(card && card.taskId || '') !== key) return;
            card.status = String(t.status || '');
            if (t.name) card.title = String(t.name || card.title || '');
          });
        }
        done(true);
      })
      .withFailureHandler(() => done(false))
      .sv_getRecord_v2({ entity: 'task', id: key });
  }

  function commitTaskPatchFromInspector_(taskId, patch, onDone) {
    const key = String(taskId || '').trim();
    const p = (patch && typeof patch === 'object') ? patch : {};
    const done = (typeof onDone === 'function') ? onDone : function () {};
    if (!key || !Object.keys(p).length) {
      done(false);
      return;
    }
    applyTaskPatchLocally_(key, p);
    render.grid();
    ui.renderCardList();
    ui.refreshInspectorValuesFromCard();
    utils.saveStatus('saving', 'Saving task...');
    google.script.run
      .withSuccessHandler((res) => {
        const ok = !!(res && res.ok);
        if (!ok) {
          utils.saveStatus('error', String((res && (res.error || res.note)) || 'Task save failed'));
          done(false);
          return;
        }
        applyTaskPatchLocally_(key, p);
        refreshTaskFromServer_(key, () => {
          render.grid();
          ui.renderCardList();
          ui.refreshInspectorValuesFromCard();
          utils.saveStatus('saved', 'Task saved');
          done(true);
        });
      })
      .withFailureHandler((err) => {
        refreshTaskFromServer_(key, () => {
          render.grid();
          ui.renderCardList();
          ui.refreshInspectorValuesFromCard();
        });
        utils.saveStatus('error', String(err && (err.message || err) || 'Task save failed'));
        done(false);
      })
      .sv_setRecord_v2('task', key, p, { actor: 'scheduler_inspector' });
  }

  function getTaskByIdSafe_(id) {
    var key = String(id || '').trim();
    if (!key) return null;
    return state.tasksById[key] || null;
  }

  function resolveCardDisplayValueByField_(card, rawFieldKey, slotType) {
    var fieldKey = rawFieldKey;
    fieldKey = normalizeCardDisplayField_(fieldKey, slotType === 'main' ? 'shot_code' : 'task_name');
    var task = getTaskByIdSafe_(card && card.taskId);
    if (/^task:/i.test(fieldKey)) {
      var taskDynKey = fieldKey.replace(/^task:/i, '');
      if (!task) return '';
      var dynVal = task[taskDynKey];
      if (dynVal == null || dynVal === '') dynVal = taskRawValue_(task, '', [taskDynKey]);
      var dynKeyNorm = String(taskDynKey || '').trim().toLowerCase();
      if (dynKeyNorm === 'estlength' || dynKeyNorm === 'est_length' || dynKeyNorm === String(TASK_FIDS.estLength || '').toLowerCase()) {
        return formatMinutesLabel_(dynVal);
      }
      return String(dynVal == null ? '' : dynVal).trim();
    }
    if (/^card:/i.test(fieldKey)) {
      var cardDynKey = fieldKey.replace(/^card:/i, '');
      return String(card && card[cardDynKey] == null ? '' : card[cardDynKey]).trim();
    }
    if (!task && fieldKey.indexOf('card_') !== 0) return '';
    if (fieldKey === 'shot_code') return String(task.shotCode || task.shotId || '').trim();
    if (fieldKey === 'shot_id') return String(task.shotId || '').trim();
    if (fieldKey === 'task_name') return String(task.name || '').trim();
    if (fieldKey === 'task_status') return String(task.status || '').trim();
    if (fieldKey === 'task_assignee') return String(task.assignee || '').trim();
    if (fieldKey === 'task_est_length') return formatMinutesLabel_(taskRawValue_(task, TASK_FIDS.estLength, ['estLength', 'est_length']));
    if (fieldKey === 'task_id') return String(task.id || card.taskId || '').trim();
    if (fieldKey === 'card_id') return String(card && card.id || '').trim();
    if (fieldKey === 'card_memo') return String(card && card.memo || '').trim();
    if (fieldKey === 'card_lane') return String(card && card.laneId || '').trim();
    if (fieldKey === 'card_start_slot') return String(card && card.start || '').trim();
    if (fieldKey === 'card_end_slot') return String(card && card.end || '').trim();
    if (fieldKey === 'card_length') {
      var st = Number(card && card.start);
      var ed = Number(card && card.end);
      if (!isFinite(st) || !isFinite(ed)) return '';
      return String(Math.max(1, Math.round(ed - st + 1)) * Math.max(1, Math.round(Number(config.slotMin) || 1)));
    }
    return '';
  }

  function resolveCardDisplayValue_(card, slotType) {
    var fieldKey = slotType === 'main' ? state.cardDisplayMain : state.cardDisplaySub;
    return resolveCardDisplayValueByField_(card, fieldKey, slotType);
  }

  function getCardDisplayModel_(card) {
    var cardNo = (card && card.displayId != null && card.displayId !== '') ? String(card.displayId) : utils.getDisplayId(card && card.id);
    cardNo = String(cardNo || '').trim();
    if (/^\d+$/.test(cardNo)) cardNo = String(Number(cardNo));
    var hasTask = !!getTaskByIdSafe_(card && card.taskId);
    var mainText = resolveCardDisplayValue_(card, 'main');
    var subText = resolveCardDisplayValue_(card, 'sub');
    // Taskless cards can use dedicated display fields from settings.
    if (!hasTask) {
      var tasklessMain = resolveCardDisplayValueByField_(card, state.tasklessDisplayMain, 'main');
      var tasklessSub = resolveCardDisplayValueByField_(card, state.tasklessDisplaySub, 'sub');
      if (String(tasklessMain || '').trim()) mainText = tasklessMain;
      if (String(tasklessSub || '').trim()) subText = tasklessSub;
      if (!String(mainText || '').trim()) mainText = String(card && card.memo || '').trim();
      if (!String(subText || '').trim()) {
        var st = Number(card && card.start);
        var ed = Number(card && card.end);
        if (isFinite(st) && isFinite(ed)) {
          subText = String(Math.max(1, Math.round(ed - st + 1)) * Math.max(1, Math.round(Number(config.slotMin) || 1)));
        }
      }
    }
    return {
      cardNo: cardNo,
      mainText: mainText,
      subText: subText
    };
  }

  function parseEntityIdsClient_(value, prefix) {
    var out = [];
    var seen = {};
    var pfx = String(prefix || '').trim().toLowerCase();
    var pushOne = function(token) {
      var s = String(token || '').trim();
      if (!s) return;
      var lower = s.toLowerCase();
      if (pfx) {
        if (!new RegExp('^' + pfx + '_').test(lower)) return;
      }
      if (seen[lower]) return;
      seen[lower] = true;
      out.push(s);
    };
    var walk = function(v) {
      if (v === null || v === undefined || v === '') return;
      if (Array.isArray(v)) {
        v.forEach(walk);
        return;
      }
      if (typeof v === 'object') {
        ['id', 'ids', 'value', 'values', 'list', 'items', 'assetIds', 'asset_ids'].forEach(function(k) {
          if (v.hasOwnProperty(k)) walk(v[k]);
        });
        return;
      }
      var s = String(v).trim();
      if (!s) return;
      if (pfx) {
        var re = new RegExp(pfx + '_[a-z0-9]+', 'ig');
        var hits = s.match(re);
        if (hits && hits.length) {
          hits.forEach(pushOne);
          return;
        }
      }
      s.split(/[\s,;|\n\r\t]+/).forEach(pushOne);
    };
    walk(value);
    return out;
  }

  function getTaskAssetIds_(taskId) {
    var task = getTaskByIdSafe_(taskId);
    if (!task) return [];
    return parseEntityIdsClient_(task.assetIds || task.assets || task.asset_ids || '', 'as');
  }

  function getAssetCapacity_(assetId) {
    var key = String(assetId || '').trim();
    var fb = Number(state.assetCapacityDefault);
    if (!isFinite(fb) || fb <= 0) fb = 1;
    if (!key) return fb;
    var n = Number(state.assetCapacityById && state.assetCapacityById[key]);
    if (isFinite(n) && n > 0) return Math.floor(n);
    return fb;
  }

  function getAssetLabel_(assetId) {
    var key = String(assetId || '').trim();
    if (!key) return '';
    var name = state.assetNameById && state.assetNameById[key];
    if (name) return String(name);
    return key;
  }

  function buildTaskDetailHref_(taskId) {
    var tid = String(taskId || '').trim();
    if (!tid) return '#';
    try {
      if (window.Router && typeof window.Router.buildEntityUrl === 'function') {
        return window.Router.buildEntityUrl('task', tid);
      }
    } catch (_) {}
    var base = String(state.scriptUrl || state.scriptUrlServer || '').trim();
    if (!base) {
      try {
        var p = String(location.pathname || '');
        base = /\/userCodeAppPanel\b/i.test(p) ? (location.origin + '/exec') : (location.origin + p);
      } catch (_) {
        base = '';
      }
    }
    if (!base) return '#';
    try {
      var u = new URL(base, location.origin);
      u.search = '';
      u.searchParams.set('page', 'Detail');
      u.searchParams.set('entity', 'task');
      u.searchParams.set('id', tid);
      return u.toString();
    } catch (_) {
      return base + '?page=Detail&entity=task&id=' + encodeURIComponent(tid);
    }
  }

  function slotLabelFromRaw_(rawSlot) {
    var v = utils.slotToDateVal(rawSlot, 'start');
    return utils.fmtYmdText(v.date) + '-' + v.slot;
  }

  function refreshAssetUsageState_() {
    var usageBySlot = {};
    var cardConflict = {};
    var cardConflictSlots = {};
    var overloadedAssets = 0;
    var conflictSlots = 0;

    Object.values(state.cards || {}).forEach(function(card) {
      if (!card || !isFinite(Number(card.start)) || !isFinite(Number(card.end))) return;
      var start = Math.max(1, Math.round(Number(card.start)));
      var end = Math.max(start, Math.round(Number(card.end)));
      var assetIds = getTaskAssetIds_(card.taskId);
      if (!assetIds.length) return;
      for (var slot = start; slot <= end; slot++) {
        if (!usageBySlot[slot]) usageBySlot[slot] = {};
        var slotUsage = usageBySlot[slot];
        for (var i = 0; i < assetIds.length; i++) {
          var aid = assetIds[i];
          if (!slotUsage[aid]) {
            slotUsage[aid] = {
              count: 0,
              capacity: getAssetCapacity_(aid),
              cardIds: {}
            };
          }
          slotUsage[aid].count += 1;
          slotUsage[aid].cardIds[String(card.id)] = true;
        }
      }
    });

    Object.keys(usageBySlot).forEach(function(slotKey) {
      var slotUsage = usageBySlot[slotKey] || {};
      var slotHasConflict = false;
      Object.keys(slotUsage).forEach(function(assetId) {
        var u = slotUsage[assetId];
        if (!u) return;
        if (u.count <= u.capacity) return;
        overloadedAssets += 1;
        slotHasConflict = true;
        Object.keys(u.cardIds || {}).forEach(function(cardId) {
          if (!cardConflict[cardId]) cardConflict[cardId] = { assets: {}, overSlots: 0 };
          if (!cardConflictSlots[cardId]) cardConflictSlots[cardId] = {};
          cardConflict[cardId].assets[assetId] = (cardConflict[cardId].assets[assetId] || 0) + 1;
          cardConflictSlots[cardId][slotKey] = true;
        });
      });
      if (slotHasConflict) conflictSlots += 1;
    });

    Object.keys(cardConflict).forEach(function(cardId) {
      var slotSet = cardConflictSlots[cardId] || {};
      cardConflict[cardId].overSlots = Object.keys(slotSet).length;
      cardConflict[cardId].assetIds = Object.keys(cardConflict[cardId].assets || {});
    });

    state.assetUsageBySlot = usageBySlot;
    state.cardAssetConflictById = cardConflict;
    state.assetUsageStats = {
      conflictSlots: conflictSlots,
      overloadedAssets: overloadedAssets,
      affectedCards: Object.keys(cardConflict).length
    };
  }

  function getAssetsColWidth_() {
    try {
      var raw = getComputedStyle(document.documentElement).getPropertyValue('--asset-col-w');
      var n = Math.round(parseFloat(String(raw || '').replace('px', '')));
      if (isFinite(n) && n > 80) return n;
    } catch (_) {}
    return (isFinite(Number(state.assetColWidth)) && Number(state.assetColWidth) > 0) ? Number(state.assetColWidth) : 65;
  }

  function updateViewLaneSaveButtons_() {
    var viewBtn = document.getElementById('btn-save-view');
    if (viewBtn) {
      viewBtn.textContent = state.viewDirty ? 'Save View*' : 'Save View';
    }
    var laneBtn = document.getElementById('btn-save-lane');
    if (laneBtn) {
      laneBtn.textContent = state.laneDirty ? 'Save Lane*' : 'Save Lane';
    }
  }

  function markViewDirty_() {
    state.viewDirty = true;
    updateViewLaneSaveButtons_();
  }

  function markLaneDirty_() {
    state.laneDirty = true;
    updateViewLaneSaveButtons_();
  }

  function summarizeAssetsForRawRange_(fromRaw, toRaw) {
    var byAsset = {};
    var start = Math.max(1, Math.round(Number(fromRaw) || 1));
    var end = Math.max(start, Math.round(Number(toRaw) || start));
    for (var slot = start; slot <= end; slot++) {
      var slotUsage = state.assetUsageBySlot[String(slot)] || state.assetUsageBySlot[slot];
      if (!slotUsage) continue;
      Object.keys(slotUsage).forEach(function(assetId) {
        var u = slotUsage[assetId];
        if (!u) return;
        var count = Math.max(0, Number(u.count) || 0);
        if (!byAsset[assetId]) {
          byAsset[assetId] = {
            assetId: assetId,
            peak: 0,
            capacity: getAssetCapacity_(assetId)
          };
        }
        if (count > byAsset[assetId].peak) byAsset[assetId].peak = count;
      });
    }
    return Object.keys(byAsset).map(function(assetId) {
      var item = byAsset[assetId];
      item.over = item.peak > item.capacity;
      item.label = getAssetLabel_(assetId);
      return item;
    }).sort(function(a, b) {
      if (a.over !== b.over) return a.over ? -1 : 1;
      if (a.peak !== b.peak) return b.peak - a.peak;
      return String(a.label || '').localeCompare(String(b.label || ''));
    });
  }

  function isAssetCellSelected_(dateVal, rawStart, rawEnd) {
    var sel = state.assetCellSelection;
    if (!sel) return false;
    return String(sel.dateVal || '') === String(dateVal || '') &&
      Number(sel.rawStart || 0) === Number(rawStart || 0) &&
      Number(sel.rawEnd || 0) === Number(rawEnd || 0);
  }

  function renderAssetCellInspector_(selection, container) {
    if (!selection || !container) return;
    var rows = summarizeAssetsForRawRange_(selection.rawStart, selection.rawEnd);
    var head = document.createElement('div');
    head.style.cssText = 'background:#222; padding:6px; font-weight:bold; border-radius:4px;';
    head.textContent = 'ASSETS';
    container.appendChild(head);

    var metaRow = document.createElement('div');
    metaRow.style.cssText = 'display:flex; gap:6px; flex-wrap:wrap;';
    var tagRange = document.createElement('span');
    tagRange.className = 'info-tag';
    tagRange.textContent = `${slotLabelFromRaw_(selection.rawStart)} - ${slotLabelFromRaw_(selection.rawEnd)}`;
    var tagRes = document.createElement('span');
    tagRes.className = 'info-tag';
    tagRes.textContent = `Res: ${selection.resolutionLabel || '-'}`;
    metaRow.appendChild(tagRange);
    metaRow.appendChild(tagRes);
    container.appendChild(metaRow);

    var list = document.createElement('div');
    list.style.cssText = 'display:flex; flex-direction:column; gap:4px;';
    if (!rows.length) {
      var empty = document.createElement('div');
      empty.className = 'inp';
      empty.style.cssText = 'font-size:11px; color:#888;';
      empty.textContent = '(no assets in this cell)';
      list.appendChild(empty);
    } else {
      rows.forEach(function(r) {
        var item = document.createElement('div');
        item.className = 'inp';
        item.style.cssText = 'display:flex; align-items:center; justify-content:space-between; font-size:11px; line-height:1.25;';
        if (r && r.over) {
          item.style.borderColor = '#ef4444';
          item.style.color = '#fecaca';
          item.style.background = 'rgba(127,29,29,0.25)';
        }
        var left = document.createElement('span');
        left.style.cssText = 'min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;';
        left.textContent = String(r && r.label || '');
        var right = document.createElement('span');
        right.style.cssText = 'font-family:ui-monospace, SFMono-Regular, Menlo, monospace; margin-left:8px;';
        right.textContent = `(${Number(r && r.peak || 0)}/${Number(r && r.capacity || 0)})`;
        item.appendChild(left);
        item.appendChild(right);
        list.appendChild(item);
      });
    }
    container.appendChild(list);
  }

  function renderAssetsColumnInGrid_(lanes, pxPerDay, snap) {
    var assetsColW = getAssetsColWidth_();
    var laneCount = Array.isArray(lanes) ? lanes.length : 0;
    var laneWidth = getLaneWidth_();
    var leftBase = laneCount * laneWidth;
    var dayMinutes = Math.max(config.slotMin, config.workHours * 60);
    var snapMin = (snap && snap.min && snap.min > 0) ? snap.min : config.slotMin;
    if (snapMin >= dayMinutes) snapMin = dayMinutes;
    if (snapMin < config.slotMin) snapMin = config.slotMin;
    var slotsPerDay = Math.max(1, getSlotsPerDay_());
    state.workDayMap.forEach(function(day, dayIdx) {
      var dateVal = formatYmd_(day);
      var dayTop = dayIdx * pxPerDay;
      var dayBottom = dayTop + pxPerDay;
      for (var startMin = 0; startMin < dayMinutes; startMin += snapMin) {
        var endMin = Math.min(dayMinutes, startMin + snapMin);
        var cellMinutes = Math.max(config.slotMin, endMin - startMin);
        var top = dayTop + Math.round((startMin / dayMinutes) * pxPerDay);
        var bottom = (endMin >= dayMinutes)
          ? dayBottom
          : (dayTop + Math.round((endMin / dayMinutes) * pxPerDay));
        if (bottom <= top) bottom = top + 1;
        var h = Math.max(1, bottom - top);
        var slotInDayStart = Math.floor(startMin / config.slotMin) + 1;
        var spanSlots = Math.max(1, Math.ceil(cellMinutes / config.slotMin));
        var rawStart = utils.dateValToSlot(dateVal, slotInDayStart, 'start');
        var rawEnd = Math.min(rawStart + spanSlots - 1, utils.dateValToSlot(dateVal, slotsPerDay, 'end'));
        var rows = summarizeAssetsForRawRange_(rawStart, rawEnd);
        var cell = document.createElement('div');
        cell.className = 'asset-cell';
        if (rows.length) cell.classList.add('has-assets');
        cell.style.left = leftBase + 'px';
        cell.style.width = assetsColW + 'px';
        cell.style.top = top + 'px';
        cell.style.height = Math.max(1, h) + 'px';
        var hasOver = rows.some(function(r) { return !!(r && r.over); });
        if (hasOver) cell.classList.add('over');
        if (isAssetCellSelected_(dateVal, rawStart, rawEnd)) cell.classList.add('selected');
        var summaryTitle = rows.slice(0, 5).map(function(r) {
          return `${r.label} (${r.peak}/${r.capacity})${r.over ? ' !' : ''}`;
        }).join('\n');
        cell.title = `${slotLabelFromRaw_(rawStart)} - ${slotLabelFromRaw_(rawEnd)}\n` + (summaryTitle || '(no assets)');
        cell.dataset.assetCell = '1';
        cell.dataset.dateVal = dateVal;
        cell.dataset.rawStart = String(rawStart);
        cell.dataset.rawEnd = String(rawEnd);
        cell.dataset.resolutionLabel = snap && snap.label ? String(snap.label) : '';
        cell.addEventListener('mousedown', function(ev) {
          ev.stopPropagation();
        });
        cell.addEventListener('click', function(ev) {
          ev.preventDefault();
          ev.stopPropagation();
          var sel = selectionFromAssetCellElement_(ev.currentTarget) || {
            dateVal: dateVal,
            rawStart: rawStart,
            rawEnd: rawEnd,
            resolutionLabel: snap && snap.label ? String(snap.label) : '',
            rows: rows
          };
          actions.selectAssetCell(sel);
        });
        els.canvas.appendChild(cell);
      }
    });
  }

  function warnLegacySlotOffsetOnce_() {
    if (state.legacyOffsetWarned) return;
    const starts = Object.values(state.cards || {})
      .map((c) => Number(c && c.start))
      .filter((n) => isFinite(n));
    if (!starts.length) return;
    const slotsPerDay = Math.max(1, Math.round((config.workHours * 60) / config.slotMin));
    const minStartSlot = Math.min.apply(null, starts);
    const maybeLegacyOffset = minStartSlot >= slotsPerDay &&
      ((minStartSlot % slotsPerDay) === 0 || (minStartSlot % slotsPerDay) === 1);
    if (!maybeLegacyOffset) return;
    state.legacyOffsetWarned = true;
    console.warn('[MOTK][Scheduler] Legacy slot offset suspected; stored slots may be one-day shifted.', {
      slotsPerDay: slotsPerDay,
      minStartSlot: minStartSlot,
      originDate: formatYmd_(config.originDate)
    });
  }

  function getRangeOptions_() {
    return [1, 5, 14, 30, 90, 180, 365, 730];
  }

  function computeEndDateByRange_(startDate, dayCount) {
    const s = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
    const n = Math.max(1, Number(dayCount) || 1);
    return utils.shiftWorkdays(s, n - 1);
  }

  function computeDayCountByStartEnd_(startDate, endDate) {
    const s = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
    const e = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
    const diffDays = Math.floor((e.getTime() - s.getTime()) / 86400000);
    return Math.max(1, diffDays + 1);
  }

  function syncEndFromRange_() {
    state.endDate = computeEndDateByRange_(state.startDate, state.dayCount);
  }

  function buildCardDisplayOptions_() {
    var options = CARD_DISPLAY_BASE_OPTIONS.slice();
    var seen = {};
    options.forEach(function (opt) { seen[opt.value] = true; });
    var custom = Array.isArray(state.customCardDisplayFields) ? state.customCardDisplayFields : [];
    custom.forEach(function (raw) {
      var norm = normalizeCardDisplayField_(raw, '');
      if (!norm || seen[norm]) return;
      seen[norm] = true;
      options.push({ value: norm, label: norm.indexOf(':') > 0 ? norm.replace(':', ': ') : norm });
    });
    var taskSamples = Array.isArray(state.tasks) ? state.tasks : [];
    taskSamples.slice(0, 200).forEach(function (t) {
      if (!t || typeof t !== 'object') return;
      Object.keys(t).forEach(function (k) {
        if (!k) return;
        var v = t[k];
        if (v && typeof v === 'object') return;
        var key = 'task:' + String(k);
        if (seen[key]) return;
        seen[key] = true;
        options.push({ value: key, label: 'Task: ' + String(k) });
      });
    });
    var cardSamples = Object.values(state.cards || {}).slice(0, 200);
    cardSamples.forEach(function (c) {
      if (!c || typeof c !== 'object') return;
      Object.keys(c).forEach(function (k) {
        if (!k) return;
        var v = c[k];
        if (v && typeof v === 'object') return;
        var key = 'card:' + String(k);
        if (seen[key]) return;
        seen[key] = true;
        options.push({ value: key, label: 'Card: ' + String(k) });
      });
    });
    return options;
  }

  const store = {
    init: (data) => {
      const cfg = data.config || {};
      const origin = cfg.originDate || cfg.origin || '';
      const slotMin = Number(cfg.slotMin || config.slotMin);
      const workHours = Number(cfg.workHours || config.workHours);

      config.slotMin = (isFinite(slotMin) && slotMin > 0) ? slotMin : config.slotMin;
      config.workHours = (isFinite(workHours) && workHours > 0) ? workHours : config.workHours;

      let parsedOrigin = null;
      if (origin !== undefined && origin !== null && String(origin).trim() !== '') {
        parsedOrigin = utils.parseDateTime(origin);
      }
      if (parsedOrigin && !isNaN(parsedOrigin)) {
        parsedOrigin.setHours(12,0,0,0);
        config.originDate = parsedOrigin;
      } else if (!config.originDate) {
        config.originDate = new Date();
        config.originDate.setHours(12,0,0,0);
      }
      config.originDisplayText = normalizeOriginDisplayText_(origin);
      if (!config.originDisplayText) {
        config.originDisplayText = formatYmd_(config.originDate).replace(/-/g, '/');
      }
      if (config.originDate) {
        config.originAnchor = new Date(
          config.originDate.getFullYear(),
          config.originDate.getMonth(),
          config.originDate.getDate(),
          0, 0, 0, 0
        );
      }

      state.schedId = (data.schedConfig && data.schedConfig.activeSchedId) ? String(data.schedConfig.activeSchedId) : state.schedId;
      state.viewMeta = (data.schedConfig && data.schedConfig.view_meta) ? data.schedConfig.view_meta : {};
      state.schedName = (data.schedConfig && data.schedConfig.schedName) ? String(data.schedConfig.schedName) : state.schedName;
      state.allScheds = (data.schedConfig && Array.isArray(data.schedConfig.allScheds)) ? data.schedConfig.allScheds : [];
      state.assetCapacityById = (data && data.assetCapacityById && typeof data.assetCapacityById === 'object') ? data.assetCapacityById : {};
      state.assetNameById = (data && data.assetNameById && typeof data.assetNameById === 'object') ? data.assetNameById : {};
      state.assetCapacityDefault = Number(data && data.assetCapacityDefault);
      if (!isFinite(state.assetCapacityDefault) || state.assetCapacityDefault <= 0) state.assetCapacityDefault = 1;
      state.projectTimezoneRaw = String((data && data.projectTimezone) || '').trim();
      state.projectTimezoneResolved = String((data && data.projectTimezoneResolved) || '').trim();
      if (data && Object.prototype.hasOwnProperty.call(data, 'timezoneConfigured')) {
        state.timezoneConfigured = !!data.timezoneConfigured;
      } else {
        state.timezoneConfigured = !!state.projectTimezoneRaw;
      }

      var hasViewDate = false;
      if (state.viewMeta && typeof state.viewMeta === 'object') {
        if (state.viewMeta.zoom !== undefined && state.viewMeta.zoom !== null) {
          state.slotPx = utils.calcSlotPx(state.viewMeta.zoom);
        }
        if (state.viewMeta.dayCount) {
          state.dayCount = Number(state.viewMeta.dayCount) || state.dayCount;
        }
        state.startPreset = normalizePresetKey_(state.viewMeta.startPreset || 'custom');
        state.endPreset = normalizePresetKey_(state.viewMeta.endPreset || 'custom');
        state.viewDriver = String(state.viewMeta.viewDriver || '').trim().toLowerCase() === 'end' ? 'end' : 'range';
        state.viewMode = String(state.viewMeta.viewMode || '').trim().toLowerCase() === 'lite' ? 'lite' : 'grid';
        if (state.requestedViewMode === 'lite' || state.requestedViewMode === 'grid') state.viewMode = state.requestedViewMode;
        state.cardDisplayMain = normalizeCardDisplayField_(state.viewMeta.cardDisplayMain, 'shot_code');
        state.cardDisplaySub = normalizeCardDisplayField_(state.viewMeta.cardDisplaySub, 'task_name');
        state.tasklessDisplayMain = normalizeCardDisplayField_(state.viewMeta.tasklessDisplayMain, 'card_memo');
        state.tasklessDisplaySub = normalizeCardDisplayField_(state.viewMeta.tasklessDisplaySub, 'card_length');
        state.customCardDisplayFields = Array.isArray(state.viewMeta.customCardDisplayFields)
          ? state.viewMeta.customCardDisplayFields.map(function (v) { return normalizeCardDisplayField_(v, ''); }).filter(function (v) { return /^task:|^card:/i.test(String(v || '')); })
          : [];
        var vmColors = (state.viewMeta.cardColors && typeof state.viewMeta.cardColors === 'object') ? state.viewMeta.cardColors : {};
        state.cardColors = {
          notStarted: normalizeHexColor_(vmColors.notStarted, CARD_COLOR_DEFAULTS.notStarted),
          inProgress: normalizeHexColor_(vmColors.inProgress, CARD_COLOR_DEFAULTS.inProgress),
          review: normalizeHexColor_(vmColors.review, CARD_COLOR_DEFAULTS.review),
          approved: normalizeHexColor_(vmColors.approved, CARD_COLOR_DEFAULTS.approved),
          completed: normalizeHexColor_(vmColors.completed, CARD_COLOR_DEFAULTS.completed),
          camera: normalizeHexColor_(vmColors.camera, CARD_COLOR_DEFAULTS.camera),
          taskless: normalizeHexColor_(vmColors.taskless, CARD_COLOR_DEFAULTS.taskless)
        };
        var vmLaneWidth = Number(state.viewMeta.laneWidth);
        if (isFinite(vmLaneWidth) && vmLaneWidth > 0) state.laneWidth = Math.round(vmLaneWidth);
        var vmAssetWidth = Number(state.viewMeta.assetColWidth);
        if (isFinite(vmAssetWidth) && vmAssetWidth > 0) state.assetColWidth = Math.round(vmAssetWidth);
        if (state.viewMeta.assetColumnVisible !== undefined && state.viewMeta.assetColumnVisible !== null) {
          state.assetColumnVisible = !!state.viewMeta.assetColumnVisible;
        }
        if (state.viewMeta.autoPush !== undefined && state.viewMeta.autoPush !== null) {
          state.autoPush = !!state.viewMeta.autoPush;
        }
        if (state.viewMeta.startDate) {
          var vmDate = utils.parseDateTime(state.viewMeta.startDate);
          if (vmDate && !isNaN(vmDate)) {
            vmDate.setHours(0,0,0,0);
            state.startDate = vmDate;
            hasViewDate = true;
          }
        }
        if (state.viewMeta.endDate) {
          var vmEndDate = utils.parseDateTime(state.viewMeta.endDate);
          if (vmEndDate && !isNaN(vmEndDate)) {
            vmEndDate.setHours(0,0,0,0);
            state.endDate = vmEndDate;
          }
        }
      }

      if (els.configInfo) {
        var originText = config.originDisplayText || formatYmd_(config.originDate).replace(/-/g, '/');
        var baseOriginText = formatYmd_(config.originDate).replace(/-/g, '/');
        var tzText = state.projectTimezoneRaw || 'UNSET';
        els.configInfo.innerHTML = `
          <span class="info-tag" title="Base origin for rawSlot: ${baseOriginText}">Origin: ${originText}</span>
          <span class="info-tag">Slot: ${config.slotMin}m</span>
          <span class="info-tag">Work: ${config.workHours}h</span>
          <span class="info-tag" style="${state.timezoneConfigured ? '' : 'color:#f87171; border-color:#f87171;'}">TZ: ${tzText}</span>
        `;
      }
      state.scriptUrlServer = String(data.scriptUrl || '');
      if (state.scriptUrlServer) state.scriptUrl = state.scriptUrlServer;
      document.documentElement.style.setProperty('--lane-w', `${Math.round(state.laneWidth)}px`);
      document.documentElement.style.setProperty('--asset-col-w', `${Math.round(state.assetColWidth)}px`);
      applyCardColorTheme_();
      var brandLink = document.getElementById('brand-link');
      if (brandLink) brandLink.href = state.scriptUrl;
      var schedSel = document.getElementById('sched-switch');
      if (schedSel) {
        schedSel.innerHTML = '';
        var list = (state.allScheds && state.allScheds.length) ? state.allScheds : [{ id: state.schedId, name: state.schedName }];
        list.forEach(function(s) {
          if (!s || !s.id) return;
          var opt = document.createElement('option');
          opt.value = s.id;
          opt.textContent = s.name || s.id;
          if (String(s.id) === String(state.schedId)) opt.selected = true;
          schedSel.appendChild(opt);
        });
      }

      const rawTasks = data.tasks || [];
      state.tasks = rawTasks.map((t) => {
        var tidK = _sch_inferIdKey_(t, /^ta_/i);
        var tnmK = _sch_inferNameKey_(t);
        var stK = _sch_inferKeyByParts_(t, ['status']);
        var asK = _sch_inferKeyByParts_(t, ['assignee']) || _sch_inferKeyByParts_(t, ['assign']);
        var psK = _sch_inferKeyByParts_(t, ['plan', 'start', 'iso']) || _sch_inferKeyByParts_(t, ['plan', 'start']) || _sch_inferKeyByParts_(t, ['start']);
        var peK = _sch_inferKeyByParts_(t, ['plan', 'end', 'iso']) || _sch_inferKeyByParts_(t, ['plan', 'end']) || _sch_inferKeyByParts_(t, ['end']);
        var shotCodeK = _sch_inferKeyByParts_(t, ['shot', 'code']) || _sch_inferKeyByParts_(t, ['shotcode']);
        var shotIdK = _sch_inferKeyByParts_(t, ['shot', 'id']) || _sch_inferKeyByParts_(t, ['shot', 'link']) || _sch_inferKeyByParts_(t, ['shot']);
        var assetLinkK = _sch_inferKeyByParts_(t, ['asset', 'link']) || _sch_inferKeyByParts_(t, ['asset']) || _sch_inferKeyByParts_(t, ['resource']);
        var orderK = _sch_inferKeyByParts_(t, ['task', 'order']) || _sch_inferKeyByParts_(t, ['order']);
        var idVal = String(tidK ? t[tidK] : (t.taskId || t.id || '')).trim();
        return {
          id: idVal,
          taskId: idVal,
          name: String(tnmK ? t[tnmK] : (t.taskName || t.name || '')).trim(),
          status: String(stK ? t[stK] : (t.status || '')).trim(),
          assignee: String(asK ? t[asK] : (t.assignee || '')).trim(),
          planStartIso: String(psK ? t[psK] : (t.planStartIso || t.planStart || '')).trim(),
          planEndIso: String(peK ? t[peK] : (t.planEndIso || t.planEnd || '')).trim(),
          planStart: String(psK ? t[psK] : (t.planStartIso || t.planStart || '')).trim(),
          planEnd: String(peK ? t[peK] : (t.planEndIso || t.planEnd || '')).trim(),
          shotCode: String(shotCodeK ? t[shotCodeK] : (t.shotCode || t.shot_code || '')).trim(),
          shotId: String(shotIdK ? t[shotIdK] : (t.shotId || t.shot_id || t.shotLink || t.shot_link || t.shot || '')).trim(),
          assetIds: parseEntityIdsClient_(assetLinkK ? t[assetLinkK] : (t.assetIds || t.asset_ids || t.assetLink || t.asset_link || t.resources || ''), 'as'),
          taskOrder: String(orderK ? t[orderK] : (t.taskOrder || t.order || '')).trim(),
          stillShot: String(taskRawValue_(t, TASK_FIDS.stillShot, ['stillShot', 'still_shot']) || '').trim(),
          travelChars: String(taskRawValue_(t, TASK_FIDS.travelChars, ['travelChars', 'travel_characters']) || '').trim(),
          noTravelChars: String(taskRawValue_(t, TASK_FIDS.noTravelChars, ['noTravelChars', 'no_travel_characters']) || '').trim(),
          cameraMovement: String(taskRawValue_(t, TASK_FIDS.cameraMovement, ['cameraMovement', 'camera_movement']) || '').trim(),
          shootingFps: String(taskRawValue_(t, TASK_FIDS.shootingFps, ['shootingFps', 'shooting_fps']) || '').trim(),
          shootingFrames: String(taskRawValue_(t, TASK_FIDS.shootingFrames, ['shootingFrames', 'shooting_frames']) || '').trim(),
          difficultyFactor: String(taskRawValue_(t, TASK_FIDS.difficultyFactor, ['difficultyFactor', 'difficulty_factor']) || '').trim(),
          estLength: String(taskRawValue_(t, TASK_FIDS.estLength, ['estLength', 'est_length']) || '').trim(),
          finished: String(taskRawValue_(t, TASK_FIDS.finished, ['finished']) || '').trim(),
          spentLength: String(taskRawValue_(t, TASK_FIDS.spentLength, ['spentLength', 'spent_length']) || '').trim(),
          overrunRatio: String(taskRawValue_(t, TASK_FIDS.overrunRatio, ['overrunRatio', 'overrun_ratio']) || '').trim(),
          raw: t
        };
      }).filter(t => t.id);
      state.tasksById = {};
      state.tasks.forEach((t) => { state.tasksById[String(t.id)] = t; });

      state.members = data.members || [];

      var viewLaneVis = (state.viewMeta && state.viewMeta.laneVisibility) ? state.viewMeta.laneVisibility : null;
      const laneMap = new Map();
      laneMap.set('unassigned', { id:'unassigned', label:'Unassigned', order:-1, visible: viewLaneVis && viewLaneVis.hasOwnProperty('unassigned') ? !!viewLaneVis.unassigned : true });
      state.members.forEach((m,i) => {
        var midK = _sch_inferIdKey_(m, /^me_/i);
        var mnmK = _sch_inferNameKey_(m);
        const id = String(midK ? m[midK] : (m.memberId || m.id || '')).trim();
        const name = (mnmK ? String(m[mnmK] || '') : String(m.role || m.name || '')).trim() || id;
        if (id) laneMap.set(id, { id, label: name, order: i, visible: viewLaneVis && viewLaneVis.hasOwnProperty(id) ? !!viewLaneVis[id] : true });
      });
      state.lanes = Array.from(laneMap.values()).sort((a,b) => a.order - b.order);
      var laneOrder = (state.viewMeta && Array.isArray(state.viewMeta.laneOrder)) ? state.viewMeta.laneOrder.map(function(x){ return String(x || ''); }) : [];
      if (laneOrder.length) {
        var laneOrderMap = {};
        laneOrder.forEach(function(id, idx) { laneOrderMap[id] = idx; });
        state.lanes.sort(function(a, b) {
          var aid = String(a && a.id || '');
          var bid = String(b && b.id || '');
          if (aid === 'unassigned') return -1;
          if (bid === 'unassigned') return 1;
          var ao = Object.prototype.hasOwnProperty.call(laneOrderMap, aid) ? laneOrderMap[aid] : 9999;
          var bo = Object.prototype.hasOwnProperty.call(laneOrderMap, bid) ? laneOrderMap[bid] : 9999;
          if (ao !== bo) return ao - bo;
          return String(a.label || aid).localeCompare(String(b.label || bid));
        });
      }

      state.cards = {};
      const tMap = {};
      state.tasks.forEach(t => { tMap[t.id] = t; });

      (data.cards||[]).forEach((c, i) => {
        var cidK = _sch_inferIdKey_(c, /^c_/i);
        var cnumK = _sch_inferKeyByParts_(c, ['card', 'number']) || _sch_inferKeyByParts_(c, ['card', 'no']);
        const rawId = (cidK ? c[cidK] : null) || c.cardId || c.cardNo || (cnumK ? c[cnumK] : null) || `c_${i}`;
        const id = String(rawId).trim() || `c_${i}`;
        var cTidK = _sch_inferIdKey_(c, /^ta_/i);
        const tid = String(cTidK ? c[cTidK] : (c.taskId || c.taskLink || c.taskid || '')).trim();
        const t = tMap[tid] || {};

        var startK = _sch_inferKeyByParts_(c, ['start', 'slot']) || _sch_inferKeyByParts_(c, ['start']);
        let start = Number(c.start || c.startSlot || c.startslot || (startK ? c[startK] : null));
        if (isNaN(start)) {
          if (t.planStart) {
            const ps = utils.parseDateTime(t.planStart);
            start = ps ? utils.dateValToSlot(formatYmd_(ps), 1, 'start') : 1;
          } else start = 1;
        }
        start = Math.max(1, Math.round(start));

        var lenK = _sch_inferKeyByParts_(c, ['length']) || _sch_inferKeyByParts_(c, ['duration']) || _sch_inferKeyByParts_(c, ['len']);
        let len = Number(c.len || c.lengthMin || c.lengthmin || (lenK ? c[lenK] : null));
        if (isNaN(len) || len < config.slotMin) len = Math.max(config.slotMin, 60);
        const dur = Math.ceil(len / config.slotMin);

        var laneK = _sch_inferKeyByParts_(c, ['lane']) || _sch_inferKeyByParts_(c, ['assignee']) || _sch_inferKeyByParts_(c, ['member']);
        let lane = c.laneId || c.laneVal || c.lane || c.laneval || (laneK ? c[laneK] : '') || '';
        if (!lane) lane = t.assignee || 'unassigned';
        lane = String(lane || 'unassigned');

        if (lane !== 'unassigned' && !laneMap.has(lane)) {
          var laneVisible = viewLaneVis && viewLaneVis.hasOwnProperty(lane) ? !!viewLaneVis[lane] : true;
          state.lanes.push({ id: lane, label: lane, order: 999, visible: laneVisible });
          laneMap.set(lane, { id: lane, label: lane, order: 999, visible: laneVisible });
        }

        var displayId = '';
        var rawDisplayId = (cnumK ? c[cnumK] : null);
        if (rawDisplayId === null || rawDisplayId === undefined || String(rawDisplayId).trim() === '') {
          rawDisplayId = c.displayId;
        }
        if (rawDisplayId === null || rawDisplayId === undefined || String(rawDisplayId).trim() === '') {
          rawDisplayId = c.cardNo;
        }
        if (rawDisplayId === null || rawDisplayId === undefined || String(rawDisplayId).trim() === '') {
          rawDisplayId = utils.getDisplayId(id);
        }
        displayId = String(rawDisplayId || '').trim();

        var memoK = _sch_inferKeyByParts_(c, ['memo']) || _sch_inferKeyByParts_(c, ['note']);
        state.cards[id] = {
          id: id,
          displayId: displayId,
          taskId: tid,
          title: t.name || 'Card',
          laneId: lane,
          start: start,
          end: start + Math.max(1, dur) - 1,
          memo: c.memo || c.cardMemo || (memoK ? c[memoK] : '') || '',
          status: t.status || '',
          cardMeta: c.cardMeta || {}
        };
      });
      warnLegacySlotOffsetOnce_();
      refreshAssetUsageState_();

      if (!hasViewDate) {
        store.fitViewToCards();
      }
      if (state.viewDriver === 'end' && state.endDate) {
        state.dayCount = computeDayCountByStartEnd_(state.startDate, state.endDate);
      } else {
        syncEndFromRange_();
      }
      state.dayCount = Math.max(1, Number(state.dayCount) || 1);
      store.calcDays();
      store.updateStartDateInput();
      store.updateEndDateInput();

      var zoomInput = document.getElementById('inp-zoom');
      if (zoomInput) zoomInput.value = state.slotPx;
      var zoomVal = document.getElementById('inp-zoom-val');
      if (zoomVal) zoomVal.value = state.slotPx;
      var pushChk = document.getElementById('chk-push');
      if (pushChk) {
        pushChk.checked = !!state.autoPush;
        pushChk.disabled = false;
      }
      var rangeSel = document.getElementById('sel-range');
      if (rangeSel) {
        var opts = getRangeOptions_().map(function(n){ return String(n); });
        rangeSel.value = opts.indexOf(String(state.dayCount)) >= 0 ? String(state.dayCount) : 'custom';
      }
      var startPresetSel = document.getElementById('sel-start-preset');
      if (startPresetSel) startPresetSel.value = normalizePresetKey_(state.startPreset);
      var endPresetSel = document.getElementById('sel-end-preset');
      if (endPresetSel) endPresetSel.value = normalizePresetKey_(state.endPreset);
      var modeSel = document.getElementById('sel-view-mode');
      if (modeSel) modeSel.value = (state.viewMode === 'lite') ? 'lite' : 'grid';
      var cardMainSel = document.getElementById('sel-card-main');
      var cardSubSel = document.getElementById('sel-card-sub');
      var tasklessMainSel = document.getElementById('sel-taskless-main');
      var tasklessSubSel = document.getElementById('sel-taskless-sub');
      ui.syncCardDisplayFieldSelectors(cardMainSel, cardSubSel, tasklessMainSel, tasklessSubSel);
      var colorNotStarted = document.getElementById('inp-color-not-started');
      if (colorNotStarted) colorNotStarted.value = normalizeHexColor_(state.cardColors.notStarted, CARD_COLOR_DEFAULTS.notStarted);
      var colorInProgress = document.getElementById('inp-color-in-progress');
      if (colorInProgress) colorInProgress.value = normalizeHexColor_(state.cardColors.inProgress, CARD_COLOR_DEFAULTS.inProgress);
      var colorReview = document.getElementById('inp-color-review');
      if (colorReview) colorReview.value = normalizeHexColor_(state.cardColors.review, CARD_COLOR_DEFAULTS.review);
      var colorApproved = document.getElementById('inp-color-approved');
      if (colorApproved) colorApproved.value = normalizeHexColor_(state.cardColors.approved, CARD_COLOR_DEFAULTS.approved);
      var colorCompleted = document.getElementById('inp-color-completed');
      if (colorCompleted) colorCompleted.value = normalizeHexColor_(state.cardColors.completed, CARD_COLOR_DEFAULTS.completed);
      var colorCamera = document.getElementById('inp-color-camera');
      if (colorCamera) colorCamera.value = normalizeHexColor_(state.cardColors.camera, CARD_COLOR_DEFAULTS.camera);
      var colorTaskless = document.getElementById('inp-color-taskless');
      if (colorTaskless) colorTaskless.value = normalizeHexColor_(state.cardColors.taskless, CARD_COLOR_DEFAULTS.taskless);
      var renameInput = document.getElementById('sched-rename-input');
      if (renameInput) renameInput.value = state.schedName;
      var laneWInput = document.getElementById('inp-lane-w');
      if (laneWInput) laneWInput.value = String(Math.round(getLaneWidth_()));
      var assetWInput = document.getElementById('inp-asset-w');
      if (assetWInput) assetWInput.value = String(Math.round(getAssetsColWidth_()));
      state.viewDirty = false;
      state.laneDirty = false;
      updateViewLaneSaveButtons_();

      render.all();
      syncTimezoneGuardUi_();
    },

    fitViewToCards: () => {
      let minS = Infinity;
      let hasCards = false;
      Object.values(state.cards).forEach(c => {
        if (c.start && c.start < minS && c.start > 0) { minS = c.start; hasCards = true; }
      });
      if (hasCards && minS !== Infinity) {
        const n = utils.normalizeSlot(minS, 'start');
        const d = n && n.date ? new Date(n.date.getTime()) : new Date();
        d.setHours(0,0,0,0);
        state.startDate = d;
      } else if (config.originDate) {
        state.startDate = new Date(config.originDate.getTime());
        state.startDate.setHours(0,0,0,0);
      } else {
        state.startDate = new Date();
        state.startDate.setHours(0,0,0,0);
      }

      store.updateStartDateInput();
    },

    updateStartDateInput: () => {
      const input = document.getElementById('start-date');
      if (!input) return;
      if (document.activeElement === input || input.dataset.editing === '1') return;
      input.value = utils.fmtYmdText(state.startDate);
    },

    updateEndDateInput: () => {
      const input = document.getElementById('end-date');
      if (!input) return;
      if (document.activeElement === input || input.dataset.editing === '1') return;
      if (!state.endDate || isNaN(state.endDate)) {
        input.value = '';
        return;
      }
      input.value = utils.fmtYmdText(state.endDate);
    },

    calcDays: () => {
      state.workDayMap = [];
      if (state.viewDriver === 'end' && state.endDate) {
        const s = new Date(state.startDate); s.setHours(0,0,0,0);
        const e = new Date(state.endDate); e.setHours(0,0,0,0);
        if (e.getTime() < s.getTime()) {
          state.endDate = new Date(s.getTime());
          state.dayCount = 1;
          state.workDayMap.push(new Date(s.getTime()));
          return;
        }
        let d = new Date(s.getTime());
        const sameDay = s.getTime() === e.getTime();
        while (d.getTime() <= e.getTime()) {
          const day = d.getDay();
          if (day !== 0 && day !== 6) state.workDayMap.push(new Date(d.getTime()));
          else if (sameDay) state.workDayMap.push(new Date(d.getTime()));
          d.setDate(d.getDate() + 1);
        }
        state.dayCount = Math.max(1, Math.floor((e.getTime() - s.getTime()) / 86400000) + 1);
        if (!state.workDayMap.length) state.workDayMap.push(new Date(s.getTime()));
        return;
      }
      let d = new Date(state.startDate); d.setHours(0,0,0,0);
      for (let i = 0; i < state.dayCount; i++) {
        const day = d.getDay();
        if (day !== 0 && day !== 6) state.workDayMap.push(new Date(d));
        else if (state.dayCount === 1) state.workDayMap.push(new Date(d));
        d.setDate(d.getDate()+1);
      }
    },

    getLanes: () => state.lanes,
    saveLanes: () => {
      markLaneDirty_();
    },
    saveViewMeta: (scope) => {
      var visMap = {};
      state.lanes.forEach(function(l) { visMap[l.id] = l.visible; });
      var meta = {
        zoom: state.slotPx,
        autoPush: state.autoPush,
        dayCount: state.dayCount,
        startDate: state.startDate ? formatYmd_(state.startDate) : null,
        endDate: state.endDate ? formatYmd_(state.endDate) : null,
        startPreset: normalizePresetKey_(state.startPreset),
        endPreset: normalizePresetKey_(state.endPreset),
        viewDriver: state.viewDriver === 'end' ? 'end' : 'range',
        viewMode: state.viewMode === 'lite' ? 'lite' : 'grid',
        laneVisibility: visMap,
        laneOrder: state.lanes.map(function(l) { return String(l.id || ''); }),
        laneWidth: Math.round(getLaneWidth_()),
        assetColWidth: Math.round(getAssetsColWidth_()),
        assetColumnVisible: !!state.assetColumnVisible,
        cardDisplayMain: normalizeCardDisplayField_(state.cardDisplayMain, 'shot_code'),
        cardDisplaySub: normalizeCardDisplayField_(state.cardDisplaySub, 'task_name'),
        tasklessDisplayMain: normalizeCardDisplayField_(state.tasklessDisplayMain, 'card_memo'),
        tasklessDisplaySub: normalizeCardDisplayField_(state.tasklessDisplaySub, 'card_length'),
        customCardDisplayFields: (Array.isArray(state.customCardDisplayFields) ? state.customCardDisplayFields : [])
          .map(function (v) { return normalizeCardDisplayField_(v, ''); })
          .filter(function (v) { return /^task:|^card:/i.test(String(v || '')); }),
        cardColors: {
          notStarted: normalizeHexColor_(state.cardColors && state.cardColors.notStarted, CARD_COLOR_DEFAULTS.notStarted),
          inProgress: normalizeHexColor_(state.cardColors && state.cardColors.inProgress, CARD_COLOR_DEFAULTS.inProgress),
          review: normalizeHexColor_(state.cardColors && state.cardColors.review, CARD_COLOR_DEFAULTS.review),
          approved: normalizeHexColor_(state.cardColors && state.cardColors.approved, CARD_COLOR_DEFAULTS.approved),
          completed: normalizeHexColor_(state.cardColors && state.cardColors.completed, CARD_COLOR_DEFAULTS.completed),
          camera: normalizeHexColor_(state.cardColors && state.cardColors.camera, CARD_COLOR_DEFAULTS.camera),
          taskless: normalizeHexColor_(state.cardColors && state.cardColors.taskless, CARD_COLOR_DEFAULTS.taskless)
        }
      };
      var payload = JSON.stringify({ schedId: state.schedId, type: 'view_meta', value: meta });
      google.script.run
        .withSuccessHandler(function() {
          state.viewDirty = false;
          state.laneDirty = false;
          updateViewLaneSaveButtons_();
          utils.saveStatus('saved', (scope === 'lane') ? 'Lane Saved' : (scope === 'view' ? 'View Saved' : 'Saved'));
        })
        .withFailureHandler(function(err) {
          console.error('[MOTK][Scheduler] saveViewMeta failed', err);
          utils.saveStatus('error', 'Save Error');
        })
        .sv_scheduler_save_meta_v2(payload);
    }
  };

  function dequeueCommitBatch_() {
    const q = Array.isArray(state.commitQueue) ? state.commitQueue : [];
    if (!q.length) return [];
    if (state.disableBatchCommit) return [q.shift()];
    const first = q[0];
    const firstPayload = (first && first.payload && typeof first.payload === 'object') ? first.payload : null;
    if (!firstPayload) {
      q.shift();
      return [];
    }
    const firstAction = String(firstPayload.action || '').trim().toLowerCase();
    if (firstAction !== 'update') return [q.shift()];
    const out = [];
    while (q.length && out.length < 64) {
      const peek = q[0];
      const p = (peek && peek.payload && typeof peek.payload === 'object') ? peek.payload : null;
      if (!p) {
        q.shift();
        continue;
      }
      const action = String(p.action || '').trim().toLowerCase();
      if (action !== 'update') break;
      out.push(q.shift());
    }
    return out.length ? out : [q.shift()];
  }

  function flushCommitQueue_() {
    // Keep edits possible during SNAP, but serialize server writes to avoid lock contention.
    if (state.snapBusy && state.snapPhase === 'rpc') return;
    if (state.undoBusy && state.undoPhase === 'rpc' && !state.commitInflight) return;
    if (state.commitInflight) return;
    const items = dequeueCommitBatch_();
    if (!items.length) return;
    const payloadList = items
      .map((it) => ((it && it.payload && typeof it.payload === 'object') ? it.payload : null))
      .filter((p) => !!p);
    if (!payloadList.length) {
      state.commitInflight = null;
      return;
    }
    const inflight = {
      items: items,
      payload: payloadList[0],
      attempts: Math.max(0, ...items.map((it) => Math.round(Number(it && it.attempts || 0) || 0))),
      batch: payloadList.length > 1
    };
    state.commitInflight = inflight;
    const primaryPayload = payloadList[0];
    const finalize_ = () => {
      state.commitInflight = null;
      queueAssetInspectorRefresh_();
      if (state.undoBusy && state.undoPhase === 'rpc') return;
      flushCommitQueue_();
    };
    const retry_ = (reason) => {
      if (state.undoBusy && state.undoPhase === 'rpc') {
        console.warn('[MOTK][Scheduler][Commit] retry dropped during undo', { reason, count: payloadList.length });
        finalize_();
        return;
      }
      const attempts = Number(inflight.attempts || 0);
      if (attempts >= 3) {
        console.error('[MOTK][Scheduler][Commit] final failure after retries', { reason, count: payloadList.length, attempts });
        utils.saveStatus('error', 'Error');
        finalize_();
        return;
      }
      inflight.attempts = attempts + 1;
      for (let i = 0; i < items.length; i++) {
        items[i].attempts = inflight.attempts;
      }
      state.commitInflight = null;
      for (let i = items.length - 1; i >= 0; i--) state.commitQueue.unshift(items[i]);
      const delayMs = Math.min(120 * inflight.attempts, 600);
      console.warn('[MOTK][Scheduler][Commit] retry scheduled', { reason, attempts: inflight.attempts, delayMs, count: payloadList.length });
      setTimeout(() => flushCommitQueue_(), delayMs);
    };
    const isBatchUnsupportedError_ = (msgLike) => {
      const m = String(msgLike || '').toLowerCase();
      if (!m) return false;
      return (
        m.indexOf('not a function') >= 0 ||
        m.indexOf('is not defined') >= 0 ||
        m.indexOf('undefined') >= 0 ||
        m.indexOf('no such function') >= 0 ||
        m.indexOf('function not found') >= 0
      );
    };
    const fallbackBatchToSingle_ = (reason) => {
      state.disableBatchCommit = true;
      state.commitInflight = null;
      for (let i = items.length - 1; i >= 0; i--) state.commitQueue.unshift(items[i]);
      console.warn('[MOTK][Scheduler][Commit] batch unsupported; fallback to single commits', {
        reason: String(reason || ''),
        count: items.length
      });
      setTimeout(() => flushCommitQueue_(), 0);
    };
    utils.saveStatus('saving', (payloadList.length > 1) ? ('Saving Ã—' + payloadList.length + '...') : 'Saving...');
    const onSuccess_ = (str) => {
      let res = null;
      try { res = JSON.parse(str); } catch (e) { res = { ok: false, error: String(e) }; }
      if (res && res.ok) {
        utils.saveStatus('saved', 'Saved');
        finalize_();
      } else {
        const msg = String((res && (res.error && (res.error.message || res.error))) || 'rpc_error');
        if (inflight.batch && isBatchUnsupportedError_(msg)) {
          fallbackBatchToSingle_(msg);
          return;
        }
        console.warn('[MOTK][Scheduler][Commit] RPC error', { payload: primaryPayload, count: payloadList.length, res, msg });
        retry_('rpc:' + msg);
      }
    };
    const onFailure_ = (err) => {
      const msg = String(err && (err.message || err) || '');
      if (inflight.batch && isBatchUnsupportedError_(msg)) {
        fallbackBatchToSingle_(msg);
        return;
      }
      console.error('[MOTK][Scheduler][Commit] Network failure', { payload: primaryPayload, count: payloadList.length, err });
      retry_('network');
    };
    const runner = google.script.run
      .withSuccessHandler(onSuccess_)
      .withFailureHandler(onFailure_);
    if (payloadList.length > 1) {
      runner.sv_scheduler_commit_batch_v1(JSON.stringify({ items: payloadList }));
      return;
    }
    runner.sv_scheduler_commit_v2(JSON.stringify(primaryPayload));
  }

  function dropPendingCommitQueue_(reason) {
    const before = Array.isArray(state.commitQueue) ? state.commitQueue.length : 0;
    if (!before) return { before: 0, after: 0, dropped: 0 };
    state.commitQueue = [];
    const out = { before: before, after: 0, dropped: before };
    console.info('[MOTK][Scheduler][Commit] dropped pending queue', { reason: String(reason || ''), before: before });
    return out;
  }

  function createCommitOpId_(tag) {
    const base = String(tag || 'op').replace(/[^a-z0-9_-]/ig, '').toLowerCase() || 'op';
    return `op_${base}_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
  }

  function withCommitOp_(tag, fn) {
    const prev = String(state.commitOpId || '');
    const next = prev || createCommitOpId_(tag);
    state.commitOpId = next;
    try {
      return fn(next);
    } finally {
      state.commitOpId = prev;
    }
  }

  function isEquivalentCardUpdatePayload_(a, b) {
    const aCard = (a && a.card && typeof a.card === 'object') ? a.card : {};
    const bCard = (b && b.card && typeof b.card === 'object') ? b.card : {};
    const numEq_ = (x, y) => {
      const nx = Math.round(Number(x));
      const ny = Math.round(Number(y));
      if (!isFinite(nx) && !isFinite(ny)) return true;
      return nx === ny;
    };
    const strEq_ = (x, y) => String((x === undefined || x === null) ? '' : x) === String((y === undefined || y === null) ? '' : y);
    return (
      strEq_(aCard.id, bCard.id) &&
      strEq_(aCard.taskId, bCard.taskId) &&
      strEq_(aCard.lane, bCard.lane) &&
      numEq_(aCard.start, bCard.start) &&
      numEq_(aCard.end, bCard.end) &&
      numEq_(aCard.len, bCard.len) &&
      strEq_(aCard.memo, bCard.memo)
    );
  }

  function enqueueCommit_(payload) {
    if (!payload || typeof payload !== 'object') return;
    if (!payload.opId) payload.opId = createCommitOpId_('single');
    const action = String(payload.action || '').trim().toLowerCase();
    const cardId = (payload.card && payload.card.id != null) ? String(payload.card.id).trim() : '';
    if (action === 'update' && cardId) {
      let latestPendingIndex = -1;
      for (let i = state.commitQueue.length - 1; i >= 0; i--) {
        const qp = (state.commitQueue[i] && state.commitQueue[i].payload) || null;
        const qAction = String((qp && qp.action) || '').trim().toLowerCase();
        const qCardId = (qp && qp.card && qp.card.id != null) ? String(qp.card.id).trim() : '';
        if (qAction === 'update' && qCardId === cardId) {
          latestPendingIndex = i;
          break;
        }
      }
      const latestPendingPayload = (latestPendingIndex >= 0 && state.commitQueue[latestPendingIndex])
        ? state.commitQueue[latestPendingIndex].payload
        : null;
      const inflightPayload = (state.commitInflight && state.commitInflight.payload) ? state.commitInflight.payload : null;
      const inflightAction = String((inflightPayload && inflightPayload.action) || '').trim().toLowerCase();
      const inflightCardId = (inflightPayload && inflightPayload.card && inflightPayload.card.id != null)
        ? String(inflightPayload.card.id).trim()
        : '';
      const latestPayload = latestPendingPayload || ((inflightAction === 'update' && inflightCardId === cardId) ? inflightPayload : null);
      if (latestPayload && isEquivalentCardUpdatePayload_(latestPayload, payload)) return;
      for (let i = state.commitQueue.length - 1; i >= 0; i--) {
        const qp = (state.commitQueue[i] && state.commitQueue[i].payload) || null;
        const qAction = String((qp && qp.action) || '').trim().toLowerCase();
        const qCardId = (qp && qp.card && qp.card.id != null) ? String(qp.card.id).trim() : '';
        if (qAction === 'update' && qCardId === cardId) {
          state.commitQueue.splice(i, 1);
        }
      }
    }
    state.commitSeq = Math.max(0, Math.round(Number(state.commitSeq) || 0)) + 1;
    state.commitQueue.push({
      seq: state.commitSeq,
      payload: payload,
      attempts: 0,
      enqueuedAt: Date.now()
    });
    flushCommitQueue_();
  }

  function getCommitQueueStats_() {
    const pending = Array.isArray(state.commitQueue) ? state.commitQueue.length : 0;
    const inflight = state.commitInflight ? 1 : 0;
    const retrying = (state.commitInflight && Number(state.commitInflight.attempts || 0) > 0) ? 1 : 0;
    return {
      keys: pending + inflight,
      inflight: inflight,
      pending: pending,
      retrying: retrying
    };
  }

  function isCommitQueueIdle_() {
    const stats = getCommitQueueStats_();
    return (stats.inflight === 0 && stats.pending === 0);
  }

  function waitForCommitQueueIdle_(opts) {
    const cfg = (opts && typeof opts === 'object') ? opts : {};
    const timeoutMs = Math.max(1000, Math.round(Number(cfg.timeoutMs || 60000)));
    const message = String(cfg.message || 'Waiting save queue...');
    const onReady = (typeof cfg.onReady === 'function') ? cfg.onReady : function () {};
    const onTimeout = (typeof cfg.onTimeout === 'function') ? cfg.onTimeout : function () {};
    const start = Date.now();
    const tick_ = () => {
      if (isCommitQueueIdle_()) {
        onReady();
        return;
      }
      const elapsed = Date.now() - start;
      if (elapsed > timeoutMs) {
        onTimeout(getCommitQueueStats_());
        return;
      }
      const q = getCommitQueueStats_();
      setBlockingOverlay_(true, `${message} (${q.inflight + q.pending})`);
      setTimeout(tick_, 70);
    };
    tick_();
  }

  function compactCommitQueueForUndo_() {
    const q = Array.isArray(state.commitQueue) ? state.commitQueue : [];
    if (!q.length) return { before: 0, after: 0 };
    const seen = {};
    const keptRev = [];
    for (let i = q.length - 1; i >= 0; i--) {
      const item = q[i];
      const p = (item && item.payload && typeof item.payload === 'object') ? item.payload : {};
      const cardId = (p.card && p.card.id != null) ? String(p.card.id) : '';
      const key = cardId ? ('card:' + cardId) : ('idx:' + i);
      if (seen[key]) continue;
      seen[key] = true;
      keptRev.push(item);
    }
    keptRev.reverse();
    const before = q.length;
    state.commitQueue = keptRev;
    return { before: before, after: keptRev.length };
  }

  function setBlockingOverlay_(visible, text) {
    const sp = document.getElementById('loadingSpinner');
    const label = document.getElementById('loadingSpinnerText');
    if (label) label.textContent = String(text || 'Loading...');
    if (sp) sp.style.display = visible ? 'flex' : 'none';
  }

  function applyCardsSyncResponse_(res) {
    const list = Array.isArray(res && res.cards) ? res.cards : [];
    const syncedSchedId = String((res && res.schedId) || '').trim();
    if (syncedSchedId) state.schedId = syncedSchedId;
    const lanesById = {};
    (state.lanes || []).forEach((l) => { lanesById[String((l && l.id) || '')] = true; });
    const prevCards = state.cards || {};
    const nextCards = {};
    list.forEach((raw, i) => {
      const row = (raw && typeof raw === 'object') ? raw : {};
      const id = String(row.id || row.cardId || row.cardNo || '').trim() || ('c_' + i);
      const taskId = String(row.taskId || '').trim();
      const task = state.tasksById && state.tasksById[taskId] ? state.tasksById[taskId] : null;
      let laneId = String(row.lane || row.laneVal || '').trim() || (task && task.assignee ? String(task.assignee) : 'unassigned');
      if (!laneId) laneId = 'unassigned';
      if (laneId !== 'unassigned' && !lanesById[laneId]) {
        state.lanes.push({ id: laneId, label: laneId, order: 999, visible: true });
        lanesById[laneId] = true;
      }
      let start = Math.max(1, Math.round(Number(row.start) || 1));
      let end = Math.round(Number(row.end));
      const lenMinRaw = Number(row.len);
      const lenMin = (isFinite(lenMinRaw) && lenMinRaw > 0) ? Math.round(lenMinRaw) : config.slotMin;
      if (!isFinite(end)) {
        const durSlots = Math.max(1, Math.ceil(lenMin / Math.max(1, Number(config.slotMin) || 1)));
        end = start + durSlots - 1;
      }
      if (end < start) end = start;
      nextCards[id] = {
        id: id,
        displayId: utils.getDisplayId(id),
        taskId: taskId,
        title: (task && task.name) ? String(task.name) : 'Card',
        laneId: laneId,
        start: start,
        end: end,
        memo: String(row.memo || ''),
        status: (task && task.status) ? String(task.status) : '',
        cardMeta: (prevCards[id] && prevCards[id].cardMeta) ? prevCards[id].cardMeta : {}
      };
    });
    state.cards = nextCards;
    const selectedId = String(state.selection || '');
    if (selectedId && !state.cards[selectedId]) state.selection = null;
    state.multiSelection = normalizeCardIds_(state.multiSelection || []).filter((id) => !!state.cards[id]);
    if (state.multiAnchorCardId && !state.cards[String(state.multiAnchorCardId)]) state.multiAnchorCardId = state.multiSelection[0] || '';
    warnLegacySlotOffsetOnce_();
    refreshAssetUsageState_();
    render.all();
    ui.refreshInspectorValuesFromCard();
    queueAssetInspectorRefresh_();
  }

  function reloadCardsOnlyAfterUndo_(onDone) {
    const done = (typeof onDone === 'function') ? onDone : function () {};
    google.script.run
      .withSuccessHandler((str) => {
        let res = null;
        try { res = JSON.parse(str); } catch (e) { res = { ok: false, error: String(e) }; }
        if (res && res.ok && Array.isArray(res.cards)) {
          applyCardsSyncResponse_(res);
          done(true);
          return;
        }
        actions.load({ forceNetwork: true, onDone: () => done(false) });
      })
      .withFailureHandler(() => {
        actions.load({ forceNetwork: true, onDone: () => done(false) });
      })
      .sv_scheduler_cards_sync_v1(JSON.stringify({ schedId: String(state.schedId || '') }));
  }

  function executeUndoRequest_(rpcMethod, payload, afterSuccess) {
    if (state.undoBusy) return;
    clearInspectorTimers_();
    const compacted = compactCommitQueueForUndo_();
    if (compacted.before > compacted.after) {
      console.info('[MOTK][Scheduler][Undo] compacted pending queue before wait', compacted);
    }
    dropPendingCommitQueue_('undo_request');
    if (state.inspEdit) {
      state.inspEdit.isEditingStart = false;
      state.inspEdit.isEditingEnd = false;
      state.inspEdit.isTypingStartDate = false;
      state.inspEdit.isTypingEndDate = false;
      state.inspEdit.isTyping = false;
    }
    try {
      const ae = document.activeElement;
      if (ae && typeof ae.blur === 'function') ae.blur();
    } catch (_) {}
    state.undoBusy = true;
    state.undoPhase = 'waiting_queue';
    renderUndoModalList_();
    const beginTs = Date.now();
    const startUndoRpc_ = () => {
      state.undoPhase = 'rpc';
      setBlockingOverlay_(true, 'Undo...');
      utils.saveStatus('saving', 'Undo...');
      const runner = google.script.run
        .withSuccessHandler((str) => {
          let res = null;
          try { res = JSON.parse(str); } catch (e) { res = { ok: false, error: String(e) }; }
          if (res && res.ok) {
            const undoneCount = Math.max(1, Math.round(Number(res.undoneCount || 1)));
            const msg = undoneCount > 1 ? ('Undone Ã—' + undoneCount) : 'Undone';
            utils.saveStatus('saved', msg);
            console.info('[MOTK][Scheduler][Undo] applied', {
              undoneCount: undoneCount,
              undoneLogIds: Array.isArray(res.undoneLogIds) ? res.undoneLogIds : [],
              undoneGroupCount: Number(res.undoneGroupCount || 1)
            });
            reloadCardsOnlyAfterUndo_(() => {
              state.undoBusy = false;
              state.undoPhase = '';
              setBlockingOverlay_(false);
              if (typeof afterSuccess === 'function') {
                try { afterSuccess(res); } catch (_) {}
              }
              flushCommitQueue_();
              renderUndoModalList_();
            });
            return;
          }
          const msg = (res && (res.error || (res.result && res.result.error))) ? String(res.error || res.result.error) : 'Undo failed';
          console.warn('[MOTK][Scheduler][Undo] failed', { response: res });
          utils.saveStatus('error', msg);
          state.undoBusy = false;
          state.undoPhase = '';
          setBlockingOverlay_(false);
          flushCommitQueue_();
          renderUndoModalList_();
        })
        .withFailureHandler((err) => {
          console.error('[MOTK][Scheduler][Undo] network failure', err);
          utils.saveStatus('error', String(err && (err.message || err) || 'Undo failed'));
          state.undoBusy = false;
          state.undoPhase = '';
          setBlockingOverlay_(false);
          flushCommitQueue_();
          renderUndoModalList_();
        });
      const payloadStr = JSON.stringify(payload || { scope: 'scheduler' });
      if (rpcMethod === 'sv_undo_to_v2') runner.sv_undo_to_v2(payloadStr);
      else runner.sv_undo_last_v2(payloadStr);
    };
    const waitQueueAndUndo_ = () => {
      if (isCommitQueueIdle_()) {
        startUndoRpc_();
        return;
      }
      const elapsed = Date.now() - beginTs;
      if (elapsed > 60000) {
        const q = getCommitQueueStats_();
        console.warn('[MOTK][Scheduler][Undo] commit queue timeout', q);
        utils.saveStatus('error', 'Undo timeout (save queue busy)');
        state.undoBusy = false;
        state.undoPhase = '';
        setBlockingOverlay_(false);
        renderUndoModalList_();
        return;
      }
      const q = getCommitQueueStats_();
      setBlockingOverlay_(true, 'Waiting save queue... (' + (q.inflight + q.pending) + ')');
      setTimeout(waitQueueAndUndo_, 60);
    };
    waitQueueAndUndo_();
  }

  function executeSnapshotRequest_(opts = {}) {
    const options = (opts && typeof opts === 'object') ? opts : {};
    const isAuto = !!options.auto;
    const onDone = (typeof options.onDone === 'function') ? options.onDone : null;
    if (state.undoBusy || state.snapBusy) return;
    state.snapBusy = true;
    state.snapPhase = 'waiting_queue';
    state.lastSnapshotAttemptAtMs = Date.now();
    state.autoSnapPending = false;
    const beginTs = Date.now();
    const waitTimeoutMs = isAuto ? 6000 : 20000;
    const finish_ = (ok, msg) => {
      state.snapBusy = false;
      state.snapPhase = '';
      if (ok) markSnapshotTs_(options.snapshotTs || '');
      if (msg) {
        if (isAuto) {
          if (ok) utils.saveStatus('saved', msg);
        } else {
          utils.saveStatus(ok ? 'saved' : 'error', msg);
        }
      }
      if (onDone) {
        try { onDone(ok); } catch (_) {}
      }
      flushCommitQueue_();
    };
    const runSnapshotRpc_ = () => {
      state.snapPhase = 'rpc';
      if (!isAuto) utils.saveStatus('saving', 'SNAP...');
      google.script.run
        .withSuccessHandler((str) => {
          let res = null;
          try { res = JSON.parse(str); } catch (e) { res = { ok: false, error: String(e) }; }
          if (res && res.ok) {
            options.snapshotTs = String((res && res.ts) || '');
            finish_(true, isAuto ? 'Auto SNAP saved' : 'SNAP Saved');
            return;
          }
          finish_(false, isAuto ? 'Auto SNAP failed' : String((res && res.error) || 'SNAP failed'));
        })
        .withFailureHandler((err) => {
          finish_(false, isAuto ? 'Auto SNAP failed' : String(err && (err.message || err) || 'SNAP failed'));
        })
        .sv_scheduler_snapshot_create_v1(JSON.stringify({
          scope: 'scheduler',
          name: isAuto ? '' : String(options.name || '').trim()
        }));
    };
    const waitQueueAndRun_ = () => {
      if (isCommitQueueIdle_()) {
        runSnapshotRpc_();
        return;
      }
      if (isAuto) {
        finish_(false, '');
        return;
      }
      const elapsed = Date.now() - beginTs;
      if (elapsed > waitTimeoutMs) {
        finish_(false, isAuto ? 'Auto SNAP skipped (save queue busy)' : 'SNAP timeout (save queue busy)');
        return;
      }
      setTimeout(waitQueueAndRun_, 60);
    };
    waitQueueAndRun_();
  }

  function executeSnapshotRestoreRequest_(snapshotItem) {
    const item = (snapshotItem && typeof snapshotItem === 'object') ? snapshotItem : null;
    const logId = String((item && item.logId) || '').trim();
    if (!logId || state.undoBusy) return;
    dropPendingCommitQueue_('snapshot_restore');
    state.undoBusy = true;
    state.undoPhase = 'waiting_queue';
    renderUndoModalList_();
    const beginTs = Date.now();
    const startRestoreRpc_ = () => {
      state.undoPhase = 'rpc';
      setBlockingOverlay_(true, 'Restoring SNAP...');
      utils.saveStatus('saving', 'Restoring SNAP...');
      google.script.run
        .withSuccessHandler((str) => {
          let res = null;
          try { res = JSON.parse(str); } catch (e) { res = { ok: false, error: String(e) }; }
          if (res && res.ok) {
            utils.saveStatus('saved', 'SNAP Restored');
            reloadCardsOnlyAfterUndo_(() => {
              state.undoBusy = false;
              state.undoPhase = '';
              setBlockingOverlay_(false);
              actions.loadUndoOptions();
              flushCommitQueue_();
              renderUndoModalList_();
            });
            return;
          }
          const msg = String((res && res.error) || 'SNAP restore failed');
          utils.saveStatus('error', msg);
          state.undoBusy = false;
          state.undoPhase = '';
          setBlockingOverlay_(false);
          flushCommitQueue_();
          renderUndoModalList_();
        })
        .withFailureHandler((err) => {
          utils.saveStatus('error', String(err && (err.message || err) || 'SNAP restore failed'));
          state.undoBusy = false;
          state.undoPhase = '';
          setBlockingOverlay_(false);
          flushCommitQueue_();
          renderUndoModalList_();
        })
        .sv_scheduler_snapshot_restore_v1(JSON.stringify({ logId: logId, scope: 'scheduler' }));
    };
    const waitQueueAndRestore_ = () => {
      if (isCommitQueueIdle_()) {
        startRestoreRpc_();
        return;
      }
      const elapsed = Date.now() - beginTs;
      if (elapsed > 60000) {
        utils.saveStatus('error', 'SNAP restore timeout (save queue busy)');
        state.undoBusy = false;
        state.undoPhase = '';
        setBlockingOverlay_(false);
        renderUndoModalList_();
        return;
      }
      const q = getCommitQueueStats_();
      setBlockingOverlay_(true, 'Waiting save queue... (' + (q.inflight + q.pending) + ')');
      setTimeout(waitQueueAndRestore_, 60);
    };
    waitQueueAndRestore_();
  }

  function maybeAutoSnapshotByEdit_() {
    if (state.undoBusy || state.snapBusy || state.autoSnapPending) return;
    if (!isCommitQueueIdle_()) return;
    const lastTs = Math.max(
      Number(state.lastSnapshotAtMs || 0),
      Number(state.lastSnapshotAttemptAtMs || 0)
    );
    const threshold = Math.max(60 * 1000, Number(state.autoSnapThresholdMs || 0));
    const elapsed = Date.now() - lastTs;
    if (!isFinite(elapsed) || elapsed < threshold) return;
    state.autoSnapPending = true;
    executeSnapshotRequest_({ auto: true });
  }

  const actions = {
    openUndoModal: () => {
      if (state.undoBusy) return;
      closeToolbarMenus_();
      setUndoModalOpen_(true);
      actions.loadUndoOptions();
    },
    closeUndoModal: () => {
      if (state.undoBusy) return;
      setUndoModalOpen_(false);
    },
    loadUndoOptions: () => {
      state.undoLoading = true;
      state.undoLoadError = '';
      renderUndoModalList_();
      google.script.run
        .withSuccessHandler((str) => {
          let res = null;
          try { res = JSON.parse(str); } catch (e) { res = { ok: false, error: String(e) }; }
          if (!(res && res.ok)) {
            state.undoOptions = [];
            state.undoSelectedKey = '';
            state.undoLoadError = String((res && res.error) || 'Failed to load undo history');
            state.undoLoading = false;
            renderUndoModalList_();
            return;
          }
          const items = Array.isArray(res.items) ? res.items : [];
          state.undoOptions = items;
          const firstSnap = items.find((it) => String((it && it.kind) || '').toLowerCase() === 'snapshot');
          if (firstSnap && firstSnap.ts) markSnapshotTs_(firstSnap.ts);
          const selectedExists = !!items.find((it) => String((it && it.undoKey) || '') === String(state.undoSelectedKey || ''));
          state.undoSelectedKey = selectedExists ? String(state.undoSelectedKey || '') : String(((items[0] && items[0].undoKey) || ''));
          state.undoLoadError = '';
          state.undoLoading = false;
          renderUndoModalList_();
        })
        .withFailureHandler((err) => {
          state.undoOptions = [];
          state.undoSelectedKey = '';
          state.undoLoadError = String(err && (err.message || err) || 'Failed to load undo history');
          state.undoLoading = false;
          renderUndoModalList_();
        })
        .sv_undo_options_v2(JSON.stringify({ scope: 'scheduler', limit: 100 }));
    },
    undoToSelected: () => {
      const undoKey = String(state.undoSelectedKey || '').trim();
      if (!undoKey || state.undoBusy || state.undoLoading) return;
      const selected = (Array.isArray(state.undoOptions) ? state.undoOptions : []).find((it) => String((it && it.undoKey) || '') === undoKey) || null;
      const kind = String((selected && selected.kind) || '').trim().toLowerCase();
      if (kind === 'snapshot') {
        executeSnapshotRestoreRequest_(selected);
        return;
      }
      utils.saveStatus('error', 'Only SNAP items are restorable here');
    },
    takeSnapshotFromUndoMenu: () => {
      if (state.undoBusy || state.snapBusy || state.undoLoading) return;
      const name = prompt('Snapshot name (required):', '');
      if (name === null) return;
      const trimmed = String(name || '').trim();
      if (!trimmed) {
        utils.saveStatus('error', 'Snapshot name is required');
        return;
      }
      executeSnapshotRequest_({
        auto: false,
        name: trimmed,
        onDone: () => actions.loadUndoOptions()
      });
    },
    renameSelectedSnapshot: () => {
      if (state.undoBusy || state.undoLoading) return;
      const undoKey = String(state.undoSelectedKey || '').trim();
      const selected = (Array.isArray(state.undoOptions) ? state.undoOptions : []).find((it) => String((it && it.undoKey) || '') === undoKey) || null;
      if (!selected || String(selected.kind || '').toLowerCase() !== 'snapshot') return;
      const logId = String(selected.logId || '').trim();
      if (!logId) return;
      const currentName = String(selected.snapshotName || '').trim();
      const nextName = prompt('Snapshot name (empty = rolling 5):', currentName);
      if (nextName === null) return;
      google.script.run
        .withSuccessHandler((str) => {
          let res = null;
          try { res = JSON.parse(str); } catch (e) { res = { ok: false, error: String(e) }; }
          if (res && res.ok) {
            utils.saveStatus('saved', 'SNAP name saved');
            actions.loadUndoOptions();
            return;
          }
          utils.saveStatus('error', String((res && res.error) || 'SNAP rename failed'));
        })
        .withFailureHandler((err) => {
          utils.saveStatus('error', String(err && (err.message || err) || 'SNAP rename failed'));
        })
        .sv_scheduler_snapshot_rename_v1(JSON.stringify({ logId: logId, name: String(nextName || '') }));
    },
    renameSched: (nextName) => {
      const fromInput = (nextName !== undefined && nextName !== null) ? String(nextName).trim() : '';
      const newName = fromInput || prompt('Rename Schedule:', state.schedName);
      if (!newName || newName === state.schedName) return;
      state.schedName = newName;
      const renameInput = document.getElementById('sched-rename-input');
      if (renameInput && document.activeElement !== renameInput) renameInput.value = state.schedName;
      if (Array.isArray(state.allScheds)) {
        state.allScheds = state.allScheds.map((s) => (String(s.id) === String(state.schedId)) ? Object.assign({}, s, { name: newName }) : s);
        const sel = document.getElementById('sched-switch');
        if (sel) {
          const opt = Array.from(sel.options || []).find((o) => String(o.value) === String(state.schedId));
          if (opt) opt.textContent = newName;
        }
      }
      google.script.run.sv_scheduler_rename_sched(JSON.stringify({
        schedId: state.schedId,
        name: newName
      }));
    },
    renameSchedFromSettings: () => {
      const input = document.getElementById('sched-rename-input');
      if (!input) return;
      actions.renameSched(input.value);
    },
    switchSched: (id) => {
      if (!id || String(id) === String(state.schedId)) return;
      google.script.run
        .withSuccessHandler(() => { actions.load(); })
        .sv_scheduler_switch_active(id);
    },
    load: (opts) => {
      opts = opts || {};
      const silentStatus = !!opts.silentStatus;
      const onDone = (typeof opts.onDone === 'function') ? opts.onDone : null;
      let doneCalled = false;
      const done_ = () => {
        if (doneCalled) return;
        doneCalled = true;
        if (onDone) {
          try { onDone(); } catch (_) {}
        }
      };
      if (!silentStatus) utils.saveStatus('saving', 'Loading...');
      const sp = document.getElementById('loadingSpinner');
      if (sp) sp.style.display='flex';

      const t0 = Date.now();
      const diag = {
        ts: t0,
        usedCache: false,
        cacheAgeMs: null,
        t_cache_render_end: null,
        netMs: null,
        totalMs: null,
        ok: false,
        error: null,
        payloadBytesApprox: null
      };

      let cacheUsed = false;
      const shouldBypassCache = !!(opts.forceNetwork || (state.requestedSchedId && !state.requestedSchedApplied));
      if (!shouldBypassCache) {
        try {
          const raw = localStorage.getItem(SCHED_CACHE_KEY);
          const rawTs = localStorage.getItem(SCHED_CACHE_TS_KEY);
          const ts = Number(rawTs);
          if (raw && isFinite(ts)) {
            diag.cacheAgeMs = t0 - ts;
            if (diag.cacheAgeMs >= 0 && diag.cacheAgeMs <= SCHED_CACHE_MAX_AGE_MS) {
              const cached = JSON.parse(raw);
              store.init(cached);
              cacheUsed = true;
              diag.usedCache = true;
              diag.t_cache_render_end = Date.now();
              if (!silentStatus) {
                if (state.timezoneBlocked) utils.saveStatus('error', 'Timezone is not configured');
                else utils.saveStatus('saved', 'Loaded');
              }
              if (sp) sp.style.display='none';
            }
          }
        } catch (e) {
          console.error('scheduler cache parse error', e);
        }
      }
      const tNetStart = Date.now();
      google.script.run
        .withSuccessHandler(str => {
          const tNetEnd = Date.now();
          diag.netMs = tNetEnd - tNetStart;
          diag.totalMs = tNetEnd - t0;
          diag.payloadBytesApprox = str ? String(str).length : 0;
          if (!cacheUsed && sp) sp.style.display='none';
          let res;
          try { res = JSON.parse(str); } catch(e){ console.error(e); }
          if (res && res.ok) {
            var requested = String(state.requestedSchedId || '').trim();
            if (requested && !state.requestedSchedApplied) {
              var active = String((res.schedConfig && res.schedConfig.activeSchedId) || '').trim();
              var list = (res.schedConfig && Array.isArray(res.schedConfig.allScheds)) ? res.schedConfig.allScheds : [];
              var exists = !list.length || list.some(function (s) {
                return String((s && s.id) || '').trim() === requested;
              });
              if (exists && active && active !== requested) {
                state.requestedSchedApplied = true;
                google.script.run
                  .withSuccessHandler(function () { actions.load(opts); })
                  .withFailureHandler(function (err) {
                    const msg = 'Requested schedule switch failed';
                    console.error('[MOTK][Scheduler] ' + msg, { requested: requested, err: err });
                    if (!cacheUsed && sp) sp.style.display = 'none';
                    diag.ok = false;
                    diag.error = msg;
                    if (!cacheUsed) utils.saveStatus('error', msg);
                    try { sessionStorage.setItem(SCHED_LOAD_DIAG_KEY, JSON.stringify(diag, null, 2)); } catch (_) { }
                    done_();
                  })
                  .sv_scheduler_switch_active(requested);
                return;
              }
              state.requestedSchedApplied = true;
            }
            store.init(res);
            diag.ok = true;
            if (!silentStatus) {
              if (state.timezoneBlocked) utils.saveStatus('error', 'Timezone is not configured');
              else utils.saveStatus('saved', 'Loaded');
            }
            try {
              localStorage.setItem(SCHED_CACHE_KEY, JSON.stringify(res));
              localStorage.setItem(SCHED_CACHE_TS_KEY, String(Date.now()));
            } catch (_) { }
          } else {
            diag.ok = false;
            diag.error = (res && res.error) ? (res.error.message || res.error) : 'Load Failed';
            if (!cacheUsed) {
              utils.saveStatus('error', diag.error);
            } else {
              if (!silentStatus) utils.saveStatus('saved', 'Loaded');
            }
          }
          try { sessionStorage.setItem(SCHED_LOAD_DIAG_KEY, JSON.stringify(diag, null, 2)); } catch (_) { }
          done_();
        })
        .withFailureHandler(e => {
          const tNetEnd = Date.now();
          diag.netMs = tNetEnd - tNetStart;
          diag.totalMs = tNetEnd - t0;
          diag.ok = false;
          diag.error = String(e && (e.message || e));
          if (!cacheUsed && sp) sp.style.display='none';
          if (!cacheUsed) {
            utils.saveStatus('error', diag.error);
          } else {
            if (!silentStatus) utils.saveStatus('saved', 'Loaded');
          }
          try { sessionStorage.setItem(SCHED_LOAD_DIAG_KEY, JSON.stringify(diag, null, 2)); } catch (_) { }
          done_();
        })
        .sv_scheduler_load_v2();
    },

    undoLast: () => executeUndoRequest_('sv_undo_last_v2', { scope: 'scheduler' }),
    publish: () => {
      if (state.undoBusy || state.snapBusy || state.publishBusy) return;
      if (!confirm('Publish current schedule to Tasks?\n\nThis updates Assigned member / Start Date / End Date / task Order.\nCompleted tasks are skipped.')) return;
      state.publishBusy = true;
      state.publishPhase = 'waiting_queue';
      const btn = document.getElementById('btn-publish');
      if (btn) btn.disabled = true;
      utils.saveStatus('saving', 'Publishing...');
      waitForCommitQueueIdle_({
        timeoutMs: 120000,
        message: 'Waiting save queue...',
        onReady: () => {
          state.publishPhase = 'rpc';
          setBlockingOverlay_(true, 'Publishing...');
          const cards = Object.values(state.cards || {}).map((c) => ({
            id: String(c && c.id || ''),
            cardId: String(c && c.id || ''),
            taskId: String(c && c.taskId || ''),
            lane: String(c && c.laneId || ''),
            laneVal: String(c && c.laneId || ''),
            start: Number(c && c.start || 0),
            end: Number(c && c.end || 0),
            startSlot: Number(c && c.start || 0),
            endSlot: Number(c && c.end || 0),
            startDate: (utils.slotToDateVal(Number(c && c.start || 1), 'start') || {}).dateVal || '',
            endDate: (utils.slotToDateVal(Number(c && c.end || 1), 'end') || {}).dateVal || ''
          }));
          const finish_ = (statusType, msg) => {
            utils.saveStatus(statusType, msg);
            state.publishBusy = false;
            state.publishPhase = '';
            if (btn) btn.disabled = false;
            setBlockingOverlay_(false);
          };
          const runPublishRpc_ = (attempt) => {
            google.script.run
              .withSuccessHandler((resRaw) => {
                let res = resRaw;
                if (typeof resRaw === 'string') {
                  try { res = JSON.parse(resRaw); } catch (_) { res = { ok: false, error: 'Invalid publish response' }; }
                }
                if (res && res.ok) {
                  const updated = Number(res.updated || 0);
                  const skipped = Number(res.skipped || 0);
                  const completed = Number(res.skippedCompleted || 0);
                  const missing = Number(res.skippedMissing || 0);
                  const invalid = Number(res.skippedInvalid || 0);
                  const unchanged = Number(res.skippedNoChange || 0);
                  const msg = `Publish done: updated ${updated} / skipped ${skipped} (completed ${completed}, missing ${missing}, invalid ${invalid}, unchanged ${unchanged})`;
                  finish_('saved', msg);
                  actions.load({
                    forceNetwork: true,
                    silentStatus: true,
                    onDone: () => {
                      utils.saveStatus('saved', msg);
                    }
                  });
                  return;
                }
                const errMsg = String((res && (res.error || res.details)) || 'Publish failed');
                if (attempt < 2) {
                  utils.saveStatus('saving', `Publishing retry ${attempt + 2}/3...`);
                  setTimeout(() => runPublishRpc_(attempt + 1), 400 * (attempt + 1));
                  return;
                }
                finish_('error', errMsg);
              })
              .withFailureHandler((err) => {
                if (attempt < 2) {
                  utils.saveStatus('saving', `Publishing retry ${attempt + 2}/3...`);
                  setTimeout(() => runPublishRpc_(attempt + 1), 400 * (attempt + 1));
                  return;
                }
                finish_('error', String(err && (err.message || err) || 'Publish failed'));
              })
              .sv_schedule_publish_v1({
                schedId: String(state.schedId || ''),
                viewSlotMin: Number(config.slotMin || 30),
                cards: cards
              });
          };
          runPublishRpc_(0);
        },
        onTimeout: () => {
          utils.saveStatus('error', 'Publish timeout (save queue busy)');
          state.publishBusy = false;
          state.publishPhase = '';
          if (btn) btn.disabled = false;
          setBlockingOverlay_(false);
        }
      });
    },
    openSchedIndex: () => {
      try {
        const base = String(state.scriptUrlServer || state.scriptUrl || (location.origin + location.pathname));
        const href = String(base).replace(/\?.*$/, '') + '?p=table&e=scheds';
        (window.top || window).location.href = href;
      } catch (_) {}
    },
    commit: (id, type, opts = {}) => {
      if (state.undoBusy) {
        utils.saveStatus('saving', 'Undo in progress...');
        return;
      }
      maybeAutoSnapshotByEdit_();
      const c = state.cards[id];
      if (!c && type !== 'delete') return;
      const opId = String((opts && opts.opId) || state.commitOpId || createCommitOpId_('single'));
      const payload = {
        action: type,
        opId: opId,
        card: {
          id: id,
          taskId: c ? c.taskId : '',
          lane: c ? c.laneId : '',
          start: c ? c.start : 1,
          end: c ? c.end : 1,
          len: c ? (Math.max(1, (c.end - c.start + 1)) * config.slotMin) : 0,
          memo: c ? c.memo : ''
        }
      };
      enqueueCommit_(payload);
      queueAssetInspectorRefresh_();
    },

    clearAssetCellSelection: (opts = {}) => {
      if (!state.assetCellSelection) return;
      state.assetCellSelection = null;
      state.dragPreview = null;
      if (opts && opts.skipRender) return;
      render.grid();
      ui.renderInspector();
    },

    clearGapSelection: () => {
      if (!state.gapSelection) return;
      state.gapSelection = null;
      state.dragPreview = null;
      state.assetCellSelection = null;
      render.grid();
      ui.renderInspector();
    },

    selectAssetCell: (selection) => {
      if (!selection || !isFinite(Number(selection.rawStart)) || !isFinite(Number(selection.rawEnd))) {
        actions.clearAssetCellSelection();
        return;
      }
      state.selection = null;
      state.gapSelection = null;
      state.multiSelection = [];
      state.multiAnchorCardId = null;
      state.assetCellSelection = {
        dateVal: String(selection.dateVal || ''),
        rawStart: Math.max(1, Math.round(Number(selection.rawStart))),
        rawEnd: Math.max(1, Math.round(Number(selection.rawEnd))),
        resolutionLabel: String(selection.resolutionLabel || ''),
        rows: Array.isArray(selection.rows) ? selection.rows : []
      };
      render.grid();
      ui.renderInspector();
      ui.switchTab('edit');
      setInspectorClosed_(false);
    },

    selectGap: (gap) => {
      if (!gap || !gap.laneId || !isFinite(Number(gap.fromSlot)) || !isFinite(Number(gap.toSlot))) {
        actions.clearGapSelection();
        return;
      }
      try {
        var ae = document.activeElement;
        if (ae && typeof ae.blur === 'function') {
          var tag = String(ae.tagName || '').toLowerCase();
          if (tag === 'input' || tag === 'textarea' || tag === 'select' || ae.isContentEditable) ae.blur();
        }
      } catch (_) {}
      state.selection = null;
      state.assetCellSelection = null;
      state.multiSelection = [];
      state.multiAnchorCardId = null;
      state.gapSelection = {
        laneId: String(gap.laneId),
        fromSlot: Math.max(1, Math.round(Number(gap.fromSlot))),
        toSlot: Math.max(1, Math.round(Number(gap.toSlot))),
        sizeSlots: Math.max(0, Math.round(Number(gap.sizeSlots || 0))),
        prevCardId: String(gap.prevCardId || ''),
        nextCardId: String(gap.nextCardId || '')
      };
      render.grid();
      ui.renderInspector();
      requestAnimationFrame(() => focusSelectedGapHitbox_());
    },

    closeSelectedGap: () => {
      const g = state.gapSelection;
      if (!g || !g.laneId) return;
      const shift = Math.max(0, Math.round(Number(g.sizeSlots || 0)));
      if (shift <= 0) {
        actions.clearGapSelection();
        return;
      }
      const targets = Object.values(state.cards || {})
        .filter((c) => String(c && c.laneId || '') === String(g.laneId) && isFinite(Number(c && c.start)) && Number(c.start) >= Number(g.fromSlot))
        .sort((a, b) => Number(a.start) - Number(b.start));
      if (!targets.length) {
        actions.clearGapSelection();
        return;
      }
      withCommitOp_('close_gap', () => {
        targets.forEach((c) => {
          const oldStart = Math.round(Number(c.start));
          const oldEnd = Math.round(Number(c.end));
          const nextStart = Math.max(1, oldStart - shift);
          const nextEnd = Math.max(nextStart, oldEnd - shift);
          if (nextStart === oldStart && nextEnd === oldEnd) return;
          c.start = nextStart;
          c.end = nextEnd;
          actions.commit(c.id, 'update');
        });
      });
      state.gapSelection = null;
      render.grid();
      ui.renderCardList();
      ui.refreshInspectorValuesFromCard();
      utils.saveStatus('saved', 'Gap closed');
    },

    clearMultiSelection: () => {
      if (!state.multiSelection || !state.multiSelection.length) return;
      state.multiSelection = [];
      state.multiAnchorCardId = null;
      render.grid();
      ui.renderCardList();
    },

    toggleMultiSelection: (id, opts = {}) => {
      const key = String(id || '').trim();
      if (!key || !state.cards[key]) return;
      const laneId = String((state.cards[key] && state.cards[key].laneId) || '').trim();
      const hasExplicitChecked = Object.prototype.hasOwnProperty.call(opts || {}, 'checked');
      const explicitChecked = hasExplicitChecked ? !!opts.checked : null;
      const keepContiguous = opts.contiguous !== false;
      const shiftKey = !!opts.shiftKey;
      const anchorId = String(state.multiAnchorCardId || state.selection || key).trim();
      let next = [];
      if (hasExplicitChecked) {
        next = normalizeCardIds_(state.multiSelection || []);
        const idx = next.indexOf(key);
        if (explicitChecked && idx < 0) next.push(key);
        if (!explicitChecked && idx >= 0) next.splice(idx, 1);
        state.multiSelection = normalizeCardIds_(next);
      } else {
        if (keepContiguous) {
          next = buildLaneRangeSelection_(anchorId, key);
        }
        if (!next.length) {
          toggleMultiSelection_(key);
          next = normalizeCardIds_(state.multiSelection || []);
        } else {
          state.multiSelection = normalizeCardIds_(next);
        }
      }
      // Multi-selection is lane-scoped to prevent cross-lane partial block moves.
      state.multiSelection = keepOnlyLaneSelection_(state.multiSelection || [], laneId);
      if (!state.multiSelection.length) {
        state.multiAnchorCardId = null;
      } else if (!state.multiAnchorCardId || !state.cards[state.multiAnchorCardId]) {
        state.multiAnchorCardId = key;
      } else if (hasExplicitChecked && explicitChecked) {
        state.multiAnchorCardId = key;
      } else if (!shiftKey && keepContiguous) {
        state.multiAnchorCardId = anchorId || key;
      }
      if (!state.multiSelection.length) {
        state.selection = key;
      } else if (hasExplicitChecked && explicitChecked) {
        state.selection = key;
      } else if (state.multiSelection.indexOf(String(state.selection || '')) < 0) {
        state.selection = key;
      }
      render.grid();
      ui.renderCardList();
      ui.renderInspector();
    },

    selectCard: (id, opts = {}) => {
      const key = String(id);
      if (!state.cards[key]) return;
      if (opts && opts.clearMulti) {
        state.multiSelection = [];
        state.multiAnchorCardId = null;
      }
      state.gapSelection = null;
      state.assetCellSelection = null;
      if (String(state.selection || '') !== key) clearInspectorTimers_();
      state.selection = key;
      render.grid();
      ui.renderInspector();
      if (opts && opts.focus === false) return;
      requestAnimationFrame(() => actions.focusSelected());
    },

    focusSelected: () => {
      const edit = state.inspEdit;
      if (edit && edit.isTyping) return;
      const id = String(state.selection || '');
      if (!id) return;
      const esc = id.replace(/\"/g, '\\\"');
      const cardEl = els.canvas ? els.canvas.querySelector(`[data-card-id=\"${esc}\"]`) : null;
      if (!cardEl) return;
      cardEl.scrollIntoView({ block: 'center', inline: 'center', behavior: 'auto' });
    },

    setZoomFromSlider: (v) => {
      state.slotPx = utils.calcSlotPx(v);
      const inp = document.getElementById('inp-zoom-val');
      if (inp) inp.value = state.slotPx;
      render.grid();
      markViewDirty_();
    },

    setZoomFromInput: (v) => {
      state.slotPx = utils.calcSlotPx(v);
      const slider = document.getElementById('inp-zoom');
      if (slider) slider.value = state.slotPx;
      render.grid();
      markViewDirty_();
    },

    fitZoomToView: () => {
      store.calcDays();
      const rows = Math.max(1, state.workDayMap.length);
      const slotsPerDay = Math.max(1, getSlotsPerDay_());
      const gs = els.gridScroll || document.getElementById('grid-scroll');
      if (!gs) return;
      const viewportH = Math.max(1, gs.clientHeight || 1);
      const fit = Math.floor(viewportH / (rows * slotsPerDay));
      state.slotPx = utils.calcSlotPx(Math.max(1, fit));
      const slider = document.getElementById('inp-zoom');
      if (slider) slider.value = state.slotPx;
      const inp = document.getElementById('inp-zoom-val');
      if (inp) inp.value = state.slotPx;
      render.grid();
      markViewDirty_();
    },

    setStartPreset: (preset) => {
      const normalized = normalizePresetKey_(preset);
      state.startPreset = normalized;
      if (normalized === 'custom') {
        markViewDirty_();
        return;
      }
      const d = resolveDatePreset_(normalized);
      if (!d) return;
      state.startDate = d;
      if (state.viewDriver === 'end' && state.endDate) {
        state.dayCount = computeDayCountByStartEnd_(state.startDate, state.endDate);
      } else {
        syncEndFromRange_();
      }
      store.calcDays();
      store.updateStartDateInput();
      store.updateEndDateInput();
      const rangeSel = document.getElementById('sel-range');
      if (rangeSel) {
        var opts = getRangeOptions_().map(function(n){ return String(n); });
        rangeSel.value = opts.indexOf(String(state.dayCount)) >= 0 ? String(state.dayCount) : 'custom';
      }
      render.grid();
      markViewDirty_();
    },

    setEndPreset: (preset) => {
      const normalized = normalizePresetKey_(preset);
      state.endPreset = normalized;
      if (normalized === 'custom') {
        markViewDirty_();
        return;
      }
      const d = resolveDatePreset_(normalized);
      if (!d) return;
      state.endDate = d;
      state.viewDriver = 'end';
      state.dayCount = computeDayCountByStartEnd_(state.startDate, state.endDate);
      store.calcDays();
      store.updateEndDateInput();
      const rangeSel = document.getElementById('sel-range');
      if (rangeSel) {
        var opts = getRangeOptions_().map(function(n){ return String(n); });
        rangeSel.value = opts.indexOf(String(state.dayCount)) >= 0 ? String(state.dayCount) : 'custom';
      }
      render.grid();
      markViewDirty_();
    },

    setDuration: (mode) => {
      var n = parseInt(mode, 10);
      if (!isFinite(n) || n <= 0) return;
      state.dayCount = n;
      state.viewDriver = 'range';
      state.endPreset = 'custom';
      syncEndFromRange_();
      store.calcDays();
      store.updateEndDateInput();
      render.grid();
      markViewDirty_();
    },

    setCardDisplayField: (slotType, fieldKey) => {
      var fallback = 'task_name';
      if (slotType === 'main') fallback = 'shot_code';
      else if (slotType === 'taskless_main') fallback = 'card_memo';
      else if (slotType === 'taskless_sub') fallback = 'card_length';
      var normalized = normalizeCardDisplayField_(fieldKey, fallback);
      if (slotType === 'main') state.cardDisplayMain = normalized;
      else if (slotType === 'sub') state.cardDisplaySub = normalized;
      else if (slotType === 'taskless_main') state.tasklessDisplayMain = normalized;
      else if (slotType === 'taskless_sub') state.tasklessDisplaySub = normalized;
      else return;
      render.grid();
      ui.renderCardList();
      markViewDirty_();
    },

    addCardDisplayFieldFromSettings: () => {
      const addSel = document.getElementById('sel-card-add-field');
      const targetSel = document.getElementById('sel-card-add-target');
      if (!addSel) return;
      const normalized = normalizeCardDisplayField_(addSel.value, '');
      if (!normalized) return;
      if (!Array.isArray(state.customCardDisplayFields)) state.customCardDisplayFields = [];
      if (state.customCardDisplayFields.indexOf(normalized) < 0) state.customCardDisplayFields.push(normalized);
      const target = String(targetSel && targetSel.value || 'main').toLowerCase() === 'sub' ? 'sub' : 'main';
      if (target === 'main') state.cardDisplayMain = normalized;
      else state.cardDisplaySub = normalized;
      ui.syncCardDisplayFieldSelectors();
      render.grid();
      ui.renderCardList();
      markViewDirty_();
      utils.saveStatus('saved', 'Field added');
    },

    setCardColorFromSettings: (key, value) => {
      if (!state.cardColors || typeof state.cardColors !== 'object') state.cardColors = Object.assign({}, CARD_COLOR_DEFAULTS);
      const mapKey = String(key || '');
      if (!mapKey) return;
      const fallback = CARD_COLOR_DEFAULTS.hasOwnProperty(mapKey) ? CARD_COLOR_DEFAULTS[mapKey] : '#2563eb';
      state.cardColors[mapKey] = normalizeHexColor_(value, fallback);
      applyCardColorTheme_();
      render.grid();
      markViewDirty_();
    },

    saveViewSettings: () => {
      store.saveViewMeta('view');
    },

    saveLaneSettings: () => {
      store.saveViewMeta('lane');
    },

    resolveCollisions: (movedCard) => {
      if (!state.autoPush) return;
      if (!movedCard || !movedCard.laneId || movedCard.laneId === 'unassigned') return;
      if (!isFinite(movedCard.start) || !isFinite(movedCard.end)) return;
      var shifted = pushDownLaneSuffixPreserveGaps_(
        movedCard.laneId,
        movedCard.start,
        movedCard.end,
        [movedCard.id]
      );
      shifted.forEach(function (c) { actions.commit(c.id, 'update'); });
    },

    moveCard: (id, newStart, newLane) => {
      const c = state.cards[id];
      if (!c) return;
      withCommitOp_('move_card', () => {
        const laneBefore = String(c.laneId || '');
        const laneAfter = String(newLane || laneBefore);
        const dur = c.end - c.start + 1;
        const requestedStart = Math.max(1, Math.round(Number(newStart) || 1));
        const resolvedStart = resolveInsertStartByEarlyCards_(laneAfter, requestedStart, [id]);
        const expectedById = snapshotLaneLengths_(laneAfter);
        expectedById[String(id)] = Math.max(1, Math.round(Number(dur) || 1));
        c.start = resolvedStart;
        c.end = resolvedStart + dur - 1;
        c.laneId = newLane;
        actions.resolveCollisions(c);
        const fixed = enforceLaneLengthInvariant_(laneAfter, expectedById, 'moveCard');
        fixed.forEach((f) => {
          if (String(f.id) !== String(id)) actions.commit(f.id, 'update');
        });
        render.grid();
        ui.renderCardList();
        actions.commit(id, 'update');
        if (!(state.assetCellSelection && isFinite(Number(state.assetCellSelection.rawStart)))) {
          ui.refreshInspectorValuesFromCard();
        }
        queueAssetInspectorRefresh_();
      });
    },

    moveCardBlock: (cardIds, targetStart, targetLane) => {
      var ids = normalizeCardIds_(cardIds);
      if (!ids.length) return;
      withCommitOp_('move_block', () => {
        var cards = ids
          .map(function (id) { return state.cards[id]; })
          .filter(function (c) { return !!c && isFinite(Number(c.start)) && isFinite(Number(c.end)); })
          .sort(function (a, b) {
            if (Number(a.start) !== Number(b.start)) return Number(a.start) - Number(b.start);
            return String(a.id || '').localeCompare(String(b.id || ''));
          });
        if (!cards.length) return;
        var laneId = String(targetLane || cards[0].laneId || '');
        if (!laneId || laneId === 'unassigned') return;
        var base = Math.round(Number(cards[0].start) || 1);
        var entries = cards.map(function (c) {
          var len = getCardLengthSlots_(c);
          var relStart = Math.max(0, Math.round(Number(c.start) || base) - base);
          return { id: String(c.id || ''), relStart: relStart, len: len };
        });
        var requestedStart = Math.max(1, Math.round(Number(targetStart) || 1));
        var start = resolveInsertStartByEarlyCards_(laneId, requestedStart, ids);
        var blockSpan = 1;
        entries.forEach(function (ent) {
          blockSpan = Math.max(blockSpan, ent.relStart + ent.len);
        });
        var blockEnd = start + blockSpan - 1;
        var expectedById = {};
        entries.forEach(function (ent) {
          var card = state.cards[ent.id];
          if (!card) return;
          card.laneId = laneId;
          card.start = start + ent.relStart;
          card.end = card.start + ent.len - 1;
          expectedById[String(card.id || '')] = ent.len;
        });
        var shifted = pushDownLaneSuffixPreserveGaps_(laneId, start, blockEnd, ids);
        shifted.forEach(function (card) { actions.commit(card.id, 'update'); });
        var fixed = enforceLaneLengthInvariant_(laneId, expectedById, 'moveCardBlock');
        fixed.forEach(function (f) {
          if (ids.indexOf(String(f.id || '')) < 0) actions.commit(f.id, 'update');
        });
        render.grid();
        ui.renderCardList();
        ids.forEach(function (cid) { actions.commit(cid, 'update'); });
        state.selection = ids[0];
        state.multiSelection = ids.slice();
        state.multiAnchorCardId = ids[0];
        ui.renderInspector();
        queueAssetInspectorRefresh_();
      });
    },

    toggleLane: (id) => {
      const l = state.lanes.find(x => x.id === id);
      if (l) {
        l.visible = !l.visible;
        store.saveLanes();
        render.all();
      }
    },

    moveLane: (id, dir) => {
      var laneId = String(id || '');
      if (!laneId || laneId === 'unassigned') return;
      var step = Number(dir);
      if (!isFinite(step) || !step) return;
      var idx = state.lanes.findIndex(function(l) { return String(l && l.id || '') === laneId; });
      if (idx < 0) return;
      var next = idx + (step > 0 ? 1 : -1);
      if (next < 1 || next >= state.lanes.length) return;
      var tmp = state.lanes[idx];
      state.lanes[idx] = state.lanes[next];
      state.lanes[next] = tmp;
      render.all();
      markLaneDirty_();
    },

    setLaneWidth: (raw) => {
      var n = Math.round(Number(raw));
      if (!isFinite(n)) return;
      if (!(n > 0)) return;
      n = Math.min(360, n);
      state.laneWidth = n;
      document.documentElement.style.setProperty('--lane-w', `${n}px`);
      var laneWInput = document.getElementById('inp-lane-w');
      if (laneWInput && document.activeElement !== laneWInput) laneWInput.value = String(n);
      render.all();
      markLaneDirty_();
    },

    setAssetColWidth: (raw) => {
      var n = Math.round(Number(raw));
      if (!isFinite(n)) return;
      if (!(n > 0)) return;
      n = Math.min(420, n);
      state.assetColWidth = n;
      document.documentElement.style.setProperty('--asset-col-w', `${n}px`);
      var assetWInput = document.getElementById('inp-asset-w');
      if (assetWInput && document.activeElement !== assetWInput) assetWInput.value = String(n);
      render.all();
      markLaneDirty_();
    },
    setViewMode: (rawMode) => {
      const next = String(rawMode || '').trim().toLowerCase() === 'lite' ? 'lite' : 'grid';
      if (state.viewMode === next) return;
      state.viewMode = next;
      render.all();
      markViewDirty_();
    },

    deleteCard: (id) => {
      if (!confirm('Delete permanently?')) return;
      delete state.cards[id];
      state.selection = null;
      render.grid();
      ui.renderCardList();
      ui.renderInspector();
      actions.commit(id, 'delete');
    },

    autoCreate: () => {
      const used = new Set(Object.values(state.cards).map(c => c.taskId));
      const orphans = state.tasks
        .filter(t => t.id && !used.has(t.id))
        .slice()
        .sort((a, b) => {
          const oa = getTaskOrderValue_(a);
          const ob = getTaskOrderValue_(b);
          if (oa !== ob) return oa - ob;
          return String(a.id || '').localeCompare(String(b.id || ''));
        });
      if (!orphans.length) { alert('No orphans.'); return; }
      if (!confirm(`Create ${orphans.length} cards?`)) return;
      waitForCommitQueueIdle_({
        timeoutMs: 120000,
        message: 'Waiting save queue...',
        onReady: () => {
          setBlockingOverlay_(true, 'Creating cards...');
          utils.saveStatus('saving', 'Preparing task estimates...');
          google.script.run
            .withSuccessHandler((resRaw) => {
              let res = resRaw;
              if (typeof resRaw === 'string') {
                try { res = JSON.parse(resRaw); } catch (_) { res = { ok: false, error: 'Invalid auto-create response' }; }
              }
              if (!(res && res.ok)) {
                setBlockingOverlay_(false);
                utils.saveStatus('error', String((res && (res.error && (res.error.message || res.error))) || 'Auto create failed'));
                return;
              }
              const createdCards = Array.isArray(res.createdCards) ? res.createdCards : [];
              createdCards.forEach((card) => {
                const id = String(card && card.id || '').trim();
                if (!id) return;
                const taskId = String(card && card.taskId || '').trim();
                const task = taskId ? getTaskByIdSafe_(taskId) : null;
                state.cards[id] = {
                  id: id,
                  taskId: taskId,
                  title: task ? String(task.name || '') : '',
                  laneId: String(card && card.lane || 'unassigned') || 'unassigned',
                  start: Math.max(1, Math.round(Number(card && card.start || 1))),
                  end: Math.max(1, Math.round(Number(card && card.end || 1))),
                  memo: String(card && card.memo || ''),
                  status: task ? String(task.status || '') : ''
                };
              });
              render.grid();
              ui.renderCardList();
              const msg = `Created ${Number(res.created || createdCards.length || 0)} cards (recalc ${Number(res.recalcCount || 0)}, failed ${Number(res.recalcFailed || 0)})`;
              utils.saveStatus('saved', msg);
              setBlockingOverlay_(false);
              actions.load({ forceNetwork: true });
            })
            .withFailureHandler((err) => {
              setBlockingOverlay_(false);
              utils.saveStatus('error', String(err && (err.message || err) || 'Auto create failed'));
            })
            .sv_scheduler_prepare_autocreate_v1(JSON.stringify({
              schedId: String(state.schedId || ''),
              taskIds: orphans.map((t) => String(t.id || '')).filter((v) => !!v)
            }));
        },
        onTimeout: () => {
          utils.saveStatus('error', 'Auto create timeout (save queue busy)');
        }
      });
    },

    newCard: () => {
      let maxNum = 0;
      Object.values(state.cards).forEach(c => {
        const raw = String(c.id || '');
        const digits = raw.replace(/\D/g, '');
        const n = parseInt(digits || raw, 10);
        if (!isNaN(n) && n > maxNum) maxNum = n;
      });
      const nextNum = String(maxNum + 1).padStart(3, '0');
      const id = nextNum;
      const card = { id, taskId: '', title: 'New_Task', laneId: 'unassigned', start: 1, end: 2, memo: '', status: '' };
      state.cards[id] = card;
      actions.commit(id, 'create');
      ui.renderCardList();
      render.grid();
      actions.selectCard(id);
    }
  };

  (function applyTimezoneActionGuard_() {
    const allow = { load: true };
    Object.keys(actions).forEach((name) => {
      if (allow[name]) return;
      const fn = actions[name];
      if (typeof fn !== 'function') return;
      actions[name] = function guardedAction_() {
        if (!ensureTimezoneReady_()) return;
        return fn.apply(actions, arguments);
      };
    });
  })();

  const render = {
    all: () => {
      render.headers();
      if (state.viewMode === 'lite') render.lite();
      else render.grid();
      ui.renderMenu();
      ui.renderCardList();
    },

    headers: () => {
      els.laneHeaders.innerHTML = '';
      state.lanes.filter(l => l.visible).forEach(l => {
        const d = document.createElement('div');
        d.className = 'lane-header-cell'; d.textContent = l.label;
        els.laneHeaders.appendChild(d);
      });
      if (state.assetColumnVisible && state.viewMode !== 'lite') {
        const assetsHead = document.createElement('div');
        assetsHead.className = 'lane-header-cell assets-col';
        assetsHead.textContent = 'ASSETS';
        els.laneHeaders.appendChild(assetsHead);
      }
    },

    grid: () => {
      if (state.viewMode === 'lite') {
        render.lite();
        return;
      }
      els.dateAxis.innerHTML = ''; els.canvas.innerHTML = '';
      refreshAssetUsageState_();
      const lanes = state.lanes.filter(l => l.visible);
      const pxPerDay = getPxPerDay_();
      const h = state.workDayMap.length * pxPerDay;
      const laneWidth = getLaneWidth_();
      const assetsColW = getAssetsColWidth_();
      const w = (lanes.length * laneWidth) + (state.assetColumnVisible ? assetsColW : 0);

      els.canvas.style.height = h + 'px';
      els.canvas.style.width = w + 'px';

      const snap = getSnapState_();
      if (els.configInfo) {
        var originText = config.originDisplayText || formatYmd_(config.originDate).replace(/-/g, '/');
        var baseOriginText = formatYmd_(config.originDate).replace(/-/g, '/');
        var tzText = state.projectTimezoneRaw || 'UNSET';
        els.configInfo.innerHTML = `
          <span class="info-tag" title="Base origin for rawSlot: ${baseOriginText}">Origin: ${originText}</span>
          <span class="info-tag">Slot: ${config.slotMin}m</span>
          <span class="info-tag">Work: ${config.workHours}h</span>
          <span class="info-tag" style="${state.timezoneConfigured ? '' : 'color:#f87171; border-color:#f87171;'}">TZ: ${tzText}</span>
          <span class="info-tag">Res: ${snap.label}</span>
          <span class="info-tag" title="Overloaded assets by slot">Assetâš : ${state.assetUsageStats.conflictSlots || 0}</span>
        `;
      }
      const dayMinutes = config.workHours * 60;
      let bgImage = 'linear-gradient(to bottom, var(--grid-line-strong) 1px, transparent 1px)';
      let bgSize = `100% ${pxPerDay}px`;

      if (snap.min < dayMinutes) {
        const subH = pxPerDay * (snap.min / dayMinutes);
        bgImage = 'linear-gradient(to bottom, var(--grid-line-strong) 1px, transparent 1px), linear-gradient(to bottom, var(--grid-line) 1px, transparent 1px)';
        bgSize = `100% ${pxPerDay}px, 100% ${subH}px`;
      }
      els.canvas.style.backgroundImage = bgImage;
      els.canvas.style.backgroundSize = bgSize;

      let lastYear = null;
      if (state.workDayMap && state.workDayMap.length) {
        lastYear = state.workDayMap[0].getFullYear();
      }
      state.workDayMap.forEach((d) => {
        const cell = document.createElement('div');
        const compact = pxPerDay < 40;
        cell.className = `date-cell${compact ? ' compact' : ''}`;
        cell.style.height = pxPerDay + 'px';
        const year = d.getFullYear();
        const showYear = year !== lastYear;
        if (showYear) lastYear = year;

        const fmt = utils.fmtDateAxis(d);
        let html = `<div class="d-main">${fmt.main}</div><div class="d-sub">${fmt.sub}</div>`;
        if (showYear) html = `<div class="year-marker">${year}</div>` + html;
        cell.innerHTML = html;
        els.dateAxis.appendChild(cell);
      });

      lanes.forEach(l => {
        const col = document.createElement('div');
        col.className = 'lane-col-bg'; col.dataset.laneId = l.id;
        els.canvas.appendChild(col);
      });
      for (let i = 1; i < lanes.length; i++) {
        const line = document.createElement('div');
        line.className = 'lane-boundary-line';
        line.style.left = (i * laneWidth) + 'px';
        els.canvas.appendChild(line);
      }
      if (state.assetColumnVisible) {
        const assetsBg = document.createElement('div');
        assetsBg.className = 'asset-col-bg';
        els.canvas.appendChild(assetsBg);
        const assetBoundary = document.createElement('div');
        assetBoundary.className = 'lane-boundary-line';
        assetBoundary.style.left = (lanes.length * laneWidth) + 'px';
        els.canvas.appendChild(assetBoundary);
      }

      state.workDayMap.forEach((d, idx) => {
        if (idx === 0) return;
        if (d.getDay() !== 1) return;
        const sep = document.createElement('div');
        sep.className = 'week-sep';
        sep.style.top = (idx * pxPerDay) + 'px';
        els.canvas.appendChild(sep);
      });

      lanes.forEach((lane, laneIdx) => {
        const laneCards = Object.values(state.cards || {})
          .filter((c) => String(c && c.laneId || '') === String(lane.id || '') && isFinite(Number(c && c.start)) && isFinite(Number(c && c.end)))
          .sort((a, b) => Number(a.start) - Number(b.start));
        if (laneCards.length < 2) return;
        for (let gi = 0; gi < laneCards.length - 1; gi++) {
          const a = laneCards[gi];
          const b = laneCards[gi + 1];
          const from = Math.round(Number(a.end)) + 1;
          const to = Math.round(Number(b.start)) - 1;
          if (!(isFinite(from) && isFinite(to)) || from > to) continue;
          const rect = slotRectForRawRange_(from, to, pxPerDay);
          if (!rect) continue;
          const hit = document.createElement('div');
          hit.className = 'gap-hitbox';
          hit.tabIndex = 0;
          hit.setAttribute('role', 'button');
          hit.setAttribute('aria-label', `Gap ${from}-${to}`);
          hit.style.left = (laneIdx * laneWidth + 4) + 'px';
          hit.style.top = rect.top + 'px';
          hit.style.height = rect.height + 'px';
          hit.title = `Gap ${from}-${to} (${to - from + 1})`;
          hit.dataset.gapLaneId = String(lane.id || '');
          hit.dataset.gapFrom = String(from);
          hit.dataset.gapTo = String(to);
          hit.addEventListener('mousedown', (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
          });
          hit.addEventListener('click', (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            actions.selectGap({
              laneId: String(lane.id || ''),
              fromSlot: from,
              toSlot: to,
              sizeSlots: (to - from + 1),
              prevCardId: String(a.id || ''),
              nextCardId: String(b.id || '')
            });
          });
          els.canvas.appendChild(hit);
        }
      });

      if (state.gapSelection && state.gapSelection.sizeSlots > 0) {
        const g = state.gapSelection;
        const laneIdx = lanes.findIndex((l) => String(l.id || '') === String(g.laneId || ''));
        const rect = slotRectForRawRange_(g.fromSlot, g.toSlot, pxPerDay);
        if (laneIdx >= 0 && rect) {
          const left = (laneIdx * laneWidth) + 4;
          const gapEl = document.createElement('div');
          gapEl.className = 'gap-marker';
          gapEl.style.top = rect.top + 'px';
          gapEl.style.left = left + 'px';
          gapEl.style.height = Math.max(6, rect.height - 1) + 'px';
          gapEl.title = `Gap ${g.fromSlot}-${g.toSlot} (${g.sizeSlots})`;
          els.canvas.appendChild(gapEl);
        }
      }

      if (state.dragPreview && state.dragPreview.laneId) {
        var p = state.dragPreview;
        var laneIdxPreview = lanes.findIndex(function (l) { return String(l.id || '') === String(p.laneId || ''); });
        var previewRect = slotRectForRawRange_(p.start, p.end, pxPerDay);
        if (laneIdxPreview >= 0 && previewRect) {
          var previewLeft = (laneIdxPreview * laneWidth) + 4;
          var previewEl = document.createElement('div');
          var modeClass = (p.mode === 'resize') ? 'resize' : (p.mode === 'block' ? 'block' : 'move');
          previewEl.className = 'drag-preview ' + modeClass;
          previewEl.style.left = previewLeft + 'px';
          previewEl.style.top = previewRect.top + 'px';
          previewEl.style.height = Math.max(8, previewRect.height - 1) + 'px';
          previewEl.title = `Drop ${p.start}-${p.end}`;
          els.canvas.appendChild(previewEl);

          var lineEl = document.createElement('div');
          lineEl.className = 'drop-slot-line ' + modeClass;
          lineEl.style.left = previewLeft + 'px';
          lineEl.style.top = Math.max(0, previewRect.top - 1) + 'px';
          els.canvas.appendChild(lineEl);
        }
      }

      Object.values(state.cards).forEach(c => {
        if (c.start === null) return;
        const sNorm = utils.normalizeSlot(c.start, 'start');
        const dayIdx = state.workDayMap.findIndex(wd => formatYmd_(wd) === sNorm.dateVal);
        if(dayIdx === -1) return;
        const laneIdx = lanes.findIndex(l => l.id === c.laneId);
        if(laneIdx === -1) return;

        const startRatio = sNorm.slotsPerDay > 0 ? ((sNorm.slotVal - 1) / sNorm.slotsPerDay) : 0;
        const top = (dayIdx * pxPerDay) + (startRatio * pxPerDay);
        const spanSlotsRaw = Math.round(Number(c.end) - Number(c.start) + 1);
        const spanSlots = Math.max(1, isFinite(spanSlotsRaw) ? spanSlotsRaw : 1);
        const h = Math.max(14, (spanSlots / Math.max(1, sNorm.slotsPerDay)) * pxPerDay);
        const left = (laneIdx * laneWidth) + 4;

        const div = document.createElement('div');
        const conflictInfo = state.cardAssetConflictById[String(c.id)];
        const isPrimary = String(state.selection || '') === String(c.id || '');
        const isMulti = isCardInMultiSelection_(c.id);
        const t = getTaskByIdSafe_(c.taskId);
        const isTaskless = !t;
        const cardStatus = normalizeTaskStatus_(c.status || (t && t.status) || '');
        const cameraMove = taskBoolValue_(t, TASK_FIDS.cameraMovement, ['cameraMovement', 'camera_movement']);
        div.className = `card ${isPrimary ? 'selected' : ''} ${isMulti ? 'multi-selected' : ''} ${conflictInfo ? 'asset-conflict' : ''} ${cardStatus ? ('status-' + cardStatus) : ''} ${cameraMove ? 'camera-move' : ''} ${isTaskless ? 'taskless' : ''}`;
        div.style.top = top + 'px'; div.style.left = left + 'px';
        div.style.height = (h - 1) + 'px';

        const view = getCardDisplayModel_(c);
        div.innerHTML = `<div class="c-id">${escapeHtml_(view.cardNo)}</div><div class="c-main">${escapeHtml_(view.mainText)}</div>`;
        if (h > 35 && view.subText) div.innerHTML += `<div class="c-sub">${escapeHtml_(view.subText)}</div>`;
        if (conflictInfo && conflictInfo.overSlots > 0) {
          var conflictAssetText = (conflictInfo.assetIds || []).map(getAssetLabel_).join(', ');
          var overAssetCount = Array.isArray(conflictInfo.assetIds) ? conflictInfo.assetIds.length : 0;
          div.title = `Asset overlap: ${overAssetCount} asset(s)` + (conflictAssetText ? ` | ${conflictAssetText}` : '');
        }
        div.dataset.cardId = String(c.id);

        const chkMulti = document.createElement('input');
        chkMulti.type = 'checkbox';
        chkMulti.className = 'card-multi-toggle';
        chkMulti.checked = !!isMulti;
        chkMulti.title = 'Multi-select';
        chkMulti.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });
        chkMulti.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        chkMulti.addEventListener('change', (e) => {
          e.stopPropagation();
          actions.toggleMultiSelection(c.id, { checked: !!chkMulti.checked, contiguous: false });
        });
        div.appendChild(chkMulti);
        if (cameraMove) {
          const moveBand = document.createElement('div');
          moveBand.className = 'card-move-band';
          moveBand.textContent = 'MOVE';
          div.appendChild(moveBand);
        }
        if (conflictInfo && conflictInfo.overSlots > 0) {
          const conflictBadge = document.createElement('div');
          conflictBadge.className = 'card-conflict-badge';
          conflictBadge.textContent = 'ASSET!';
          div.appendChild(conflictBadge);
        }

        const xBtn = document.createElement('div'); xBtn.className='card-close'; xBtn.textContent='Ã—';
        xBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          requestRemoveCardFromLane_(c.id);
        });
        div.appendChild(xBtn);

        const rsz = document.createElement('div'); rsz.className='card-resizer';
        div.appendChild(rsz);

        div.addEventListener('mousedown', (e) => dragStart(e, c, div));
        els.canvas.appendChild(div);
      });
      if (state.assetColumnVisible) {
        renderAssetsColumnInGrid_(lanes, pxPerDay, snap);
      }
      if (state.assetCellSelection && isFinite(Number(state.assetCellSelection.rawStart))) {
        state.assetCellSelection.rows = summarizeAssetsForRawRange_(
          state.assetCellSelection.rawStart,
          state.assetCellSelection.rawEnd
        );
        ui.renderInspector();
      }
    },

    lite: () => {
      els.dateAxis.innerHTML = '';
      els.canvas.innerHTML = '';
      const lanes = state.lanes.filter(l => l.visible);
      const laneWidth = getLaneWidth_();
      const rowH = Math.max(72, Math.round(getPxPerDay_()));
      const h = state.workDayMap.length * rowH;
      const w = lanes.length * laneWidth;
      els.canvas.style.height = h + 'px';
      els.canvas.style.width = w + 'px';
      els.canvas.style.backgroundImage = 'linear-gradient(to bottom, var(--grid-line-strong) 1px, transparent 1px)';
      els.canvas.style.backgroundSize = `100% ${rowH}px`;

      if (els.configInfo) {
        var originText = config.originDisplayText || formatYmd_(config.originDate).replace(/-/g, '/');
        var baseOriginText = formatYmd_(config.originDate).replace(/-/g, '/');
        var tzText = state.projectTimezoneRaw || 'UNSET';
        els.configInfo.innerHTML = `
          <span class="info-tag" title="Base origin for rawSlot: ${baseOriginText}">Origin: ${originText}</span>
          <span class="info-tag">Mode: Lite</span>
          <span class="info-tag">Slot: ${config.slotMin}m</span>
          <span class="info-tag">Work: ${config.workHours}h</span>
          <span class="info-tag" style="${state.timezoneConfigured ? '' : 'color:#f87171; border-color:#f87171;'}">TZ: ${tzText}</span>
        `;
      }

      let lastYear = null;
      if (state.workDayMap && state.workDayMap.length) lastYear = state.workDayMap[0].getFullYear();
      state.workDayMap.forEach((d) => {
        const cell = document.createElement('div');
        cell.className = 'date-cell';
        cell.style.height = rowH + 'px';
        const year = d.getFullYear();
        const showYear = year !== lastYear;
        if (showYear) lastYear = year;
        const fmt = utils.fmtDateAxis(d);
        let html = `<div class="d-main">${fmt.main}</div><div class="d-sub">${fmt.sub}</div>`;
        if (showYear) html = `<div class="year-marker">${year}</div>` + html;
        cell.innerHTML = html;
        els.dateAxis.appendChild(cell);
      });

      const dayVals = state.workDayMap.map((d) => formatYmd_(d));
      const laneIndexById = {};
      lanes.forEach((l, idx) => { laneIndexById[String(l.id || '')] = idx; });

      const bucket = {};
      const keyOf_ = (laneId, dayIdx) => String(laneId || '') + '|' + String(dayIdx);
      Object.values(state.cards || {}).forEach((c) => {
        if (!c || !isFinite(Number(c.start)) || !isFinite(Number(c.end))) return;
        const laneId = String(c.laneId || '');
        if (!Object.prototype.hasOwnProperty.call(laneIndexById, laneId)) return;
        const s = utils.slotToDateVal(Number(c.start || 1), 'start');
        const e = utils.slotToDateVal(Number(c.end || 1), 'end');
        const sVal = String((s && s.dateVal) || '');
        const eVal = String((e && e.dateVal) || '');
        if (!sVal || !eVal) return;
        for (let di = 0; di < dayVals.length; di++) {
          const dv = dayVals[di];
          if (dv < sVal || dv > eVal) continue;
          const k = keyOf_(laneId, di);
          if (!bucket[k]) bucket[k] = [];
          bucket[k].push(c);
        }
      });

      const sortInCell_ = (a, b) => {
        const ta = getTaskByIdSafe_(a && a.taskId);
        const tb = getTaskByIdSafe_(b && b.taskId);
        const parseOrder_ = (task, card) => {
          const raw = task ? (
            task.taskOrder ||
            task.order ||
            taskRawValue_(task, TASK_FIDS.taskOrder, ['taskOrder', 'task Order', 'task_order', 'order'])
          ) : '';
          const n = Number(String(raw || '').replace(/[^\d.-]/g, ''));
          if (isFinite(n) && n > 0) return Math.round(n);
          const cNo = Number(String((card && (card.displayId || card.id)) || '').replace(/\D+/g, ''));
          if (isFinite(cNo) && cNo > 0) return cNo;
          return Number.MAX_SAFE_INTEGER;
        };
        const oa = parseOrder_(ta || null, a || null);
        const ob = parseOrder_(tb || null, b || null);
        if (oa !== ob) return oa - ob;
        const sa = Number(a && a.start || 0);
        const sb = Number(b && b.start || 0);
        if (sa !== sb) return sa - sb;
        const aNo = Number(String((a && (a.displayId || a.id)) || '').replace(/\D+/g, ''));
        const bNo = Number(String((b && (b.displayId || b.id)) || '').replace(/\D+/g, ''));
        if (isFinite(aNo) && isFinite(bNo) && aNo !== bNo) return aNo - bNo;
        return String(a && a.id || '').localeCompare(String(b && b.id || ''));
      };

      for (let li = 0; li < lanes.length; li++) {
        const lane = lanes[li];
        for (let di = 0; di < dayVals.length; di++) {
          const cell = document.createElement('div');
          cell.className = 'lite-cell';
          cell.style.left = (li * laneWidth) + 'px';
          cell.style.top = (di * rowH) + 'px';
          cell.style.width = laneWidth + 'px';
          cell.style.height = rowH + 'px';
          const items = (bucket[keyOf_(lane.id, di)] || []).slice().sort(sortInCell_);
          const maxTokensPerCell = Math.max(2, Math.min(8, Math.floor((rowH - 10) / 17)));
          const overflowCount = Math.max(0, items.length - maxTokensPerCell);
          const visibleCardCount = overflowCount > 0 ? (maxTokensPerCell - 1) : items.length;
          for (let ii = 0; ii < visibleCardCount; ii++) {
            const c = items[ii];
            const t = getTaskByIdSafe_(c.taskId);
            const isTaskless = !t;
            const status = normalizeTaskStatus_(c.status || (t && t.status) || '');
            const cardView = getCardDisplayModel_(c);
            const isPrimary = String(state.selection || '') === String(c.id || '');
            const isMulti = isCardInMultiSelection_(c.id);
            const token = document.createElement('div');
            token.className = `lite-token ${status ? ('status-' + status) : ''} ${isTaskless ? 'taskless' : ''} ${isPrimary ? 'selected' : ''} ${isMulti ? 'multi-selected' : ''}`;
            const taskOrder = getTaskOrderValue_(t || {});
            const s = utils.slotToDateVal(Number(c.start || 1), 'start');
            const e = utils.slotToDateVal(Number(c.end || 1), 'end');
            const sVal = String((s && s.dateVal) || '');
            const eVal = String((e && e.dateVal) || '');
            const arrow = (sVal !== eVal)
              ? (dayVals[di] === sVal ? 'â†’' : (dayVals[di] === eVal ? 'â†' : 'â†”'))
              : '';
            token.innerHTML = `<span class="lt-order">${isFinite(taskOrder) && taskOrder < Number.MAX_SAFE_INTEGER ? taskOrder : '-'}</span>` +
              `<span class="lt-main">${escapeHtml_(cardView.mainText || cardView.cardNo || c.id || '')}</span>` +
              `${arrow ? `<span class="lt-arrow">${arrow}</span>` : ''}`;
            token.title = `${cardView.cardNo || c.id || ''} ${cardView.mainText || ''}`.trim();
            token.addEventListener('click', (ev) => {
              ev.stopPropagation();
              actions.selectCard(c.id);
            });
            cell.appendChild(token);
          }
          if (overflowCount > 0) {
            const more = document.createElement('div');
            more.className = 'lite-token more';
            more.innerHTML = `<span class="lt-main">+${overflowCount} more</span>`;
            more.title = `+${overflowCount} more cards in this day cell`;
            cell.appendChild(more);
          }
          els.canvas.appendChild(cell);
        }
      }
    }
  };

  function fmtTaskDateForInspector_(v) {
    if (!v) return '';
    if (v instanceof Date && !isNaN(v)) return utils.fmtYmdText(v);
    const d1 = utils.parseDateTextStrict(v);
    if (d1) return utils.fmtYmdText(d1);
    const d2 = utils.parseDateTime(v);
    return d2 && !isNaN(d2) ? utils.fmtYmdText(d2) : '';
  }

  function resolveDropTargetFromCanvas_(x, y) {
    const pxPerDay = getPxPerDay_();
    const dayIdx = Math.floor(y / pxPerDay);
    if (!state.workDayMap[dayIdx]) return null;
    const yInDay = y % pxPerDay;
    const snapState = snapMinutes_(yInDay, pxPerDay);
    const snappedMins = snapState.minutes;
    const d = new Date(state.workDayMap[dayIdx]);
    d.setHours(0, 0, 0, 0);
    const spd = getSlotsPerDay_();
    let slotVal = Math.round(snappedMins / config.slotMin) + 1;
    slotVal = Math.max(1, Math.min(spd, slotVal));
    const newStart = utils.dateValToSlot(formatYmd_(d), slotVal, 'start');
    const lanes = state.lanes.filter(l => l.visible);
    const laneWidth = getLaneWidth_();
    const laneIdx = Math.floor(x / laneWidth);
    const newLane = (laneIdx >= 0 && laneIdx < lanes.length) ? lanes[laneIdx].id : null;
    return { newStart, newLane, snapState };
  }

  function getLaneLabelById_(laneId) {
    const key = String(laneId || '').trim();
    const lane = (state.lanes || []).find((l) => String((l && l.id) || '').trim() === key);
    if (lane && lane.label) return String(lane.label);
    return key || 'unassigned';
  }

  function renderLiteInspector_(container, c) {
    if (!container || !c) return;
    const t = getTaskByIdSafe_(c.taskId);
    const cardView = getCardDisplayModel_(c);
    const displayId = (c.displayId != null && c.displayId !== '') ? String(c.displayId) : utils.getDisplayId(c.id);
    const sVal = utils.slotToDateVal(c.start || 1, 'start');
    const eVal = utils.slotToDateVal(c.end || 1, 'end');
    const lenSlots = Math.max(1, Math.round(Number(c.end || 1) - Number(c.start || 1) + 1));
    const lenMin = lenSlots * Math.max(1, Math.round(Number(config.slotMin) || 1));

    const makeReadRow_ = (label, value) => {
      const g = document.createElement('div');
      g.className = 'inp-group';
      const l = document.createElement('label');
      l.textContent = label;
      const v = document.createElement('input');
      v.className = 'inp';
      v.readOnly = true;
      v.value = String(value || '');
      g.appendChild(l);
      g.appendChild(v);
      container.appendChild(g);
    };

    const headerMeta = document.createElement('div');
    headerMeta.style.cssText = 'display:flex; align-items:center; gap:6px; min-width:0;';
    const cardNo = document.createElement('div');
    cardNo.className = 'info-tag';
    cardNo.style.cssText = 'display:inline-block; font-size:10px; margin-bottom:2px;';
    cardNo.textContent = `CARD NO. ${displayId}`;
    headerMeta.appendChild(cardNo);
    container.appendChild(headerMeta);

    const title = document.createElement('div');
    title.style.cssText = 'background:#222; padding:6px; font-weight:bold; border-radius:4px; display:flex; align-items:center; justify-content:space-between; gap:8px;';
    const titleText = document.createElement('span');
    titleText.style.cssText = 'min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;';
    titleText.textContent = cardView.mainText || c.title || '';
    const focusBtn = document.createElement('button');
    focusBtn.type = 'button';
    focusBtn.className = 'btn';
    focusBtn.textContent = 'Focus';
    focusBtn.addEventListener('click', () => actions.focusSelected());
    title.appendChild(titleText);
    title.appendChild(focusBtn);
    container.appendChild(title);

    const hint = document.createElement('div');
    hint.className = 'info-tag';
    hint.style.cssText = 'margin-top:6px;';
    hint.textContent = 'Lite mode: status editable only';
    container.appendChild(hint);

    if (t && c.taskId) {
      const taskWrap = document.createElement('div');
      taskWrap.className = 'inp-group';
      const label = document.createElement('label');
      label.textContent = 'Status';
      const row = document.createElement('div');
      row.style.cssText = 'display:flex; align-items:center; gap:6px;';
      const statusSel = document.createElement('select');
      statusSel.className = 'inp';
      statusSel.style.maxWidth = '220px';
      statusSel.innerHTML = TASK_STATUS_OPTIONS.map((s) => `<option value="${s}">${s}</option>`).join('');
      statusSel.value = normalizeTaskStatus_(taskRawValue_(t, TASK_FIDS.status, ['status'])) || 'not_started';
      const statusPill = document.createElement('div');
      statusPill.className = 'status-pill ' + normalizeTaskStatus_(statusSel.value || '');
      statusPill.textContent = String(statusSel.value || '').replace(/_/g, ' ');
      statusSel.addEventListener('change', () => {
        const next = normalizeTaskStatus_(statusSel.value) || 'not_started';
        const patch = {};
        patch[TASK_FIDS.status] = next;
        commitTaskPatchFromInspector_(String(c.taskId || ''), patch, () => {
          statusSel.value = next;
          statusPill.className = 'status-pill ' + next;
          statusPill.textContent = String(next).replace(/_/g, ' ');
          ui.renderInspector();
        });
      });
      row.appendChild(statusSel);
      row.appendChild(statusPill);
      taskWrap.appendChild(label);
      taskWrap.appendChild(row);
      container.appendChild(taskWrap);
    } else {
      const note = document.createElement('div');
      note.className = 'info-tag';
      note.style.cssText = 'margin-top:6px; border-color:#4b5563; color:#9ca3af;';
      note.textContent = 'Taskless card (status edit unavailable)';
      container.appendChild(note);
    }

    makeReadRow_('Lane', getLaneLabelById_(c.laneId));
    makeReadRow_('Start', `${utils.fmtYmdText(sVal.date)} / slot ${sVal.slot}`);
    makeReadRow_('End', `${utils.fmtYmdText(eVal.date)} / slot ${eVal.slot}`);
    makeReadRow_('Length', `${lenMin}mins`);
    makeReadRow_('Task', String(c.taskId || ''));
    makeReadRow_('Memo', String(c.memo || ''));
  }

  const ui = {
    syncCardDisplayFieldSelectors: (mainSel, subSel, tasklessMainSel, tasklessSubSel) => {
      const main = mainSel || document.getElementById('sel-card-main');
      const sub = subSel || document.getElementById('sel-card-sub');
      const tasklessMain = tasklessMainSel || document.getElementById('sel-taskless-main');
      const tasklessSub = tasklessSubSel || document.getElementById('sel-taskless-sub');
      if (!main || !sub) return;
      const addFieldSel = document.getElementById('sel-card-add-field');
      const options = buildCardDisplayOptions_();
      const ensureOption_ = (value) => {
        const v = String(value || '').trim();
        if (!v) return;
        if (options.some((o) => o.value === v)) return;
        options.push({ value: v, label: v.indexOf(':') > 0 ? v.replace(':', ': ') : v });
      };
      ensureOption_(state.cardDisplayMain);
      ensureOption_(state.cardDisplaySub);
      ensureOption_(state.tasklessDisplayMain);
      ensureOption_(state.tasklessDisplaySub);
      const renderTo = (sel, selectedValue, fallback) => {
        const normalized = normalizeCardDisplayField_(selectedValue, fallback);
        sel.innerHTML = '';
        options.forEach((opt) => {
          const o = document.createElement('option');
          o.value = opt.value;
          o.textContent = opt.label;
          sel.appendChild(o);
        });
        const values = options.map((o) => o.value);
        if (values.indexOf(normalized) >= 0) sel.value = normalized;
        else sel.value = fallback;
      };
      renderTo(main, state.cardDisplayMain, 'shot_code');
      renderTo(sub, state.cardDisplaySub, 'task_name');
      if (tasklessMain) renderTo(tasklessMain, state.tasklessDisplayMain, 'card_memo');
      if (tasklessSub) renderTo(tasklessSub, state.tasklessDisplaySub, 'card_length');
      state.cardDisplayMain = normalizeCardDisplayField_(main.value, 'shot_code');
      state.cardDisplaySub = normalizeCardDisplayField_(sub.value, 'task_name');
      if (tasklessMain) state.tasklessDisplayMain = normalizeCardDisplayField_(tasklessMain.value, 'card_memo');
      if (tasklessSub) state.tasklessDisplaySub = normalizeCardDisplayField_(tasklessSub.value, 'card_length');
      if (addFieldSel) {
        const addCandidates = options.filter((opt) => {
          const v = String((opt && opt.value) || '');
          return !!v;
        });
        const prev = String(addFieldSel.value || '');
        addFieldSel.innerHTML = '';
        addCandidates.forEach((opt) => {
          const o = document.createElement('option');
          o.value = opt.value;
          o.textContent = opt.label;
          addFieldSel.appendChild(o);
        });
        if (prev && addCandidates.some((opt) => String(opt.value) === prev)) addFieldSel.value = prev;
      }
    },
    renderMenu: () => {
      const m = document.getElementById('lane-menu-list');
      if (!m) return;
      m.innerHTML = '';
      const assetsRow = document.createElement('div');
      assetsRow.className = 'lane-row';
      const assetsChk = document.createElement('input');
      assetsChk.type = 'checkbox';
      assetsChk.checked = !!state.assetColumnVisible;
      assetsChk.addEventListener('change', () => {
        state.assetColumnVisible = !!assetsChk.checked;
        if (!state.assetColumnVisible) state.assetCellSelection = null;
        markLaneDirty_();
        render.all();
      });
      assetsRow.appendChild(assetsChk);
      assetsRow.appendChild(document.createTextNode('ASSETS'));
      m.appendChild(assetsRow);
      state.lanes.forEach((l, idx) => {
        const row = document.createElement('div'); row.className = 'lane-row';
        const chk = document.createElement('input'); chk.type = 'checkbox'; chk.checked = l.visible;
        chk.addEventListener('change', () => { actions.toggleLane(l.id); });
        row.appendChild(chk);
        row.appendChild(document.createTextNode(l.label));
        const ctrls = document.createElement('span');
        ctrls.className = 'lane-row-controls';
        const up = document.createElement('button');
        up.type = 'button';
        up.className = 'btn lane-row-btn';
        up.textContent = 'â†‘';
        up.disabled = (idx <= 1 || String(l.id || '') === 'unassigned');
        up.addEventListener('click', () => actions.moveLane(l.id, -1));
        const down = document.createElement('button');
        down.type = 'button';
        down.className = 'btn lane-row-btn';
        down.textContent = 'â†“';
        down.disabled = (idx >= state.lanes.length - 1 || String(l.id || '') === 'unassigned');
        down.addEventListener('click', () => actions.moveLane(l.id, 1));
        ctrls.appendChild(up);
        ctrls.appendChild(down);
        row.appendChild(ctrls);
        m.appendChild(row);
      });
    },
    renderCardList: () => {
      refreshAssetUsageState_();
      const c = document.getElementById('card-list-container');
      if (!c) return;
      c.innerHTML = '';
      const q = document.getElementById('inp-filter').value.toLowerCase();
      Object.values(state.cards).forEach(card => {
        const cardView = getCardDisplayModel_(card);
        const searchBlob = [
          String(card.title || ''),
          String(cardView.cardNo || ''),
          String(cardView.mainText || ''),
          String(cardView.subText || ''),
          String(card.taskId || '')
        ].join(' ').toLowerCase();
        if (q && searchBlob.indexOf(q) < 0) return;
        const d = document.createElement('div');
        const laneId = String(card.laneId || '').trim();
        const lane = state.lanes.find(l => String(l.id || '') === laneId);
        const isUnassigned = !laneId || laneId === 'unassigned' || !lane;
        const invalidRange = (card.start === null || card.start === undefined || card.end === null || card.end === undefined ||
          !isFinite(card.start) || !isFinite(card.end) || (card.end - card.start) <= 0);
        const isAttention = isUnassigned || (!isUnassigned && invalidRange);
        const laneLabel = isUnassigned ? 'UNASSIGNED' : String(lane.label || laneId);
        d.className = `list-item ${card.start===null?'':'placed'} ${isUnassigned ? 'unassigned' : ''} ${isAttention ? 'attention' : ''}`;
        d.style.cssText = 'display:flex;align-items:center;justify-content:space-between;gap:8px;white-space:nowrap;flex-wrap:nowrap;';

        const left = document.createElement('div');
        left.className = 'li-left';
        left.style.cssText = 'display:flex;align-items:center;gap:6px;min-width:0;flex:1;flex-wrap:nowrap;overflow:hidden;';
        const idEl = document.createElement('span');
        idEl.style.cssText = 'font-size:9px;color:#666;min-width:36px;display:inline-block;white-space:nowrap;flex:0 0 auto;';
        idEl.textContent = cardView.cardNo || '';
        const titleEl = document.createElement('span');
        titleEl.className = 'li-title';
        titleEl.style.cssText = 'min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1 1 auto;';
        titleEl.textContent = cardView.mainText + (cardView.subText ? (' / ' + cardView.subText) : '');
        left.appendChild(idEl);
        left.appendChild(titleEl);

        const laneEl = document.createElement('span');
        laneEl.className = 'li-lane';
        laneEl.style.cssText = 'margin-left:auto;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:40%;flex:0 0 auto;';
        laneEl.textContent = laneLabel;
        d.appendChild(left);
        d.appendChild(laneEl);
        d.draggable = true;
        d.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', String(card.id));
          e.dataTransfer.effectAllowed = 'copyMove';
        });
        d.addEventListener('click', () => {
          actions.selectCard(card.id);
        });
        c.appendChild(d);
      });
    },
    switchTab: (t) => {
      document.querySelectorAll('.ins-tab').forEach(e => e.classList.remove('active'));
      document.querySelectorAll('.ins-panel').forEach(e => e.classList.add('hidden'));
      document.getElementById('tab-'+t).classList.add('active');
      document.getElementById('panel-'+t).classList.remove('hidden');
    },
    renderInspector: () => {
      refreshAssetUsageState_();
      const p = els.inspContent;
      if (!p) return;

      // Asset-cell inspector always takes precedence while a cell is selected.
      if (state.assetCellSelection && isFinite(Number(state.assetCellSelection.rawStart))) {
        setInspectorClosed_(false);
        p.innerHTML = '';
        renderAssetCellInspector_(state.assetCellSelection, p);
        return;
      }

      const c = state.cards[state.selection];
      if (!c) {
        if (state.gapSelection && state.gapSelection.sizeSlots > 0) {
          setInspectorClosed_(false);
          p.innerHTML = '';
          const msg = document.createElement('div');
          msg.innerHTML = `Gap selected in lane <b>${escapeHtml_(state.gapSelection.laneId)}</b><br>` +
            `Slots: ${state.gapSelection.fromSlot} - ${state.gapSelection.toSlot} (${state.gapSelection.sizeSlots})<br>` +
            `Press <b>Delete</b> or use the button below.`;
          const btnCloseGap = document.createElement('button');
          btnCloseGap.className = 'btn';
          btnCloseGap.textContent = 'Close Gap';
          btnCloseGap.addEventListener('click', () => actions.closeSelectedGap());
          p.appendChild(msg);
          p.appendChild(btnCloseGap);
        } else {
          p.innerHTML = 'Select a card';
        }
        return;
      }
      setInspectorClosed_(false);
      p.innerHTML = '';

      let renderQueued = false;
      const scheduleRender_ = (refreshInspector) => {
        if (renderQueued) return;
        renderQueued = true;
        requestAnimationFrame(() => {
          renderQueued = false;
          render.grid();
          queueAssetInspectorRefresh_();
          if (refreshInspector) ui.renderInspector();
        });
      };

      const edit = state.inspEdit || (state.inspEdit = { active: false, cardId: null, fields: {}, dirty: {}, commitLock: false, isTyping: false, isEditingStart: false, isEditingEnd: false, isEditingTask: false, isTypingStartDate: false, isTypingEndDate: false, isTypingTaskDate: false, needsResyncAfterEdit: false, refs: {}, timers: {}, taskDraft: {}, taskDraftId: '', taskTimers: {} });
      const initEdit_ = () => {
        if (edit.active && String(edit.cardId) === String(c.id)) return;
        clearInspectorTimers_();
        edit.sessionId = (Number(edit.sessionId) || 0) + 1;
        const sVal = utils.slotToDateVal(c.start || 1, 'start');
        const eVal = utils.slotToDateVal(c.end || 1, 'end');
        edit.active = true;
        edit.cardId = c.id;
        edit.fields = {
          startDate: utils.fmtYmdText(sVal.date),
          startSlot: String(sVal.slot),
          endDate: utils.fmtYmdText(eVal.date),
          endSlot: String(eVal.slot),
          memo: c.memo || ''
        };
        edit.dirty = {};
        edit.isTyping = false;
        edit.isEditingStart = false;
        edit.isEditingEnd = false;
        edit.isTypingStartDate = false;
        edit.isTypingEndDate = false;
        edit.needsResyncAfterEdit = false;
        edit.refs = {};
      };
      const isCurrentInspectorCard_ = () => {
        const id = String(c && c.id || '');
        return !!id &&
          String(state.selection || '') === id &&
          String(edit.cardId || '') === id &&
          !!state.cards[id];
      };
      const setField_ = (k, v) => { edit.fields[k] = v; edit.dirty[k] = true; };
      const commitOnce_ = (key, fn) => {
        const now = Date.now();
        if (edit.commitLock && edit.lastCommitKey === key && now - edit.lastCommitTs < 200) return;
        if (edit.commitLock) return;
        edit.commitLock = true;
        edit.lastCommitKey = key;
        edit.lastCommitTs = now;
        fn();
        setTimeout(() => { edit.commitLock = false; }, 0);
      };
      const refreshEditFromCard_ = () => {
        const sVal = utils.slotToDateVal(c.start || 1, 'start');
        const eVal = utils.slotToDateVal(c.end || 1, 'end');
        edit.fields.startDate = utils.fmtYmdText(sVal.date);
        edit.fields.startSlot = String(sVal.slot);
        edit.fields.endDate = utils.fmtYmdText(eVal.date);
        edit.fields.endSlot = String(eVal.slot);
        edit.fields.memo = c.memo || '';
      };
      const syncInputs_ = () => {
        if (!edit.refs) return;
        if (edit.refs.inpStartDate && !edit.isTypingStartDate && document.activeElement !== edit.refs.inpStartDate) edit.refs.inpStartDate.value = edit.fields.startDate || '';
        if (edit.refs.inpStartSlot) edit.refs.inpStartSlot.value = edit.fields.startSlot || '';
        if (edit.refs.inpEndDate && !edit.isTypingEndDate && document.activeElement !== edit.refs.inpEndDate) edit.refs.inpEndDate.value = edit.fields.endDate || '';
        if (edit.refs.inpEndSlot) edit.refs.inpEndSlot.value = edit.fields.endSlot || '';
        if (edit.refs.inpMemo) edit.refs.inpMemo.value = edit.fields.memo || '';
        if (edit.refs.pickStart) {
          const dS = utils.parseDateTextStrict(edit.fields.startDate);
          edit.refs.pickStart.value = dS ? utils.fmtYmdInput(dS) : '';
        }
        if (edit.refs.pickEnd) {
          const dE = utils.parseDateTextStrict(edit.fields.endDate);
          edit.refs.pickEnd.value = dE ? utils.fmtYmdInput(dE) : '';
        }
        if (edit.refs.metaStart) {
          const sRaw = utils.normalizeSlot(c.start, 'start').rawSlot;
          edit.refs.metaStart.textContent = `rawSlot: ${sRaw}`;
        }
        if (edit.refs.metaEnd) {
          const eRaw = utils.normalizeSlot(c.end, 'end').rawSlot;
          edit.refs.metaEnd.textContent = `rawSlot: ${eRaw}`;
        }
      };
      const setDateError_ = (el, msg) => {
        if (!el) return;
        el.textContent = msg || '';
        el.style.display = msg ? 'block' : 'none';
      };
      const setTyping_ = (on) => { edit.isTyping = !!on; };
      const normalizeDateInput_ = (raw) => {
        const d = utils.parseDateTextStrict(raw);
        return d ? utils.fmtYmdText(d) : '';
      };
      initEdit_();
      const inspectorSessionId = Number(edit.sessionId) || 0;

      const getTaskById_ = (id) => state.tasks.find(t => String(t.id || '') === String(id || ''));
      const title = document.createElement('div');
      title.style.cssText = 'background:#222; padding:6px; font-weight:bold; border-radius:4px; display:flex; align-items:center; justify-content:space-between; gap:8px;';
      const titleText = document.createElement('span');
      const cardViewTop = getCardDisplayModel_(c);
      titleText.textContent = cardViewTop.mainText || c.title || '';
      titleText.style.cssText = 'min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;';
      const focusBtn = document.createElement('button');
      focusBtn.type = 'button';
      focusBtn.className = 'btn';
      focusBtn.textContent = 'Focus';
      focusBtn.addEventListener('click', () => {
        if (edit.isTypingStartDate || edit.isTypingEndDate || edit.isEditingStart || edit.isEditingEnd || edit.isTyping) return;
        actions.focusSelected();
      });
      title.appendChild(titleText);
      title.appendChild(focusBtn);
      const headerMeta = document.createElement('div');
      headerMeta.style.cssText = 'display:flex; align-items:center; gap:6px; min-width:0;';
      const cardNo = document.createElement('div');
      cardNo.className = 'info-tag';
      cardNo.style.cssText = 'display:inline-block; font-size:10px; margin-bottom:2px; flex:0 0 auto;';
      const displayId = (c.displayId != null && c.displayId !== '') ? String(c.displayId) : utils.getDisplayId(c.id);
      cardNo.textContent = `CARD NO. ${displayId}`;
      headerMeta.appendChild(cardNo);
      const taskForHeader = c.taskId ? (getTaskById_(c.taskId) || {}) : null;
      if (taskForHeader && Object.keys(taskForHeader).length) {
        const ordVal = getTaskOrderValue_(taskForHeader);
        const ordTag = document.createElement('div');
        ordTag.className = 'info-tag';
        ordTag.style.cssText = 'display:inline-block; font-size:10px; margin-bottom:2px; color:#e5e7eb; border-color:#4b5563; flex:0 0 auto;';
        ordTag.textContent = `ORDER ${isFinite(ordVal) && ordVal < Number.MAX_SAFE_INTEGER ? ordVal : '-'}`;
        headerMeta.appendChild(ordTag);
      }
      if (cardViewTop.subText) {
        const subTag = document.createElement('div');
        subTag.className = 'info-tag';
        subTag.style.cssText = 'display:inline-block; font-size:10px; margin-bottom:2px; color:#aab0ba; border-color:#3a3f49; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;';
        subTag.textContent = cardViewTop.subText;
        headerMeta.appendChild(subTag);
      }
      p.appendChild(headerMeta);
      p.appendChild(title);

      const modeWrap = document.createElement('div');
      modeWrap.style.cssText = 'display:flex; align-items:center; gap:6px; font-size:11px; color:#aaa;';
      const modeLabel = document.createElement('span');
      modeLabel.textContent = 'Inspector fields:';
      const modeSel = document.createElement('select');
      modeSel.className = 'inp';
      modeSel.style.cssText = 'height:24px; padding:2px 6px;';
      modeSel.innerHTML = '<option value="card">Card</option><option value="card+task">Card+Task</option>';
      modeSel.value = state.inspectorFieldsMode || 'card';
      modeSel.addEventListener('change', () => {
        state.inspectorFieldsMode = modeSel.value || 'card';
        try { localStorage.setItem(INSPECTOR_FIELDS_MODE_KEY, state.inspectorFieldsMode); } catch (_) { }
        ui.renderInspector();
      });
      modeWrap.appendChild(modeLabel);
      modeWrap.appendChild(modeSel);
      p.appendChild(modeWrap);

      const extInfo = document.createElement('div');
      extInfo.className = 'info-tag';
      extInfo.style.cssText = 'margin-top:4px; display:none;';
      extInfo.textContent = '';
      p.appendChild(extInfo);
      edit.refs.extIndicator = extInfo;

      const addField = (label, el, metaText, metaKey) => {
        const g = document.createElement('div'); g.className='inp-group';
        const header = document.createElement('div');
        header.style.cssText = 'display:flex; align-items:center; justify-content:space-between; gap:6px;';
        const l = document.createElement('label'); l.textContent=label;
        header.appendChild(l);
        if (metaText !== undefined && metaText !== null && metaText !== '') {
          const meta = document.createElement('span');
          meta.className = 'info-tag';
          meta.style.whiteSpace = 'nowrap';
          meta.style.fontFamily = 'monospace';
          meta.style.flex = '0 0 auto';
          meta.textContent = String(metaText);
          header.appendChild(meta);
          if (metaKey && edit.refs) edit.refs[metaKey] = meta;
        }
        g.style.userSelect = 'text';
        g.appendChild(header);
        g.appendChild(el);
        p.appendChild(g);
      };

      const linkWrap = document.createElement('div');
      linkWrap.style.cssText = 'display:flex; align-items:center; gap:4px; position:relative; flex-wrap:wrap;';
      const dlId = 'task-datalist';
      let dl = document.getElementById(dlId);
      if (!dl) {
        dl = document.createElement('datalist');
        dl.id = dlId;
        document.body.appendChild(dl);
      }
      dl.innerHTML = '';
      state.tasks.forEach(t => {
        if (!t || !t.id) return;
        const op = document.createElement('option');
        op.value = t.id;
        op.label = t.name || t.id;
        dl.appendChild(op);
      });
      const inpTask = document.createElement('input');
      inpTask.className = 'inp';
      inpTask.setAttribute('list', dlId);
      inpTask.value = c.taskId || '';
      edit.refs.inpTask = inpTask;
      const btnLink = document.createElement('a');
      btnLink.innerHTML = '&#8599;';
      btnLink.className = 'btn';
      btnLink.style.cssText = 'padding:4px 8px; text-decoration:none; flex:0 0 auto;';
      btnLink.target = '_blank';
      btnLink.rel = 'noopener';
      edit.refs.taskLinkBtn = btnLink;
      const syncTaskLinkBtn_ = () => {
        const href = buildTaskDetailHref_(c.taskId);
        btnLink.href = href || '#';
      };
      const applyTaskLink_ = (rawTaskId, force) => {
        const nextTaskId = String(rawTaskId || '').trim();
        if (!force && String(c.taskId || '') === nextTaskId) return;
        const prevTaskId = String(c.taskId || '').trim();
        c.taskId = nextTaskId;
        const t = state.tasks.find(x => x.id === c.taskId);
        if (t && t.name) c.title = t.name;
        if (!prevTaskId && t) {
          const estMin = getTaskEstLengthMin_(t);
          const durSlots = Math.max(1, Math.ceil(estMin / Math.max(1, Number(config.slotMin) || 1)));
          c.end = Math.max(c.start, c.start + durSlots - 1);
          c.status = String(t.status || '');
        }
        syncTaskLinkBtn_();
        actions.commit(c.id, 'update');
        ui.renderCardList();
        render.grid();
        queueAssetInspectorRefresh_();
        ui.renderInspector();
      };
      inpTask.addEventListener('change', (e) => applyTaskLink_(e.target.value, true));
      inpTask.addEventListener('input', (e) => {
        const nextVal = String(e.target.value || '').trim();
        if (nextVal && state.tasksById[nextVal]) applyTaskLink_(nextVal, false);
      });
      const taskSuggest = document.createElement('div');
      taskSuggest.className = 'task-suggest-box';
      const hideTaskSuggest_ = () => {
        taskSuggest.style.display = 'none';
      };
      const renderTaskSuggest_ = (keyword) => {
        const q = String(keyword || '').trim().toLowerCase();
        const list = (state.tasks || []).filter((t) => {
          const tid = String(t && t.id || '').toLowerCase();
          const nm = String(t && t.name || '').toLowerCase();
          if (!q) return true;
          return tid.indexOf(q) >= 0 || nm.indexOf(q) >= 0;
        }).slice(0, 120);
        taskSuggest.innerHTML = '';
        if (!list.length) {
          const none = document.createElement('div');
          none.className = 'task-suggest-item';
          none.style.cursor = 'default';
          none.textContent = '(no task)';
          taskSuggest.appendChild(none);
          return;
        }
        list.forEach((t) => {
          const b = document.createElement('button');
          b.type = 'button';
          b.className = 'task-suggest-item';
          b.innerHTML = `<span class="id">${escapeHtml_(String(t.id || ''))}</span><span>${escapeHtml_(String(t.name || t.id || ''))}</span>`;
          b.addEventListener('mousedown', (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            inpTask.value = String(t.id || '');
            applyTaskLink_(t.id, true);
            hideTaskSuggest_();
          });
          taskSuggest.appendChild(b);
        });
      };
      const openTaskSuggest_ = (keyword) => {
        renderTaskSuggest_(keyword);
        taskSuggest.style.display = 'block';
      };
      inpTask.addEventListener('focus', () => openTaskSuggest_(''));
      inpTask.addEventListener('click', () => openTaskSuggest_(''));
      inpTask.addEventListener('input', () => openTaskSuggest_(inpTask.value || ''));
      inpTask.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          hideTaskSuggest_();
          return;
        }
        if (e.key === 'ArrowDown') {
          openTaskSuggest_(inpTask.value || '');
        }
      });
      inpTask.addEventListener('blur', () => setTimeout(hideTaskSuggest_, 120));
      syncTaskLinkBtn_();
      linkWrap.appendChild(inpTask);
      linkWrap.appendChild(btnLink);
      linkWrap.appendChild(taskSuggest);
      addField('Task', linkWrap);

      if (state.inspectorFieldsMode === 'card+task') {
        const taskId = String(c.taskId || '').trim();
        const t = taskId ? (getTaskById_(taskId) || {}) : {};
        const makeTaskTextInput_ = (fid, label, fallbackKeys, readOnly, typeHint) => {
          const inp = document.createElement('input');
          inp.className = 'inp';
          inp.readOnly = !!readOnly;
          if (typeHint === 'number') inp.inputMode = 'numeric';
          inp.value = String(taskRawValue_(t, fid, fallbackKeys) || '').trim();
          if (!readOnly && taskId) {
            inp.addEventListener('blur', () => {
              const next = String(inp.value || '').trim();
              const patch = {};
              patch[fid] = next;
              commitTaskPatchFromInspector_(taskId, patch, () => ui.renderInspector());
            });
            inp.addEventListener('keydown', (ev) => {
              if (ev.key === 'Enter') {
                ev.preventDefault();
                inp.blur();
              }
            });
          }
          addField(label, inp);
          return inp;
        };

        const taskName = document.createElement('input');
        taskName.className = 'inp';
        taskName.readOnly = true;
        taskName.value = String(t.name || '');
        edit.refs.taskName = taskName;
        addField('Task Name', taskName);

        const statusWrap = document.createElement('div');
        statusWrap.style.cssText = 'display:flex; align-items:center; gap:6px;';
        const taskStatusSel = document.createElement('select');
        taskStatusSel.className = 'inp';
        taskStatusSel.style.maxWidth = '220px';
        taskStatusSel.innerHTML = TASK_STATUS_OPTIONS.map((s) => `<option value="${s}">${s}</option>`).join('');
        taskStatusSel.value = normalizeTaskStatus_(taskRawValue_(t, TASK_FIDS.status, ['status'])) || 'not_started';
        const statusPill = document.createElement('div');
        statusPill.className = 'status-pill ' + normalizeTaskStatus_(taskStatusSel.value || '');
        statusPill.textContent = String(taskStatusSel.value || '').replace(/_/g, ' ');
        taskStatusSel.addEventListener('change', () => {
          if (!taskId) return;
          const next = normalizeTaskStatus_(taskStatusSel.value);
          const patch = {};
          patch[TASK_FIDS.status] = next;
          commitTaskPatchFromInspector_(taskId, patch, () => {
            taskStatusSel.value = next || 'not_started';
            statusPill.className = 'status-pill ' + (next || '');
            statusPill.textContent = String(next || '').replace(/_/g, ' ');
            ui.renderInspector();
          });
        });
        statusWrap.appendChild(taskStatusSel);
        statusWrap.appendChild(statusPill);
        edit.refs.taskStatus = taskStatusSel;
        addField('Status', statusWrap);

        const cameraWrap = document.createElement('label');
        cameraWrap.style.cssText = 'display:flex; align-items:center; gap:8px; font-size:11px; color:#d1d5db;';
        const cameraChk = document.createElement('input');
        cameraChk.type = 'checkbox';
        cameraChk.title = 'Camera movement';
        cameraChk.checked = taskBoolValue_(t, TASK_FIDS.cameraMovement, ['cameraMovement', 'camera_movement']);
        cameraChk.addEventListener('change', () => {
          if (!taskId) return;
          const patch = {};
          patch[TASK_FIDS.cameraMovement] = cameraChk.checked ? 'TRUE' : 'FALSE';
          commitTaskPatchFromInspector_(taskId, patch, () => ui.renderInspector());
        });
        cameraWrap.appendChild(cameraChk);
        addField('Camera movement', cameraWrap);

        edit.refs.taskStillShot = makeTaskTextInput_(TASK_FIDS.stillShot, 'Still Shot', ['stillShot', 'still_shot'], false, 'number');
        edit.refs.taskTravel = makeTaskTextInput_(TASK_FIDS.travelChars, 'Travel Characters', ['travelChars', 'travel_characters'], false, 'number');
        edit.refs.taskNoTravel = makeTaskTextInput_(TASK_FIDS.noTravelChars, 'No-Travel Characters', ['noTravelChars', 'no_travel_characters'], false, 'number');
        edit.refs.taskShootFps = makeTaskTextInput_(TASK_FIDS.shootingFps, 'Shooting fps', ['shootingFps', 'shooting_fps'], false, 'number');
        edit.refs.taskDifficulty = makeTaskTextInput_(TASK_FIDS.difficultyFactor, 'difficulty_factor', ['difficultyFactor', 'difficulty_factor'], false, 'number');
        edit.refs.taskShootFrames = makeTaskTextInput_(TASK_FIDS.shootingFrames, 'shooting_frames', ['shootingFrames', 'shooting_frames'], true);
        edit.refs.taskEstLength = makeTaskTextInput_(TASK_FIDS.estLength, 'Est length (mins)', ['estLength', 'est_length'], true);
        if (edit.refs.taskEstLength) edit.refs.taskEstLength.value = formatMinutesLabel_(taskRawValue_(t, TASK_FIDS.estLength, ['estLength', 'est_length']));
        const finishedInput = document.createElement('input');
        finishedInput.className = 'inp';
        finishedInput.type = 'date';
        finishedInput.value = parseFinishedDateForInput_(taskRawValue_(t, TASK_FIDS.finished, ['finished']));
        if (taskId) {
          finishedInput.addEventListener('change', () => {
            const next = String(finishedInput.value || '').trim();
            const patch = {};
            patch[TASK_FIDS.finished] = next;
            commitTaskPatchFromInspector_(taskId, patch, () => ui.renderInspector());
          });
        } else {
          finishedInput.disabled = true;
        }
        edit.refs.taskFinished = finishedInput;
        addField('finished', finishedInput);

        edit.refs.taskSpentLength = makeTaskTextInput_(TASK_FIDS.spentLength, 'Spent length (mins)', ['spentLength', 'spent_length'], true, 'number');
        if (edit.refs.taskSpentLength) {
          const spentRaw = taskRawValue_(t, TASK_FIDS.spentLength, ['spentLength', 'spent_length']);
          const spentNum = parseSpentMinutesValue_(spentRaw);
          edit.refs.taskSpentLength.value = isFinite(spentNum) && spentNum > 0 ? String(Math.round(spentNum)) : '';
        }
        edit.refs.taskOverrun = makeTaskTextInput_(TASK_FIDS.overrunRatio, 'Overrun Ratio (%)', ['overrunRatio', 'overrun_ratio'], true);
        if (edit.refs.taskOverrun) {
          const overrunRaw = taskRawValue_(t, TASK_FIDS.overrunRatio, ['overrunRatio', 'overrun_ratio']);
          const overrunNum = parseOverrunRatioValue_(overrunRaw);
          edit.refs.taskOverrun.value = isFinite(overrunNum) ? String(overrunNum) : '';
        }

        const taskOrder = document.createElement('input');
        taskOrder.className = 'inp';
        taskOrder.inputMode = 'numeric';
        taskOrder.value = String(taskRawValue_(t, TASK_FIDS.taskOrder, ['taskOrder', 'order']) || '').trim();
        if (taskId) {
          const commitTaskOrder_ = () => {
            const raw = String(taskOrder.value || '').trim();
            const next = raw ? String(Math.max(1, Math.round(Number(raw) || 1))) : '';
            const patch = {};
            patch[TASK_FIDS.taskOrder] = next;
            commitTaskPatchFromInspector_(taskId, patch, () => ui.renderInspector());
          };
          taskOrder.addEventListener('blur', commitTaskOrder_);
          taskOrder.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter') {
              ev.preventDefault();
              taskOrder.blur();
            }
          });
        } else {
          taskOrder.disabled = true;
        }
        edit.refs.taskOrder = taskOrder;
        addField('task Order', taskOrder);
      }

      const gStart = document.createElement('div');
      gStart.style.cssText = 'display:flex; gap:4px; align-items:flex-start;';
      const gStartDate = document.createElement('div');
      gStartDate.style.cssText = 'display:flex; flex-direction:column; gap:2px; flex:1 1 auto;';
      const gStartRow = document.createElement('div');
      gStartRow.style.cssText = 'display:flex; gap:4px; align-items:center;';
      const startWrap = document.createElement('div');
      startWrap.className = 'date-wrap';
      const inpSD = document.createElement('input');
      inpSD.type = 'text'; inpSD.className = 'inp';
      inpSD.placeholder = 'YYYY/MM/DD';
      inpSD.autocomplete = 'off';
      inpSD.value = edit.fields.startDate || '';
      const pickSD = document.createElement('input');
      pickSD.type = 'date';
      pickSD.className = 'date-picker-overlay';
      pickSD.tabIndex = -1;
      const pickSDInit = utils.parseDateTextStrict(edit.fields.startDate);
      pickSD.value = pickSDInit ? utils.fmtYmdInput(pickSDInit) : '';
      const errSD = document.createElement('div');
      errSD.style.cssText = 'color:#ef4444; font-size:10px; display:none;';
      const inpSS = document.createElement('input');
      inpSS.type = 'number'; inpSS.className = 'inp';
      inpSS.style.width = '60px';
      inpSS.value = edit.fields.startSlot || '';
      const rawLen = (c.end != null && c.start != null) ? (Math.max(1, c.end - c.start + 1) * config.slotMin) : '';
      const sSlotsPerDay = getSlotsPerDay_();
      if (isFinite(sSlotsPerDay)) {
        inpSS.min = '1';
        inpSS.max = String(Math.max(1, sSlotsPerDay));
      }
      const applyStart_ = () => commitOnce_('start', () => {
        if ((Number(edit.sessionId) || 0) !== inspectorSessionId) return;
        if (!isCurrentInspectorCard_()) return;
        const d = utils.parseDateTextStrict(edit.fields.startDate);
        if (!d) {
          setDateError_(errSD, 'Invalid date');
          setTyping_(false);
          return;
        }
        setDateError_(errSD, '');
        edit.isTypingStartDate = false;
        withCommitOp_('inspector_start', () => {
          const dateStr = formatYmd_(d);
          const newStart = utils.dateValToSlot(dateStr, edit.fields.startSlot, 'start');
          const len = c.end - c.start + 1;
          c.start = newStart;
          c.end = newStart + len - 1;
          actions.resolveCollisions(c);
          actions.commit(c.id, 'update');
        });
        edit.fields.startDate = utils.fmtYmdText(d);
        refreshEditFromCard_();
        syncInputs_();
        edit.isEditingStart = false;
        edit.needsResyncAfterEdit = false;
        if (edit.refs.extIndicator) { edit.refs.extIndicator.textContent = ''; edit.refs.extIndicator.style.display = 'none'; }
        setTyping_(false);
        scheduleRender_(false);
      });
      inpSD.addEventListener('focus', () => { edit.isEditingStart = true; edit.isTypingStartDate = true; setTyping_(true); if (edit.timers.start) clearTimeout(edit.timers.start); });
      inpSS.addEventListener('focus', () => { edit.isEditingStart = true; setTyping_(true); if (edit.timers.start) clearTimeout(edit.timers.start); });
      inpSD.addEventListener('paste', (e) => {
        const text = (e.clipboardData && e.clipboardData.getData('text')) ? e.clipboardData.getData('text') : '';
        if (text) {
          const norm = normalizeDateInput_(text);
          if (norm) {
            e.preventDefault();
            inpSD.value = norm;
            setField_('startDate', norm);
            setDateError_(errSD, '');
          }
        }
      });
      inpSD.addEventListener('input', (e) => {
        setField_('startDate', e.target.value);
        if (!e.target.value || utils.parseDateTextStrict(e.target.value)) setDateError_(errSD, '');
        edit.isTypingStartDate = true;
      });
      inpSS.addEventListener('input', (e) => setField_('startSlot', e.target.value));
      inpSD.addEventListener('blur', () => {
        edit.isEditingStart = false;
        edit.isTypingStartDate = false;
        const cardIdAtQueue = String(c.id || '');
        edit.timers.start = setTimeout(() => {
          if (!edit.isEditingStart && isCurrentInspectorCard_() && String(c.id || '') === cardIdAtQueue) applyStart_();
        }, 120);
      });
      inpSS.addEventListener('blur', () => {
        edit.isEditingStart = false;
        const cardIdAtQueue = String(c.id || '');
        edit.timers.start = setTimeout(() => {
          if (!edit.isEditingStart && isCurrentInspectorCard_() && String(c.id || '') === cardIdAtQueue) applyStart_();
        }, 120);
      });
      inpSD.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); edit.isEditingStart = false; applyStart_(); } });
      inpSS.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); edit.isEditingStart = false; applyStart_(); } });
      pickSD.addEventListener('change', () => {
        if (!pickSD.value) return;
        const d = utils.parseDateTextStrict(pickSD.value);
        if (!d) return;
        const t = utils.fmtYmdText(d);
        inpSD.value = t;
        setField_('startDate', t);
        setDateError_(errSD, '');
        edit.isTypingStartDate = false;
        applyStart_();
      });
      startWrap.appendChild(inpSD);
      startWrap.appendChild(pickSD);
      gStartRow.appendChild(startWrap);
      gStartDate.appendChild(gStartRow);
      gStartDate.appendChild(errSD);
      gStart.appendChild(gStartDate);
      gStart.appendChild(inpSS);
      edit.refs.inpStartDate = inpSD;
      edit.refs.inpStartSlot = inpSS;
      edit.refs.errStartDate = errSD;
      edit.refs.pickStart = pickSD;
      addField('Start (Date/Slot)', gStart, `rawSlot: ${utils.normalizeSlot(c.start, 'start').rawSlot}`, 'metaStart');

      const gEnd = document.createElement('div');
      gEnd.style.cssText = 'display:flex; gap:4px; align-items:flex-start;';
      const gEndDate = document.createElement('div');
      gEndDate.style.cssText = 'display:flex; flex-direction:column; gap:2px; flex:1 1 auto;';
      const gEndRow = document.createElement('div');
      gEndRow.style.cssText = 'display:flex; gap:4px; align-items:center;';
      const endWrap = document.createElement('div');
      endWrap.className = 'date-wrap';
      const inpED = document.createElement('input');
      inpED.type = 'text'; inpED.className = 'inp';
      inpED.placeholder = 'YYYY/MM/DD';
      inpED.autocomplete = 'off';
      inpED.value = edit.fields.endDate || '';
      const pickED = document.createElement('input');
      pickED.type = 'date';
      pickED.className = 'date-picker-overlay';
      pickED.tabIndex = -1;
      const pickEDInit = utils.parseDateTextStrict(edit.fields.endDate);
      pickED.value = pickEDInit ? utils.fmtYmdInput(pickEDInit) : '';
      const errED = document.createElement('div');
      errED.style.cssText = 'color:#ef4444; font-size:10px; display:none;';
      const inpES = document.createElement('input');
      inpES.type = 'number'; inpES.className = 'inp';
      inpES.style.width = '60px';
      inpES.value = edit.fields.endSlot || '';
      const eSlotsPerDay = getSlotsPerDay_();
      if (isFinite(eSlotsPerDay)) {
        inpES.min = '1';
        inpES.max = String(eSlotsPerDay);
      }
      const applyEnd_ = () => commitOnce_('end', () => {
        if ((Number(edit.sessionId) || 0) !== inspectorSessionId) return;
        if (!isCurrentInspectorCard_()) return;
        const slotsPerDay = getSlotsPerDay_();
        let slotNum = Number(edit.fields.endSlot);
        const d0 = utils.parseDateTextStrict(edit.fields.endDate);
        if (!d0) {
          setDateError_(errED, 'Invalid date');
          setTyping_(false);
          return;
        }
        setDateError_(errED, '');
        edit.isTypingEndDate = false;
        withCommitOp_('inspector_end', () => {
          let dateStr = formatYmd_(d0);
          if (!isFinite(slotNum)) slotNum = slotsPerDay;
          if (slotNum <= 0) {
            slotNum = slotsPerDay;
            const d = utils.parseDateTime(dateStr);
            if (d && !isNaN(d)) {
              d.setHours(0,0,0,0);
              const adj = utils.adjustWeekend(d, 'end');
              const prev = utils.shiftWorkdays(adj, -1);
              dateStr = formatYmd_(prev);
            }
          }
          const newEnd = utils.dateValToSlot(dateStr, slotNum, 'end');
          c.end = Math.max(c.start, newEnd);
          actions.resolveCollisions(c);
          actions.commit(c.id, 'update');
        });
        edit.fields.endDate = utils.fmtYmdText(d0);
        refreshEditFromCard_();
        syncInputs_();
        edit.isEditingEnd = false;
        edit.needsResyncAfterEdit = false;
        if (edit.refs.extIndicator) { edit.refs.extIndicator.textContent = ''; edit.refs.extIndicator.style.display = 'none'; }
        setTyping_(false);
        scheduleRender_(false);
      });
      inpED.addEventListener('focus', () => { edit.isEditingEnd = true; edit.isTypingEndDate = true; setTyping_(true); if (edit.timers.end) clearTimeout(edit.timers.end); });
      inpES.addEventListener('focus', () => { edit.isEditingEnd = true; setTyping_(true); if (edit.timers.end) clearTimeout(edit.timers.end); });
      inpED.addEventListener('paste', (e) => {
        const text = (e.clipboardData && e.clipboardData.getData('text')) ? e.clipboardData.getData('text') : '';
        if (text) {
          const norm = normalizeDateInput_(text);
          if (norm) {
            e.preventDefault();
            inpED.value = norm;
            setField_('endDate', norm);
            setDateError_(errED, '');
          }
        }
      });
      inpED.addEventListener('input', (e) => {
        setField_('endDate', e.target.value);
        if (!e.target.value || utils.parseDateTextStrict(e.target.value)) setDateError_(errED, '');
        edit.isTypingEndDate = true;
      });
      inpES.addEventListener('input', (e) => setField_('endSlot', e.target.value));
      inpED.addEventListener('blur', () => {
        edit.isEditingEnd = false;
        edit.isTypingEndDate = false;
        const cardIdAtQueue = String(c.id || '');
        edit.timers.end = setTimeout(() => {
          if (!edit.isEditingEnd && isCurrentInspectorCard_() && String(c.id || '') === cardIdAtQueue) applyEnd_();
        }, 120);
      });
      inpES.addEventListener('blur', () => {
        edit.isEditingEnd = false;
        const cardIdAtQueue = String(c.id || '');
        edit.timers.end = setTimeout(() => {
          if (!edit.isEditingEnd && isCurrentInspectorCard_() && String(c.id || '') === cardIdAtQueue) applyEnd_();
        }, 120);
      });
      inpED.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); edit.isEditingEnd = false; applyEnd_(); } });
      inpES.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); edit.isEditingEnd = false; applyEnd_(); } });
      pickED.addEventListener('change', () => {
        if (!pickED.value) return;
        const d = utils.parseDateTextStrict(pickED.value);
        if (!d) return;
        const t = utils.fmtYmdText(d);
        inpED.value = t;
        setField_('endDate', t);
        setDateError_(errED, '');
        edit.isTypingEndDate = false;
        applyEnd_();
      });
      endWrap.appendChild(inpED);
      endWrap.appendChild(pickED);
      gEndRow.appendChild(endWrap);
      gEndDate.appendChild(gEndRow);
      gEndDate.appendChild(errED);
      gEnd.appendChild(gEndDate);
      gEnd.appendChild(inpES);
      edit.refs.inpEndDate = inpED;
      edit.refs.inpEndSlot = inpES;
      edit.refs.errEndDate = errED;
      edit.refs.pickEnd = pickED;
      addField('End (Date/Slot)', gEnd, `rawSlot: ${utils.normalizeSlot(c.end, 'end').rawSlot}`, 'metaEnd');

      const lenBox = document.createElement('div');
      lenBox.className = 'inp';
      lenBox.style.cssText = 'font-family:ui-monospace, SFMono-Regular, Menlo, monospace;';
      lenBox.textContent = `${rawLen !== '' ? rawLen : 0}mins`;
      edit.refs.lenBox = lenBox;
      addField('Length', lenBox);

      const selLane = document.createElement('select'); selLane.className='inp';
      store.getLanes().forEach(l => {
        const o = document.createElement('option'); o.value = l.id; o.textContent = l.label;
        if (l.id === c.laneId) o.selected = true;
        selLane.appendChild(o);
      });
      selLane.addEventListener('change', (e) => {
        c.laneId = e.target.value;
        render.grid();
        ui.renderCardList();
        actions.commit(c.id, 'update');
        ui.refreshInspectorValuesFromCard();
        queueAssetInspectorRefresh_();
      });
      edit.refs.selLane = selLane;
      addField('Lane', selLane);

      const txtMemo = document.createElement('textarea'); txtMemo.className='inp';
      txtMemo.value = edit.fields.memo || '';
      txtMemo.addEventListener('focus', () => setTyping_(true));
      txtMemo.addEventListener('input', (e) => setField_('memo', e.target.value));
      txtMemo.addEventListener('blur', () => commitOnce_('memo', () => {
        if ((Number(edit.sessionId) || 0) !== inspectorSessionId) return;
        c.memo = edit.fields.memo || '';
        actions.commit(c.id, 'update');
        refreshEditFromCard_();
        syncInputs_();
        setTyping_(false);
      }));
      edit.refs.inpMemo = txtMemo;
      addField('Memo', txtMemo);

      const taskAssetIds = getTaskAssetIds_(c.taskId);
      const taskAssetText = taskAssetIds.length
        ? taskAssetIds.map(getAssetLabel_).join(', ')
        : '';
      const assetSummaryEl = document.createElement('div');
      assetSummaryEl.className = 'inp';
      assetSummaryEl.style.cssText = 'min-height:30px; white-space:normal; line-height:1.3;';
      assetSummaryEl.textContent = taskAssetText || '(none)';
      addField('Task Assets', assetSummaryEl);

      const cardAssetConflict = state.cardAssetConflictById[String(c.id)] || null;
      const overAssetCount = (cardAssetConflict && Array.isArray(cardAssetConflict.assetIds))
        ? cardAssetConflict.assetIds.length
        : 0;
      const conflictText = (overAssetCount > 0)
        ? (`OVER CAPACITY: ${overAssetCount} asset(s)`)
        : 'OK';
      const conflictEl = document.createElement('div');
      conflictEl.className = 'info-tag';
      conflictEl.style.cssText = 'display:inline-block; font-family:monospace;';
      if (overAssetCount > 0) {
        conflictEl.style.color = '#fecaca';
        conflictEl.style.borderColor = '#ef4444';
      }
      conflictEl.textContent = conflictText;
      addField('Asset Overlap', conflictEl);
    },
    refreshInspectorValuesFromCard: () => {
      const edit = state.inspEdit;
      const c = state.cards[state.selection];
      if (!edit || !edit.refs || !c) return;
      if (edit.isTyping || edit.isEditingStart || edit.isEditingEnd || edit.isEditingTask || edit.isTypingStartDate || edit.isTypingEndDate || edit.isTypingTaskDate) {
        edit.needsResyncAfterEdit = true;
        if (edit.refs.extIndicator) {
          edit.refs.extIndicator.textContent = 'Changed externally';
          edit.refs.extIndicator.style.display = 'inline-block';
        }
        return;
      }
      const sVal = utils.slotToDateVal(c.start || 1, 'start');
      const eVal = utils.slotToDateVal(c.end || 1, 'end');
      edit.fields.startDate = utils.fmtYmdText(sVal.date);
      edit.fields.startSlot = String(sVal.slot);
      edit.fields.endDate = utils.fmtYmdText(eVal.date);
      edit.fields.endSlot = String(eVal.slot);
      edit.fields.memo = c.memo || '';
      if (edit.refs.inpStartDate) edit.refs.inpStartDate.value = edit.fields.startDate || '';
      if (edit.refs.inpStartSlot) edit.refs.inpStartSlot.value = edit.fields.startSlot || '';
      if (edit.refs.inpEndDate) edit.refs.inpEndDate.value = edit.fields.endDate || '';
      if (edit.refs.inpEndSlot) edit.refs.inpEndSlot.value = edit.fields.endSlot || '';
      if (edit.refs.inpMemo) edit.refs.inpMemo.value = edit.fields.memo || '';
      if (edit.refs.inpTask) edit.refs.inpTask.value = String(c.taskId || '');
      if (edit.refs.taskLinkBtn) {
        edit.refs.taskLinkBtn.href = buildTaskDetailHref_(c.taskId);
      }
      if (edit.refs.pickStart) edit.refs.pickStart.value = utils.fmtYmdInput(sVal.date);
      if (edit.refs.pickEnd) edit.refs.pickEnd.value = utils.fmtYmdInput(eVal.date);
      const t = c.taskId ? (state.tasks.find(x => String(x.id || '') === String(c.taskId)) || {}) : {};
      if (edit.refs.taskName) edit.refs.taskName.value = String(t.name || '');
      if (edit.refs.taskStatus) edit.refs.taskStatus.value = normalizeTaskStatus_(taskRawValue_(t, TASK_FIDS.status, ['status'])) || 'not_started';
      if (edit.refs.taskAssignee) edit.refs.taskAssignee.value = String(t.assignee || '');
      if (edit.refs.taskPlanStart) edit.refs.taskPlanStart.value = fmtTaskDateForInspector_(t.planStart);
      if (edit.refs.taskPlanEnd) edit.refs.taskPlanEnd.value = fmtTaskDateForInspector_(t.planEnd);
      if (edit.refs.taskStillShot) edit.refs.taskStillShot.value = String(taskRawValue_(t, TASK_FIDS.stillShot, ['stillShot', 'still_shot']) || '');
      if (edit.refs.taskTravel) edit.refs.taskTravel.value = String(taskRawValue_(t, TASK_FIDS.travelChars, ['travelChars', 'travel_characters']) || '');
      if (edit.refs.taskNoTravel) edit.refs.taskNoTravel.value = String(taskRawValue_(t, TASK_FIDS.noTravelChars, ['noTravelChars', 'no_travel_characters']) || '');
      if (edit.refs.taskShootFps) edit.refs.taskShootFps.value = String(taskRawValue_(t, TASK_FIDS.shootingFps, ['shootingFps', 'shooting_fps']) || '');
      if (edit.refs.taskDifficulty) edit.refs.taskDifficulty.value = String(taskRawValue_(t, TASK_FIDS.difficultyFactor, ['difficultyFactor', 'difficulty_factor']) || '');
      if (edit.refs.taskShootFrames) edit.refs.taskShootFrames.value = String(taskRawValue_(t, TASK_FIDS.shootingFrames, ['shootingFrames', 'shooting_frames']) || '');
      if (edit.refs.taskEstLength) edit.refs.taskEstLength.value = formatMinutesLabel_(taskRawValue_(t, TASK_FIDS.estLength, ['estLength', 'est_length']));
      if (edit.refs.taskFinished) edit.refs.taskFinished.value = parseFinishedDateForInput_(taskRawValue_(t, TASK_FIDS.finished, ['finished']));
      if (edit.refs.taskSpentLength) {
        const spentRaw = taskRawValue_(t, TASK_FIDS.spentLength, ['spentLength', 'spent_length']);
        const spentNum = parseSpentMinutesValue_(spentRaw);
        edit.refs.taskSpentLength.value = isFinite(spentNum) && spentNum > 0 ? String(Math.round(spentNum)) : '';
      }
      if (edit.refs.taskOverrun) {
        const overrunRaw = taskRawValue_(t, TASK_FIDS.overrunRatio, ['overrunRatio', 'overrun_ratio']);
        const overrunNum = parseOverrunRatioValue_(overrunRaw);
        edit.refs.taskOverrun.value = isFinite(overrunNum) ? String(overrunNum) : '';
      }
      if (edit.refs.taskOrder) edit.refs.taskOrder.value = String(taskRawValue_(t, TASK_FIDS.taskOrder, ['taskOrder', 'order']) || '');
      if (edit.refs.metaStart) edit.refs.metaStart.textContent = `rawSlot: ${utils.normalizeSlot(c.start, 'start').rawSlot}`;
      if (edit.refs.metaEnd) edit.refs.metaEnd.textContent = `rawSlot: ${utils.normalizeSlot(c.end, 'end').rawSlot}`;
      if (edit.refs.lenBox) {
        const liveLen = Math.max(1, Number(c.end) - Number(c.start) + 1) * config.slotMin;
        edit.refs.lenBox.textContent = `${isFinite(liveLen) ? liveLen : 0}mins`;
      }
      if (edit.refs.selLane) edit.refs.selLane.value = String(c.laneId || '');
      edit.needsResyncAfterEdit = false;
      if (edit.refs.extIndicator) {
        edit.refs.extIndicator.textContent = '';
        edit.refs.extIndicator.style.display = 'none';
      }
    }
  };

  let drag = null;
  let dragPreviewNode = null;
  let dragPreviewLineNode = null;

  function clearDragPreviewNodes_() {
    if (dragPreviewNode && dragPreviewNode.parentNode) dragPreviewNode.parentNode.removeChild(dragPreviewNode);
    if (dragPreviewLineNode && dragPreviewLineNode.parentNode) dragPreviewLineNode.parentNode.removeChild(dragPreviewLineNode);
    dragPreviewNode = null;
    dragPreviewLineNode = null;
    state.dragPreview = null;
  }

  function renderDragPreviewNodes_(preview) {
    if (!els.canvas) return;
    if (!preview || !preview.laneId || !isFinite(Number(preview.start)) || !isFinite(Number(preview.end))) {
      clearDragPreviewNodes_();
      return;
    }
    setDragPreview_(preview);
    const p = state.dragPreview;
    if (!p) {
      clearDragPreviewNodes_();
      return;
    }
    const lanes = state.lanes.filter((l) => l.visible);
    const laneIdx = lanes.findIndex((l) => String(l.id || '') === String(p.laneId || ''));
    const rect = slotRectForRawRange_(p.start, p.end, getPxPerDay_());
    if (laneIdx < 0 || !rect) {
      clearDragPreviewNodes_();
      return;
    }
    const laneWidth = getLaneWidth_();
    const left = (laneIdx * laneWidth) + 4;
    const modeClass = (p.mode === 'resize') ? 'resize' : (p.mode === 'block' ? 'block' : 'move');
    if (!dragPreviewNode) {
      dragPreviewNode = document.createElement('div');
      els.canvas.appendChild(dragPreviewNode);
    }
    if (!dragPreviewLineNode) {
      dragPreviewLineNode = document.createElement('div');
      els.canvas.appendChild(dragPreviewLineNode);
    }
    dragPreviewNode.className = 'drag-preview ' + modeClass;
    dragPreviewNode.style.left = left + 'px';
    dragPreviewNode.style.top = rect.top + 'px';
    dragPreviewNode.style.height = Math.max(8, rect.height - 1) + 'px';
    dragPreviewLineNode.className = 'drop-slot-line ' + modeClass;
    dragPreviewLineNode.style.left = left + 'px';
    dragPreviewLineNode.style.top = Math.max(0, rect.top - 1) + 'px';
  }

  function pointerToCanvas_(clientX, clientY) {
    const rect = els.canvas.getBoundingClientRect();
    const scrollX = els.gridScroll ? els.gridScroll.scrollLeft : 0;
    const scrollY = els.gridScroll ? els.gridScroll.scrollTop : 0;
    return {
      x: (clientX - rect.left) + scrollX,
      y: (clientY - rect.top) + scrollY
    };
  }

  function dragStart(e, card, el) {
    if (state.viewMode === 'lite') {
      e.preventDefault();
      e.stopPropagation();
      actions.selectCard(card && card.id);
      return;
    }
    if (state.timezoneBlocked) {
      e.preventDefault();
      e.stopPropagation();
      ensureTimezoneReady_();
      return;
    }
    if (state.undoBusy) {
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    if (e.target.classList.contains('card-close')) return;
    const isResizing = e.target.classList.contains('card-resizer');
    if (!isResizing && (e.metaKey || e.ctrlKey)) {
      e.preventDefault();
      e.stopPropagation();
      actions.toggleMultiSelection(card.id, { shiftKey: !!e.shiftKey, contiguous: true });
      actions.selectCard(card.id, { focus: false });
      state.suppressCanvasPickUntil = Date.now() + 250;
      return;
    }
    e.stopPropagation();
    e.preventDefault();
    const block = (!isResizing) ? buildDragBlockForCard_(card.id) : null;
    drag = {
      card,
      el,
      startY: e.clientY,
      startX: e.clientX,
      startTop: parseFloat(el.style.top),
      startHeight: parseFloat(el.style.height),
      isResizing,
      isBlockMove: !!block,
      block: block,
      didMove: false
    };
    clearDragPreviewNodes_();
    document.addEventListener('mousemove', dragMove);
    document.addEventListener('mouseup', dragEnd);
  }

  function dragMove(e) {
    if (state.timezoneBlocked) return;
    if (!drag || state.undoBusy) return;
    const dy = e.clientY - drag.startY;
    const dx = e.clientX - drag.startX;
    if (!drag.didMove && (Math.abs(dy) > 6 || Math.abs(dx) > 6)) drag.didMove = true;
    if (!drag.didMove) return;
    const pxPerDay = getPxPerDay_();
    if (drag.isResizing) {
      const nextHeight = Math.max(6, drag.startHeight + dy);
      drag.el.style.height = nextHeight + 'px';
      const top = parseFloat(drag.el.style.top);
      const pt = pointerToCanvas_(e.clientX, e.clientY);
      const dropTarget = resolveDropTargetFromCanvas_(pt.x, top);
      if (dropTarget) {
        const snap = dropTarget.snapState.snap;
        const hRatio = nextHeight / pxPerDay;
        const durMins = hRatio * (config.workHours * 60);
        let snappedDur = Math.round(durMins / snap.min) * snap.min;
        if (snappedDur < snap.min) snappedDur = snap.min;
        const slots = Math.max(1, Math.round(snappedDur / config.slotMin));
        const previewStart = Math.max(1, Math.round(Number(drag.card.start) || 1));
        const previewEnd = previewStart + slots - 1;
        renderDragPreviewNodes_({
          laneId: String(drag.card.laneId || ''),
          start: previewStart,
          end: previewEnd,
          mode: 'resize'
        });
      } else {
        clearDragPreviewNodes_();
      }
      return;
    }

    const top = drag.startTop + dy;
    drag.el.style.top = top + 'px';
    drag.el.style.transform = 'translateX(' + dx + 'px)';
    const pt = pointerToCanvas_(e.clientX, e.clientY);
    const dropTarget = resolveDropTargetFromCanvas_(pt.x, top);
    if (!dropTarget) {
      clearDragPreviewNodes_();
      return;
    }
    const newStart = dropTarget.newStart;
    const newLane = dropTarget.newLane || drag.card.laneId;
    if (drag.isBlockMove && drag.block) {
      var blockStartRaw = Math.max(1, Math.round(Number(newStart) || 1) - Math.max(0, Math.round(Number(drag.block.anchorRelStart) || 0)));
      var blockStart = resolveInsertStartByEarlyCards_(String(newLane || drag.block.laneId || ''), blockStartRaw, drag.block.ids);
      renderDragPreviewNodes_({
        laneId: String(newLane || drag.block.laneId || ''),
        start: blockStart,
        end: blockStart + drag.block.spanSlots - 1,
        mode: 'block'
      });
      return;
    }
    const len = getCardLengthSlots_(drag.card);
    const previewStart = resolveInsertStartByEarlyCards_(String(newLane || drag.card.laneId || ''), newStart, [drag.card.id]);
    renderDragPreviewNodes_({
      laneId: String(newLane || drag.card.laneId || ''),
      start: previewStart,
      end: previewStart + len - 1,
      mode: 'move'
    });
  }

  function dragEnd(e) {
    document.removeEventListener('mousemove', dragMove);
    document.removeEventListener('mouseup', dragEnd);
    if (!drag) return;
    if (state.timezoneBlocked) {
      render.grid();
      drag = null;
      return;
    }
    if (state.undoBusy) {
      render.grid();
      drag = null;
      return;
    }
    if (drag.el) drag.el.style.transform = '';
    clearDragPreviewNodes_();
    if (!drag.didMove) {
      state.suppressCanvasPickUntil = Date.now() + 250;
      const hasMulti = Array.isArray(state.multiSelection) && state.multiSelection.length > 1;
      const clickedInMulti = hasMulti && state.multiSelection.indexOf(String(drag.card && drag.card.id || '')) >= 0;
      if ((drag.isBlockMove && drag.block && hasMulti) || clickedInMulti) {
        actions.selectCard(drag.card.id, { focus: false, clearMulti: false });
      } else {
        actions.selectCard(drag.card.id, { focus: false, clearMulti: true });
      }
      drag = null;
      return;
    }
    const top = parseFloat(drag.el.style.top);
    const h = parseFloat(drag.el.style.height);
    const pt = pointerToCanvas_(e.clientX, e.clientY);
    const dropTarget = resolveDropTargetFromCanvas_(pt.x, top);
    state.suppressCanvasPickUntil = Date.now() + 250;
    if (!dropTarget) {
      render.grid();
      ui.refreshInspectorValuesFromCard();
      drag = null;
      return;
    }
    const newStart = dropTarget.newStart;
    const newLane = dropTarget.newLane || drag.card.laneId;
    const snap = dropTarget.snapState.snap;
    if (!(state.assetCellSelection && isFinite(Number(state.assetCellSelection.rawStart)))) {
      state.selection = drag.card.id;
    }
    if (drag.isResizing) {
      const pxPerDay = getPxPerDay_();
      const hRatio = h / pxPerDay;
      const durMins = hRatio * (config.workHours * 60);
      let snappedDur = Math.round(durMins / snap.min) * snap.min;
      if (snappedDur < snap.min) snappedDur = snap.min;
      const slots = Math.max(1, Math.round(snappedDur / config.slotMin));
      const prevEnd = drag.card.end;
      const nextEnd = drag.card.start + slots - 1;
      if (nextEnd !== prevEnd) {
        drag.card.end = nextEnd;
        actions.moveCard(drag.card.id, drag.card.start, drag.card.laneId);
      } else {
        render.grid();
        ui.refreshInspectorValuesFromCard();
      }
      drag = null;
      return;
    }
    if (drag.isBlockMove && drag.block) {
      var blockStartRaw = Math.max(1, Math.round(Number(newStart) || 1) - Math.max(0, Math.round(Number(drag.block.anchorRelStart) || 0)));
      var blockStart = resolveInsertStartByEarlyCards_(String(newLane || drag.block.laneId || ''), blockStartRaw, drag.block.ids);
      const unchanged = (Math.round(Number(blockStart) || 1) === Math.round(Number(drag.block.baseStart) || 1)) &&
        (String(newLane || '') === String(drag.block.laneId || ''));
      if (!unchanged) actions.moveCardBlock(drag.block.ids, blockStart, newLane);
      else {
        render.grid();
        ui.refreshInspectorValuesFromCard();
      }
      drag = null;
      return;
    }
    const prevStart = drag.card.start;
    const prevEnd = drag.card.end;
    const prevLane = drag.card.laneId;
    const len = getCardLengthSlots_(drag.card);
    const nextStart = resolveInsertStartByEarlyCards_(String(newLane || drag.card.laneId || ''), newStart, [drag.card.id]);
    const nextEnd = nextStart + len - 1;
    if (nextStart !== prevStart || nextEnd !== prevEnd || String(newLane) !== String(prevLane)) {
      actions.moveCard(drag.card.id, nextStart, newLane);
    } else {
      render.grid();
      ui.refreshInspectorValuesFromCard();
    }
    drag = null;
  }

  function handleCanvasDrop_(e) {
    e.preventDefault();
    if (state.viewMode === 'lite') return;
    if (state.timezoneBlocked) return;
    if (state.undoBusy) return;
    const cardId = e.dataTransfer.getData('text/plain');
    const key = String(cardId || '');
    if (!key || !state.cards[key]) return;

    const c = state.cards[key];
      const rect = els.canvas.getBoundingClientRect();
      const scrollX = els.gridScroll ? els.gridScroll.scrollLeft : 0;
      const scrollY = els.gridScroll ? els.gridScroll.scrollTop : 0;
      const x = (e.clientX - rect.left) + scrollX;
      const y = (e.clientY - rect.top) + scrollY;

    const dropTarget = resolveDropTargetFromCanvas_(x, y);
    if (!dropTarget) return;
    const newStart = dropTarget.newStart;
    const newLane = dropTarget.newLane || c.laneId;
    var block = buildDragBlockForCard_(c.id);
    if (block) {
      var blockStartRaw = Math.max(1, Math.round(Number(newStart) || 1) - Math.max(0, Math.round(Number(block.anchorRelStart) || 0)));
      var blockStart = resolveInsertStartByEarlyCards_(String(newLane || block.laneId || ''), blockStartRaw, block.ids);
      actions.moveCardBlock(block.ids, blockStart, newLane);
      return;
    }
    var resolvedStart = resolveInsertStartByEarlyCards_(String(newLane || c.laneId || ''), newStart, [c.id]);
    if (!(state.assetCellSelection && isFinite(Number(state.assetCellSelection.rawStart)))) {
      state.selection = c.id;
    }
    actions.moveCard(c.id, resolvedStart, newLane);
  }

  function bindEvents() {
    const safeAdd = (id, evt, fn) => { const e = document.getElementById(id); if (e) e.addEventListener(evt, fn); };
    const isTypingElement_ = (el) => {
      if (!el) return false;
      const tag = String(el.tagName || '').toLowerCase();
      if (tag === 'input' || tag === 'textarea' || tag === 'select') return true;
      if (el.isContentEditable) return true;
      return false;
    };
    const pickGapFromCanvasEvent_ = (e) => {
      if (state.viewMode === 'lite') return;
      if (state.timezoneBlocked) return;
      if (state.undoBusy) return;
      if (Date.now() < Number(state.suppressCanvasPickUntil || 0)) return;
      const canvas = els.canvas || document.getElementById('grid-canvas');
      if (!canvas) return;
      if (e.target && e.target.closest && e.target.closest('.card')) return;
      var assetCellEl = (e.target && e.target.closest) ? e.target.closest('.asset-cell') : null;
      if (assetCellEl) {
        var directSel = selectionFromAssetCellElement_(assetCellEl);
        if (directSel) {
          actions.selectAssetCell(directSel);
          return;
        }
      }
      const rect = canvas.getBoundingClientRect();
      const scrollX = els.gridScroll ? els.gridScroll.scrollLeft : 0;
      const scrollY = els.gridScroll ? els.gridScroll.scrollTop : 0;
      const x = (e.clientX - rect.left) + scrollX;
      const y = (e.clientY - rect.top) + scrollY;
      const assetSel = resolveAssetCellFromCanvasPoint_(x, y);
      if (assetSel) {
        actions.selectAssetCell(assetSel);
        return;
      }
      const lanes = getVisibleLanes_();
      if (!lanes.length) {
        actions.clearGapSelection();
        actions.clearAssetCellSelection({ skipRender: true });
        return;
      }
      const laneWidth = getLaneWidth_();
      const laneIdx = Math.floor(x / laneWidth);
      if (!isFinite(laneIdx) || laneIdx < 0 || laneIdx >= lanes.length) {
        actions.clearGapSelection();
        actions.clearAssetCellSelection({ skipRender: true });
        return;
      }
      const laneId = lanes[laneIdx].id;
      const slotHit = canvasPointToSlot_(y);
      if (!slotHit) {
        actions.clearGapSelection();
        actions.clearAssetCellSelection({ skipRender: true });
        return;
      }
      const gap = findGapAtSlot_(laneId, slotHit.rawSlot);
      if (!gap) {
        actions.clearGapSelection();
        actions.clearAssetCellSelection({ skipRender: true });
        return;
      }
      actions.selectGap(gap);
    };
    safeAdd('sel-start-preset', 'change', (e) => actions.setStartPreset(e.target.value));
    safeAdd('sel-end-preset', 'change', (e) => actions.setEndPreset(e.target.value));
    safeAdd('sel-range', 'change', (e) => {
      const value = String(e && e.target ? e.target.value : '').trim();
      if (!value || value === 'custom') return;
      actions.setDuration(value);
    });
    safeAdd('sel-card-main', 'change', (e) => actions.setCardDisplayField('main', e.target.value));
    safeAdd('sel-card-sub', 'change', (e) => actions.setCardDisplayField('sub', e.target.value));
    safeAdd('sel-taskless-main', 'change', (e) => actions.setCardDisplayField('taskless_main', e.target.value));
    safeAdd('sel-taskless-sub', 'change', (e) => actions.setCardDisplayField('taskless_sub', e.target.value));
    safeAdd('btn-card-add-field', 'click', () => actions.addCardDisplayFieldFromSettings());
    safeAdd('btn-settings-save', 'click', actions.saveViewSettings);
    safeAdd('inp-color-not-started', 'change', (e) => actions.setCardColorFromSettings('notStarted', e.target.value));
    safeAdd('inp-color-in-progress', 'change', (e) => actions.setCardColorFromSettings('inProgress', e.target.value));
    safeAdd('inp-color-review', 'change', (e) => actions.setCardColorFromSettings('review', e.target.value));
    safeAdd('inp-color-approved', 'change', (e) => actions.setCardColorFromSettings('approved', e.target.value));
    safeAdd('inp-color-completed', 'change', (e) => actions.setCardColorFromSettings('completed', e.target.value));
    safeAdd('inp-color-camera', 'change', (e) => actions.setCardColorFromSettings('camera', e.target.value));
    safeAdd('inp-color-taskless', 'change', (e) => actions.setCardColorFromSettings('taskless', e.target.value));
    safeAdd('inp-zoom', 'input', (e) => actions.setZoomFromSlider(e.target.value));
    safeAdd('inp-zoom-val', 'change', (e) => actions.setZoomFromInput(e.target.value));
    safeAdd('btn-view-fit', 'click', () => actions.fitZoomToView());
    safeAdd('sel-view-mode', 'change', (e) => actions.setViewMode(e && e.target ? e.target.value : 'grid'));

    const syncRangeSelect_ = () => {
      const rangeSel = document.getElementById('sel-range');
      if (!rangeSel) return;
      const opts = getRangeOptions_().map(function(n){ return String(n); });
      rangeSel.value = opts.indexOf(String(state.dayCount)) >= 0 ? String(state.dayCount) : 'custom';
    };

    const startInput = document.getElementById('start-date');
    if (startInput) {
      let lastCommitTs = 0;
      const commitStartDate_ = () => {
        const now = Date.now();
        if (now - lastCommitTs < 80) return;
        lastCommitTs = now;
        const raw = String(startInput.value || '').trim();
        if (!raw) {
          store.updateStartDateInput();
          return;
        }
        const d = resolveDateInput_(raw);
        if (!d) {
          store.updateStartDateInput();
          return;
        }
        state.startDate = d;
        state.startPreset = 'custom';
        const presetSel = document.getElementById('sel-start-preset');
        if (presetSel) presetSel.value = 'custom';
        if (state.viewDriver === 'end' && state.endDate) {
          state.dayCount = computeDayCountByStartEnd_(state.startDate, state.endDate);
        } else {
          syncEndFromRange_();
        }
        store.calcDays();
        render.grid();
        markViewDirty_();
        store.updateStartDateInput();
        store.updateEndDateInput();
        syncRangeSelect_();
      };
      startInput.addEventListener('focus', () => { startInput.dataset.editing = '1'; });
      startInput.addEventListener('input', () => { startInput.dataset.editing = '1'; });
      startInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          startInput.dataset.editing = '0';
          commitStartDate_();
          startInput.blur();
        }
      });
      startInput.addEventListener('blur', () => {
        startInput.dataset.editing = '0';
        commitStartDate_();
      });
      startInput.addEventListener('change', () => {
        if (document.activeElement !== startInput) commitStartDate_();
      });
      startInput.addEventListener('paste', (e) => {
        const t = (e.clipboardData && e.clipboardData.getData) ? e.clipboardData.getData('text') : '';
        const d = resolveDateInput_(t);
        if (d) {
          e.preventDefault();
          startInput.value = utils.fmtYmdText(d);
          startInput.dataset.editing = '1';
        }
      });
    }

    const endInput = document.getElementById('end-date');
    if (endInput) {
      let lastCommitTs = 0;
      const commitEndDate_ = () => {
        const now = Date.now();
        if (now - lastCommitTs < 80) return;
        lastCommitTs = now;
        const raw = String(endInput.value || '').trim();
        if (!raw) {
          store.updateEndDateInput();
          return;
        }
        const d = resolveDateInput_(raw);
        if (!d) {
          store.updateEndDateInput();
          return;
        }
        state.endDate = d;
        state.endPreset = 'custom';
        state.viewDriver = 'end';
        const presetSel = document.getElementById('sel-end-preset');
        if (presetSel) presetSel.value = 'custom';
        state.dayCount = computeDayCountByStartEnd_(state.startDate, state.endDate);
        store.calcDays();
        render.grid();
        markViewDirty_();
        store.updateEndDateInput();
        syncRangeSelect_();
      };
      endInput.addEventListener('focus', () => { endInput.dataset.editing = '1'; });
      endInput.addEventListener('input', () => { endInput.dataset.editing = '1'; });
      endInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          endInput.dataset.editing = '0';
          commitEndDate_();
          endInput.blur();
        }
      });
      endInput.addEventListener('blur', () => {
        endInput.dataset.editing = '0';
        commitEndDate_();
      });
      endInput.addEventListener('change', () => {
        if (document.activeElement !== endInput) commitEndDate_();
      });
      endInput.addEventListener('paste', (e) => {
        const t = (e.clipboardData && e.clipboardData.getData) ? e.clipboardData.getData('text') : '';
        const d = resolveDateInput_(t);
        if (d) {
          e.preventDefault();
          endInput.value = utils.fmtYmdText(d);
          endInput.dataset.editing = '1';
        }
      });
    }
    safeAdd('chk-push', 'change', (e) => {
      state.autoPush = !!(e && e.target && e.target.checked);
      markViewDirty_();
    });
    safeAdd('btn-undo', 'click', actions.openUndoModal);
    safeAdd('btn-undo-modal-close', 'click', actions.closeUndoModal);
    safeAdd('btn-undo-snap-take', 'click', actions.takeSnapshotFromUndoMenu);
    safeAdd('btn-undo-modal-refresh', 'click', actions.loadUndoOptions);
    safeAdd('btn-undo-snap-rename', 'click', actions.renameSelectedSnapshot);
    safeAdd('btn-undo-apply', 'click', actions.undoToSelected);
    safeAdd('btn-remove-card-cancel', 'click', cancelRemoveCardFromLane_);
    safeAdd('btn-remove-card-confirm', 'click', confirmRemoveCardFromLane_);
    safeAdd('btn-insp', 'click', () => {
      const insp = document.getElementById('inspector');
      if (!insp) return;
      setInspectorClosed_(!insp.classList.contains('closed'));
    });
    safeAdd('btn-view', 'click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      toggleToolbarMenu_('view');
    });
    safeAdd('btn-lanes', 'click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      toggleToolbarMenu_('lane');
    });
    safeAdd('inp-lane-w', 'change', (e) => actions.setLaneWidth(e.target.value));
    safeAdd('inp-asset-w', 'change', (e) => actions.setAssetColWidth(e.target.value));
    safeAdd('btn-save-view', 'click', actions.saveViewSettings);
    safeAdd('btn-save-lane', 'click', actions.saveLaneSettings);
    safeAdd('btn-settings', 'click', () => {
      if (!ensureTimezoneReady_()) return;
      closeToolbarMenus_();
      setSettingsModalOpen_(true);
    });
    safeAdd('btn-sched-index', 'click', actions.openSchedIndex);
    safeAdd('btn-tz-guard-reload', 'click', () => actions.load({ forceNetwork: true }));
    safeAdd('btn-publish', 'click', actions.publish);
    safeAdd('btn-settings-close', 'click', () => setSettingsModalOpen_(false));
    safeAdd('btn-rename-sched-save', 'click', actions.renameSchedFromSettings);
    safeAdd('sched-rename-input', 'keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        actions.renameSchedFromSettings();
      }
    });
    safeAdd('btn-close-insp', 'click', () => setInspectorClosed_(true));
    safeAdd('tab-edit', 'click', () => ui.switchTab('edit'));
    safeAdd('tab-list', 'click', () => ui.switchTab('list'));
    safeAdd('btn-auto', 'click', actions.autoCreate);
    safeAdd('btn-new', 'click', actions.newCard);
    safeAdd('inp-filter', 'input', ui.renderCardList);
    safeAdd('sched-switch', 'change', (e) => actions.switchSched(e.target.value));
    safeAdd('grid-canvas', 'dragover', (e) => { e.preventDefault(); });
    safeAdd('grid-canvas', 'drop', handleCanvasDrop_);
    safeAdd('grid-canvas', 'mousedown', (e) => {
      if (state.undoBusy) return;
      if (e.button !== 0) return;
      pickGapFromCanvasEvent_(e);
    });
    safeAdd('grid-canvas', 'click', (e) => {
      if (state.undoBusy) return;
      if (e.button !== 0) return;
      pickGapFromCanvasEvent_(e);
    });
    if (els.settingsModal) {
      els.settingsModal.addEventListener('click', (e) => {
        if (e.target === els.settingsModal) setSettingsModalOpen_(false);
      });
    }
    const undoModal = document.getElementById('undo-modal');
    if (undoModal) {
      undoModal.addEventListener('click', (e) => {
        if (e.target === undoModal) actions.closeUndoModal();
      });
    }
    const removeCardModal = document.getElementById('remove-card-modal');
    if (removeCardModal) {
      removeCardModal.addEventListener('click', (e) => {
        if (e.target === removeCardModal) cancelRemoveCardFromLane_();
      });
    }
    document.addEventListener('keydown', (e) => {
      if (state.timezoneBlocked) {
        if (e.key === 'Escape' || e.key === 'Delete' || e.key === 'Backspace' || e.key === 'Enter') {
          e.preventDefault();
          e.stopPropagation();
        }
        setTimezoneGuardModalOpen_(true);
        return;
      }
      if (state.undoBusy) {
        if (e.key === 'Delete' || e.key === 'Backspace' || e.key === 'Escape' || e.key === 'Enter') {
          e.preventDefault();
          e.stopPropagation();
        }
        return;
      }
      if (state.gapSelection && (e.key === 'Delete' || (e.key === 'Backspace' && !isTypingElement_(e.target)))) {
        e.preventDefault();
        e.stopPropagation();
        actions.closeSelectedGap();
        return;
      }
      if (e.key === 'Escape') {
        closeToolbarMenus_();
        cancelRemoveCardFromLane_();
        setSettingsModalOpen_(false);
        setUndoModalOpen_(false);
        actions.clearGapSelection();
        actions.clearAssetCellSelection({ skipRender: true });
        actions.clearMultiSelection();
        clearDragPreviewNodes_();
        ui.renderInspector();
      }
    });
    document.addEventListener('click', (e) => {
      const inToolbarPopup = !!(e.target && e.target.closest && e.target.closest('.toolbar-group'));
      if (!inToolbarPopup) closeToolbarMenus_();
    });
    initInspectorResizer_();
    const insp = document.getElementById('inspector');
    if (insp) setInspectorClosed_(insp.classList.contains('closed'));
  }

  return { actions, ui, state, render, bindEvents };
})();

document.addEventListener('DOMContentLoaded', () => {
  if (window.app && window.app.bindEvents) {
    window.app.bindEvents();
    window.app.actions.load();
  }
});
</script>
</body>
</html>
